var Bf=Object.defineProperty;var uc=Object.getOwnPropertySymbols;var zf=Object.prototype.hasOwnProperty,Of=Object.prototype.propertyIsEnumerable;var dc=(o,t,e)=>t in o?Bf(o,t,{enumerable:!0,configurable:!0,writable:!0,value:e}):o[t]=e,pc=(o,t)=>{for(var e in t||(t={}))zf.call(t,e)&&dc(o,e,t[e]);if(uc)for(var e of uc(t))Of.call(t,e)&&dc(o,e,t[e]);return o};import{c as Uf,r as Hf,j as Gf,a as on}from"./index.a4ff4c8b.js";import*as $t from"https://threejsfundamentals.org/threejs/resources/threejs/r132/build/three.module.js";import{OrbitControls as Wf}from"https://threejsfundamentals.org/threejs/resources/threejs/r132/examples/jsm/controls/OrbitControls.js";/**
 * @license
 * Copyright 2010-2021 Three.js Authors
 * SPDX-License-Identifier: MIT
 */const Da="136",qf=0,fc=1,jf=2,zh=1,Xf=2,Ir=3,zr=0,ge=1,$i=2,Oh=1,Wn=0,kr=1,mc=2,gc=3,vc=4,$f=5,Hi=100,Yf=101,Jf=102,_c=103,xc=104,Zf=200,Kf=201,Qf=202,tm=203,Uh=204,Hh=205,em=206,nm=207,im=208,rm=209,sm=210,om=0,am=1,lm=2,ba=3,cm=4,hm=5,um=6,dm=7,Zs=0,pm=1,fm=2,qn=0,mm=1,gm=2,vm=3,_m=4,xm=5,Gh=300,jr=301,Xr=302,ya=303,wa=304,Ks=306,Ia=307,Ma=1e3,qe=1001,Sa=1002,ve=1003,bc=1004,yc=1005,Le=1006,bm=1007,Qs=1008,En=1009,ym=1010,wm=1011,Or=1012,Mm=1013,Hs=1014,Gn=1015,ci=1016,Sm=1017,Em=1018,Tm=1019,ji=1020,Cm=1021,hi=1022,be=1023,Am=1024,Pm=1025,ui=1026,Yi=1027,Lm=1028,Rm=1029,Dm=1030,Im=1031,Nm=1032,Fm=1033,wc=33776,Mc=33777,Sc=33778,Ec=33779,Tc=35840,Cc=35841,Ac=35842,Pc=35843,km=36196,Lc=37492,Rc=37496,Vm=37808,Bm=37809,zm=37810,Om=37811,Um=37812,Hm=37813,Gm=37814,Wm=37815,qm=37816,jm=37817,Xm=37818,$m=37819,Ym=37820,Jm=37821,Zm=36492,Km=37840,Qm=37841,tg=37842,eg=37843,ng=37844,ig=37845,rg=37846,sg=37847,og=37848,ag=37849,lg=37850,cg=37851,hg=37852,ug=37853,dg=2200,pg=2201,fg=2202,Gs=2300,Ws=2301,ko=2302,Gi=2400,Wi=2401,qs=2402,Na=2500,Wh=2501,mg=0,en=3e3,Ki=3001,gg=3200,vg=3201,Qi=0,_g=1,Vo=7680,xg=519,Ur=35044,js=35048,Dc="300 es";class pi{addEventListener(t,e){this._listeners===void 0&&(this._listeners={});const n=this._listeners;n[t]===void 0&&(n[t]=[]),n[t].indexOf(e)===-1&&n[t].push(e)}hasEventListener(t,e){if(this._listeners===void 0)return!1;const n=this._listeners;return n[t]!==void 0&&n[t].indexOf(e)!==-1}removeEventListener(t,e){if(this._listeners===void 0)return;const r=this._listeners[t];if(r!==void 0){const s=r.indexOf(e);s!==-1&&r.splice(s,1)}}dispatchEvent(t){if(this._listeners===void 0)return;const n=this._listeners[t.type];if(n!==void 0){t.target=this;const r=n.slice(0);for(let s=0,l=r.length;s<l;s++)r[s].call(this,t);t.target=null}}}const Ee=[];for(let o=0;o<256;o++)Ee[o]=(o<16?"0":"")+o.toString(16);const Bo=Math.PI/180,Ea=180/Math.PI;function cn(){const o=Math.random()*4294967295|0,t=Math.random()*4294967295|0,e=Math.random()*4294967295|0,n=Math.random()*4294967295|0;return(Ee[o&255]+Ee[o>>8&255]+Ee[o>>16&255]+Ee[o>>24&255]+"-"+Ee[t&255]+Ee[t>>8&255]+"-"+Ee[t>>16&15|64]+Ee[t>>24&255]+"-"+Ee[e&63|128]+Ee[e>>8&255]+"-"+Ee[e>>16&255]+Ee[e>>24&255]+Ee[n&255]+Ee[n>>8&255]+Ee[n>>16&255]+Ee[n>>24&255]).toUpperCase()}function We(o,t,e){return Math.max(t,Math.min(e,o))}function bg(o,t){return(o%t+t)%t}function zo(o,t,e){return(1-e)*o+e*t}function Ic(o){return(o&o-1)===0&&o!==0}function yg(o){return Math.pow(2,Math.floor(Math.log(o)/Math.LN2))}class st{constructor(t=0,e=0){this.x=t,this.y=e}get width(){return this.x}set width(t){this.x=t}get height(){return this.y}set height(t){this.y=t}set(t,e){return this.x=t,this.y=e,this}setScalar(t){return this.x=t,this.y=t,this}setX(t){return this.x=t,this}setY(t){return this.y=t,this}setComponent(t,e){switch(t){case 0:this.x=e;break;case 1:this.y=e;break;default:throw new Error("index is out of range: "+t)}return this}getComponent(t){switch(t){case 0:return this.x;case 1:return this.y;default:throw new Error("index is out of range: "+t)}}clone(){return new this.constructor(this.x,this.y)}copy(t){return this.x=t.x,this.y=t.y,this}add(t,e){return e!==void 0?(console.warn("THREE.Vector2: .add() now only accepts one argument. Use .addVectors( a, b ) instead."),this.addVectors(t,e)):(this.x+=t.x,this.y+=t.y,this)}addScalar(t){return this.x+=t,this.y+=t,this}addVectors(t,e){return this.x=t.x+e.x,this.y=t.y+e.y,this}addScaledVector(t,e){return this.x+=t.x*e,this.y+=t.y*e,this}sub(t,e){return e!==void 0?(console.warn("THREE.Vector2: .sub() now only accepts one argument. Use .subVectors( a, b ) instead."),this.subVectors(t,e)):(this.x-=t.x,this.y-=t.y,this)}subScalar(t){return this.x-=t,this.y-=t,this}subVectors(t,e){return this.x=t.x-e.x,this.y=t.y-e.y,this}multiply(t){return this.x*=t.x,this.y*=t.y,this}multiplyScalar(t){return this.x*=t,this.y*=t,this}divide(t){return this.x/=t.x,this.y/=t.y,this}divideScalar(t){return this.multiplyScalar(1/t)}applyMatrix3(t){const e=this.x,n=this.y,r=t.elements;return this.x=r[0]*e+r[3]*n+r[6],this.y=r[1]*e+r[4]*n+r[7],this}min(t){return this.x=Math.min(this.x,t.x),this.y=Math.min(this.y,t.y),this}max(t){return this.x=Math.max(this.x,t.x),this.y=Math.max(this.y,t.y),this}clamp(t,e){return this.x=Math.max(t.x,Math.min(e.x,this.x)),this.y=Math.max(t.y,Math.min(e.y,this.y)),this}clampScalar(t,e){return this.x=Math.max(t,Math.min(e,this.x)),this.y=Math.max(t,Math.min(e,this.y)),this}clampLength(t,e){const n=this.length();return this.divideScalar(n||1).multiplyScalar(Math.max(t,Math.min(e,n)))}floor(){return this.x=Math.floor(this.x),this.y=Math.floor(this.y),this}ceil(){return this.x=Math.ceil(this.x),this.y=Math.ceil(this.y),this}round(){return this.x=Math.round(this.x),this.y=Math.round(this.y),this}roundToZero(){return this.x=this.x<0?Math.ceil(this.x):Math.floor(this.x),this.y=this.y<0?Math.ceil(this.y):Math.floor(this.y),this}negate(){return this.x=-this.x,this.y=-this.y,this}dot(t){return this.x*t.x+this.y*t.y}cross(t){return this.x*t.y-this.y*t.x}lengthSq(){return this.x*this.x+this.y*this.y}length(){return Math.sqrt(this.x*this.x+this.y*this.y)}manhattanLength(){return Math.abs(this.x)+Math.abs(this.y)}normalize(){return this.divideScalar(this.length()||1)}angle(){return Math.atan2(-this.y,-this.x)+Math.PI}distanceTo(t){return Math.sqrt(this.distanceToSquared(t))}distanceToSquared(t){const e=this.x-t.x,n=this.y-t.y;return e*e+n*n}manhattanDistanceTo(t){return Math.abs(this.x-t.x)+Math.abs(this.y-t.y)}setLength(t){return this.normalize().multiplyScalar(t)}lerp(t,e){return this.x+=(t.x-this.x)*e,this.y+=(t.y-this.y)*e,this}lerpVectors(t,e,n){return this.x=t.x+(e.x-t.x)*n,this.y=t.y+(e.y-t.y)*n,this}equals(t){return t.x===this.x&&t.y===this.y}fromArray(t,e=0){return this.x=t[e],this.y=t[e+1],this}toArray(t=[],e=0){return t[e]=this.x,t[e+1]=this.y,t}fromBufferAttribute(t,e,n){return n!==void 0&&console.warn("THREE.Vector2: offset has been removed from .fromBufferAttribute()."),this.x=t.getX(e),this.y=t.getY(e),this}rotateAround(t,e){const n=Math.cos(e),r=Math.sin(e),s=this.x-t.x,l=this.y-t.y;return this.x=s*n-l*r+t.x,this.y=s*r+l*n+t.y,this}random(){return this.x=Math.random(),this.y=Math.random(),this}*[Symbol.iterator](){yield this.x,yield this.y}}st.prototype.isVector2=!0;class Te{constructor(){this.elements=[1,0,0,0,1,0,0,0,1],arguments.length>0&&console.error("THREE.Matrix3: the constructor no longer reads arguments. use .set() instead.")}set(t,e,n,r,s,l,h,d,p){const f=this.elements;return f[0]=t,f[1]=r,f[2]=h,f[3]=e,f[4]=s,f[5]=d,f[6]=n,f[7]=l,f[8]=p,this}identity(){return this.set(1,0,0,0,1,0,0,0,1),this}copy(t){const e=this.elements,n=t.elements;return e[0]=n[0],e[1]=n[1],e[2]=n[2],e[3]=n[3],e[4]=n[4],e[5]=n[5],e[6]=n[6],e[7]=n[7],e[8]=n[8],this}extractBasis(t,e,n){return t.setFromMatrix3Column(this,0),e.setFromMatrix3Column(this,1),n.setFromMatrix3Column(this,2),this}setFromMatrix4(t){const e=t.elements;return this.set(e[0],e[4],e[8],e[1],e[5],e[9],e[2],e[6],e[10]),this}multiply(t){return this.multiplyMatrices(this,t)}premultiply(t){return this.multiplyMatrices(t,this)}multiplyMatrices(t,e){const n=t.elements,r=e.elements,s=this.elements,l=n[0],h=n[3],d=n[6],p=n[1],f=n[4],m=n[7],g=n[2],_=n[5],y=n[8],w=r[0],S=r[3],x=r[6],v=r[1],N=r[4],M=r[7],R=r[2],F=r[5],k=r[8];return s[0]=l*w+h*v+d*R,s[3]=l*S+h*N+d*F,s[6]=l*x+h*M+d*k,s[1]=p*w+f*v+m*R,s[4]=p*S+f*N+m*F,s[7]=p*x+f*M+m*k,s[2]=g*w+_*v+y*R,s[5]=g*S+_*N+y*F,s[8]=g*x+_*M+y*k,this}multiplyScalar(t){const e=this.elements;return e[0]*=t,e[3]*=t,e[6]*=t,e[1]*=t,e[4]*=t,e[7]*=t,e[2]*=t,e[5]*=t,e[8]*=t,this}determinant(){const t=this.elements,e=t[0],n=t[1],r=t[2],s=t[3],l=t[4],h=t[5],d=t[6],p=t[7],f=t[8];return e*l*f-e*h*p-n*s*f+n*h*d+r*s*p-r*l*d}invert(){const t=this.elements,e=t[0],n=t[1],r=t[2],s=t[3],l=t[4],h=t[5],d=t[6],p=t[7],f=t[8],m=f*l-h*p,g=h*d-f*s,_=p*s-l*d,y=e*m+n*g+r*_;if(y===0)return this.set(0,0,0,0,0,0,0,0,0);const w=1/y;return t[0]=m*w,t[1]=(r*p-f*n)*w,t[2]=(h*n-r*l)*w,t[3]=g*w,t[4]=(f*e-r*d)*w,t[5]=(r*s-h*e)*w,t[6]=_*w,t[7]=(n*d-p*e)*w,t[8]=(l*e-n*s)*w,this}transpose(){let t;const e=this.elements;return t=e[1],e[1]=e[3],e[3]=t,t=e[2],e[2]=e[6],e[6]=t,t=e[5],e[5]=e[7],e[7]=t,this}getNormalMatrix(t){return this.setFromMatrix4(t).invert().transpose()}transposeIntoArray(t){const e=this.elements;return t[0]=e[0],t[1]=e[3],t[2]=e[6],t[3]=e[1],t[4]=e[4],t[5]=e[7],t[6]=e[2],t[7]=e[5],t[8]=e[8],this}setUvTransform(t,e,n,r,s,l,h){const d=Math.cos(s),p=Math.sin(s);return this.set(n*d,n*p,-n*(d*l+p*h)+l+t,-r*p,r*d,-r*(-p*l+d*h)+h+e,0,0,1),this}scale(t,e){const n=this.elements;return n[0]*=t,n[3]*=t,n[6]*=t,n[1]*=e,n[4]*=e,n[7]*=e,this}rotate(t){const e=Math.cos(t),n=Math.sin(t),r=this.elements,s=r[0],l=r[3],h=r[6],d=r[1],p=r[4],f=r[7];return r[0]=e*s+n*d,r[3]=e*l+n*p,r[6]=e*h+n*f,r[1]=-n*s+e*d,r[4]=-n*l+e*p,r[7]=-n*h+e*f,this}translate(t,e){const n=this.elements;return n[0]+=t*n[2],n[3]+=t*n[5],n[6]+=t*n[8],n[1]+=e*n[2],n[4]+=e*n[5],n[7]+=e*n[8],this}equals(t){const e=this.elements,n=t.elements;for(let r=0;r<9;r++)if(e[r]!==n[r])return!1;return!0}fromArray(t,e=0){for(let n=0;n<9;n++)this.elements[n]=t[n+e];return this}toArray(t=[],e=0){const n=this.elements;return t[e]=n[0],t[e+1]=n[1],t[e+2]=n[2],t[e+3]=n[3],t[e+4]=n[4],t[e+5]=n[5],t[e+6]=n[6],t[e+7]=n[7],t[e+8]=n[8],t}clone(){return new this.constructor().fromArray(this.elements)}}Te.prototype.isMatrix3=!0;function qh(o){if(o.length===0)return-1/0;let t=o[0];for(let e=1,n=o.length;e<n;++e)o[e]>t&&(t=o[e]);return t}function to(o){return document.createElementNS("http://www.w3.org/1999/xhtml",o)}let Mi;class tr{static getDataURL(t){if(/^data:/i.test(t.src)||typeof HTMLCanvasElement=="undefined")return t.src;let e;if(t instanceof HTMLCanvasElement)e=t;else{Mi===void 0&&(Mi=to("canvas")),Mi.width=t.width,Mi.height=t.height;const n=Mi.getContext("2d");t instanceof ImageData?n.putImageData(t,0,0):n.drawImage(t,0,0,t.width,t.height),e=Mi}return e.width>2048||e.height>2048?(console.warn("THREE.ImageUtils.getDataURL: Image converted to jpg for performance reasons",t),e.toDataURL("image/jpeg",.6)):e.toDataURL("image/png")}}let wg=0;class we extends pi{constructor(t=we.DEFAULT_IMAGE,e=we.DEFAULT_MAPPING,n=qe,r=qe,s=Le,l=Qs,h=be,d=En,p=1,f=en){super(),Object.defineProperty(this,"id",{value:wg++}),this.uuid=cn(),this.name="",this.image=t,this.mipmaps=[],this.mapping=e,this.wrapS=n,this.wrapT=r,this.magFilter=s,this.minFilter=l,this.anisotropy=p,this.format=h,this.internalFormat=null,this.type=d,this.offset=new st(0,0),this.repeat=new st(1,1),this.center=new st(0,0),this.rotation=0,this.matrixAutoUpdate=!0,this.matrix=new Te,this.generateMipmaps=!0,this.premultiplyAlpha=!1,this.flipY=!0,this.unpackAlignment=4,this.encoding=f,this.userData={},this.version=0,this.onUpdate=null,this.isRenderTargetTexture=!1}updateMatrix(){this.matrix.setUvTransform(this.offset.x,this.offset.y,this.repeat.x,this.repeat.y,this.rotation,this.center.x,this.center.y)}clone(){return new this.constructor().copy(this)}copy(t){return this.name=t.name,this.image=t.image,this.mipmaps=t.mipmaps.slice(0),this.mapping=t.mapping,this.wrapS=t.wrapS,this.wrapT=t.wrapT,this.magFilter=t.magFilter,this.minFilter=t.minFilter,this.anisotropy=t.anisotropy,this.format=t.format,this.internalFormat=t.internalFormat,this.type=t.type,this.offset.copy(t.offset),this.repeat.copy(t.repeat),this.center.copy(t.center),this.rotation=t.rotation,this.matrixAutoUpdate=t.matrixAutoUpdate,this.matrix.copy(t.matrix),this.generateMipmaps=t.generateMipmaps,this.premultiplyAlpha=t.premultiplyAlpha,this.flipY=t.flipY,this.unpackAlignment=t.unpackAlignment,this.encoding=t.encoding,this.userData=JSON.parse(JSON.stringify(t.userData)),this}toJSON(t){const e=t===void 0||typeof t=="string";if(!e&&t.textures[this.uuid]!==void 0)return t.textures[this.uuid];const n={metadata:{version:4.5,type:"Texture",generator:"Texture.toJSON"},uuid:this.uuid,name:this.name,mapping:this.mapping,repeat:[this.repeat.x,this.repeat.y],offset:[this.offset.x,this.offset.y],center:[this.center.x,this.center.y],rotation:this.rotation,wrap:[this.wrapS,this.wrapT],format:this.format,type:this.type,encoding:this.encoding,minFilter:this.minFilter,magFilter:this.magFilter,anisotropy:this.anisotropy,flipY:this.flipY,premultiplyAlpha:this.premultiplyAlpha,unpackAlignment:this.unpackAlignment};if(this.image!==void 0){const r=this.image;if(r.uuid===void 0&&(r.uuid=cn()),!e&&t.images[r.uuid]===void 0){let s;if(Array.isArray(r)){s=[];for(let l=0,h=r.length;l<h;l++)r[l].isDataTexture?s.push(Oo(r[l].image)):s.push(Oo(r[l]))}else s=Oo(r);t.images[r.uuid]={uuid:r.uuid,url:s}}n.image=r.uuid}return JSON.stringify(this.userData)!=="{}"&&(n.userData=this.userData),e||(t.textures[this.uuid]=n),n}dispose(){this.dispatchEvent({type:"dispose"})}transformUv(t){if(this.mapping!==Gh)return t;if(t.applyMatrix3(this.matrix),t.x<0||t.x>1)switch(this.wrapS){case Ma:t.x=t.x-Math.floor(t.x);break;case qe:t.x=t.x<0?0:1;break;case Sa:Math.abs(Math.floor(t.x)%2)===1?t.x=Math.ceil(t.x)-t.x:t.x=t.x-Math.floor(t.x);break}if(t.y<0||t.y>1)switch(this.wrapT){case Ma:t.y=t.y-Math.floor(t.y);break;case qe:t.y=t.y<0?0:1;break;case Sa:Math.abs(Math.floor(t.y)%2)===1?t.y=Math.ceil(t.y)-t.y:t.y=t.y-Math.floor(t.y);break}return this.flipY&&(t.y=1-t.y),t}set needsUpdate(t){t===!0&&this.version++}}we.DEFAULT_IMAGE=void 0;we.DEFAULT_MAPPING=Gh;we.prototype.isTexture=!0;function Oo(o){return typeof HTMLImageElement!="undefined"&&o instanceof HTMLImageElement||typeof HTMLCanvasElement!="undefined"&&o instanceof HTMLCanvasElement||typeof ImageBitmap!="undefined"&&o instanceof ImageBitmap?tr.getDataURL(o):o.data?{data:Array.prototype.slice.call(o.data),width:o.width,height:o.height,type:o.data.constructor.name}:(console.warn("THREE.Texture: Unable to serialize Texture."),{})}class re{constructor(t=0,e=0,n=0,r=1){this.x=t,this.y=e,this.z=n,this.w=r}get width(){return this.z}set width(t){this.z=t}get height(){return this.w}set height(t){this.w=t}set(t,e,n,r){return this.x=t,this.y=e,this.z=n,this.w=r,this}setScalar(t){return this.x=t,this.y=t,this.z=t,this.w=t,this}setX(t){return this.x=t,this}setY(t){return this.y=t,this}setZ(t){return this.z=t,this}setW(t){return this.w=t,this}setComponent(t,e){switch(t){case 0:this.x=e;break;case 1:this.y=e;break;case 2:this.z=e;break;case 3:this.w=e;break;default:throw new Error("index is out of range: "+t)}return this}getComponent(t){switch(t){case 0:return this.x;case 1:return this.y;case 2:return this.z;case 3:return this.w;default:throw new Error("index is out of range: "+t)}}clone(){return new this.constructor(this.x,this.y,this.z,this.w)}copy(t){return this.x=t.x,this.y=t.y,this.z=t.z,this.w=t.w!==void 0?t.w:1,this}add(t,e){return e!==void 0?(console.warn("THREE.Vector4: .add() now only accepts one argument. Use .addVectors( a, b ) instead."),this.addVectors(t,e)):(this.x+=t.x,this.y+=t.y,this.z+=t.z,this.w+=t.w,this)}addScalar(t){return this.x+=t,this.y+=t,this.z+=t,this.w+=t,this}addVectors(t,e){return this.x=t.x+e.x,this.y=t.y+e.y,this.z=t.z+e.z,this.w=t.w+e.w,this}addScaledVector(t,e){return this.x+=t.x*e,this.y+=t.y*e,this.z+=t.z*e,this.w+=t.w*e,this}sub(t,e){return e!==void 0?(console.warn("THREE.Vector4: .sub() now only accepts one argument. Use .subVectors( a, b ) instead."),this.subVectors(t,e)):(this.x-=t.x,this.y-=t.y,this.z-=t.z,this.w-=t.w,this)}subScalar(t){return this.x-=t,this.y-=t,this.z-=t,this.w-=t,this}subVectors(t,e){return this.x=t.x-e.x,this.y=t.y-e.y,this.z=t.z-e.z,this.w=t.w-e.w,this}multiply(t){return this.x*=t.x,this.y*=t.y,this.z*=t.z,this.w*=t.w,this}multiplyScalar(t){return this.x*=t,this.y*=t,this.z*=t,this.w*=t,this}applyMatrix4(t){const e=this.x,n=this.y,r=this.z,s=this.w,l=t.elements;return this.x=l[0]*e+l[4]*n+l[8]*r+l[12]*s,this.y=l[1]*e+l[5]*n+l[9]*r+l[13]*s,this.z=l[2]*e+l[6]*n+l[10]*r+l[14]*s,this.w=l[3]*e+l[7]*n+l[11]*r+l[15]*s,this}divideScalar(t){return this.multiplyScalar(1/t)}setAxisAngleFromQuaternion(t){this.w=2*Math.acos(t.w);const e=Math.sqrt(1-t.w*t.w);return e<1e-4?(this.x=1,this.y=0,this.z=0):(this.x=t.x/e,this.y=t.y/e,this.z=t.z/e),this}setAxisAngleFromRotationMatrix(t){let e,n,r,s;const d=t.elements,p=d[0],f=d[4],m=d[8],g=d[1],_=d[5],y=d[9],w=d[2],S=d[6],x=d[10];if(Math.abs(f-g)<.01&&Math.abs(m-w)<.01&&Math.abs(y-S)<.01){if(Math.abs(f+g)<.1&&Math.abs(m+w)<.1&&Math.abs(y+S)<.1&&Math.abs(p+_+x-3)<.1)return this.set(1,0,0,0),this;e=Math.PI;const N=(p+1)/2,M=(_+1)/2,R=(x+1)/2,F=(f+g)/4,k=(m+w)/4,j=(y+S)/4;return N>M&&N>R?N<.01?(n=0,r=.707106781,s=.707106781):(n=Math.sqrt(N),r=F/n,s=k/n):M>R?M<.01?(n=.707106781,r=0,s=.707106781):(r=Math.sqrt(M),n=F/r,s=j/r):R<.01?(n=.707106781,r=.707106781,s=0):(s=Math.sqrt(R),n=k/s,r=j/s),this.set(n,r,s,e),this}let v=Math.sqrt((S-y)*(S-y)+(m-w)*(m-w)+(g-f)*(g-f));return Math.abs(v)<.001&&(v=1),this.x=(S-y)/v,this.y=(m-w)/v,this.z=(g-f)/v,this.w=Math.acos((p+_+x-1)/2),this}min(t){return this.x=Math.min(this.x,t.x),this.y=Math.min(this.y,t.y),this.z=Math.min(this.z,t.z),this.w=Math.min(this.w,t.w),this}max(t){return this.x=Math.max(this.x,t.x),this.y=Math.max(this.y,t.y),this.z=Math.max(this.z,t.z),this.w=Math.max(this.w,t.w),this}clamp(t,e){return this.x=Math.max(t.x,Math.min(e.x,this.x)),this.y=Math.max(t.y,Math.min(e.y,this.y)),this.z=Math.max(t.z,Math.min(e.z,this.z)),this.w=Math.max(t.w,Math.min(e.w,this.w)),this}clampScalar(t,e){return this.x=Math.max(t,Math.min(e,this.x)),this.y=Math.max(t,Math.min(e,this.y)),this.z=Math.max(t,Math.min(e,this.z)),this.w=Math.max(t,Math.min(e,this.w)),this}clampLength(t,e){const n=this.length();return this.divideScalar(n||1).multiplyScalar(Math.max(t,Math.min(e,n)))}floor(){return this.x=Math.floor(this.x),this.y=Math.floor(this.y),this.z=Math.floor(this.z),this.w=Math.floor(this.w),this}ceil(){return this.x=Math.ceil(this.x),this.y=Math.ceil(this.y),this.z=Math.ceil(this.z),this.w=Math.ceil(this.w),this}round(){return this.x=Math.round(this.x),this.y=Math.round(this.y),this.z=Math.round(this.z),this.w=Math.round(this.w),this}roundToZero(){return this.x=this.x<0?Math.ceil(this.x):Math.floor(this.x),this.y=this.y<0?Math.ceil(this.y):Math.floor(this.y),this.z=this.z<0?Math.ceil(this.z):Math.floor(this.z),this.w=this.w<0?Math.ceil(this.w):Math.floor(this.w),this}negate(){return this.x=-this.x,this.y=-this.y,this.z=-this.z,this.w=-this.w,this}dot(t){return this.x*t.x+this.y*t.y+this.z*t.z+this.w*t.w}lengthSq(){return this.x*this.x+this.y*this.y+this.z*this.z+this.w*this.w}length(){return Math.sqrt(this.x*this.x+this.y*this.y+this.z*this.z+this.w*this.w)}manhattanLength(){return Math.abs(this.x)+Math.abs(this.y)+Math.abs(this.z)+Math.abs(this.w)}normalize(){return this.divideScalar(this.length()||1)}setLength(t){return this.normalize().multiplyScalar(t)}lerp(t,e){return this.x+=(t.x-this.x)*e,this.y+=(t.y-this.y)*e,this.z+=(t.z-this.z)*e,this.w+=(t.w-this.w)*e,this}lerpVectors(t,e,n){return this.x=t.x+(e.x-t.x)*n,this.y=t.y+(e.y-t.y)*n,this.z=t.z+(e.z-t.z)*n,this.w=t.w+(e.w-t.w)*n,this}equals(t){return t.x===this.x&&t.y===this.y&&t.z===this.z&&t.w===this.w}fromArray(t,e=0){return this.x=t[e],this.y=t[e+1],this.z=t[e+2],this.w=t[e+3],this}toArray(t=[],e=0){return t[e]=this.x,t[e+1]=this.y,t[e+2]=this.z,t[e+3]=this.w,t}fromBufferAttribute(t,e,n){return n!==void 0&&console.warn("THREE.Vector4: offset has been removed from .fromBufferAttribute()."),this.x=t.getX(e),this.y=t.getY(e),this.z=t.getZ(e),this.w=t.getW(e),this}random(){return this.x=Math.random(),this.y=Math.random(),this.z=Math.random(),this.w=Math.random(),this}*[Symbol.iterator](){yield this.x,yield this.y,yield this.z,yield this.w}}re.prototype.isVector4=!0;class Ye extends pi{constructor(t,e,n={}){super(),this.width=t,this.height=e,this.depth=1,this.scissor=new re(0,0,t,e),this.scissorTest=!1,this.viewport=new re(0,0,t,e),this.texture=new we(void 0,n.mapping,n.wrapS,n.wrapT,n.magFilter,n.minFilter,n.format,n.type,n.anisotropy,n.encoding),this.texture.isRenderTargetTexture=!0,this.texture.image={width:t,height:e,depth:1},this.texture.generateMipmaps=n.generateMipmaps!==void 0?n.generateMipmaps:!1,this.texture.internalFormat=n.internalFormat!==void 0?n.internalFormat:null,this.texture.minFilter=n.minFilter!==void 0?n.minFilter:Le,this.depthBuffer=n.depthBuffer!==void 0?n.depthBuffer:!0,this.stencilBuffer=n.stencilBuffer!==void 0?n.stencilBuffer:!1,this.depthTexture=n.depthTexture!==void 0?n.depthTexture:null}setTexture(t){t.image={width:this.width,height:this.height,depth:this.depth},this.texture=t}setSize(t,e,n=1){(this.width!==t||this.height!==e||this.depth!==n)&&(this.width=t,this.height=e,this.depth=n,this.texture.image.width=t,this.texture.image.height=e,this.texture.image.depth=n,this.dispose()),this.viewport.set(0,0,t,e),this.scissor.set(0,0,t,e)}clone(){return new this.constructor().copy(this)}copy(t){return this.width=t.width,this.height=t.height,this.depth=t.depth,this.viewport.copy(t.viewport),this.texture=t.texture.clone(),this.texture.image=pc({},this.texture.image),this.depthBuffer=t.depthBuffer,this.stencilBuffer=t.stencilBuffer,this.depthTexture=t.depthTexture,this}dispose(){this.dispatchEvent({type:"dispose"})}}Ye.prototype.isWebGLRenderTarget=!0;class Mg extends Ye{constructor(t,e,n){super(t,e);const r=this.texture;this.texture=[];for(let s=0;s<n;s++)this.texture[s]=r.clone()}setSize(t,e,n=1){if(this.width!==t||this.height!==e||this.depth!==n){this.width=t,this.height=e,this.depth=n;for(let r=0,s=this.texture.length;r<s;r++)this.texture[r].image.width=t,this.texture[r].image.height=e,this.texture[r].image.depth=n;this.dispose()}return this.viewport.set(0,0,t,e),this.scissor.set(0,0,t,e),this}copy(t){this.dispose(),this.width=t.width,this.height=t.height,this.depth=t.depth,this.viewport.set(0,0,this.width,this.height),this.scissor.set(0,0,this.width,this.height),this.depthBuffer=t.depthBuffer,this.stencilBuffer=t.stencilBuffer,this.depthTexture=t.depthTexture,this.texture.length=0;for(let e=0,n=t.texture.length;e<n;e++)this.texture[e]=t.texture[e].clone();return this}}Mg.prototype.isWebGLMultipleRenderTargets=!0;class Fa extends Ye{constructor(t,e,n={}){super(t,e,n),this.samples=4,this.ignoreDepthForMultisampleCopy=n.ignoreDepth!==void 0?n.ignoreDepth:!0,this.useRenderToTexture=n.useRenderToTexture!==void 0?n.useRenderToTexture:!1,this.useRenderbuffer=this.useRenderToTexture===!1}copy(t){return super.copy.call(this,t),this.samples=t.samples,this.useRenderToTexture=t.useRenderToTexture,this.useRenderbuffer=t.useRenderbuffer,this}}Fa.prototype.isWebGLMultisampleRenderTarget=!0;class Be{constructor(t=0,e=0,n=0,r=1){this._x=t,this._y=e,this._z=n,this._w=r}static slerp(t,e,n,r){return console.warn("THREE.Quaternion: Static .slerp() has been deprecated. Use qm.slerpQuaternions( qa, qb, t ) instead."),n.slerpQuaternions(t,e,r)}static slerpFlat(t,e,n,r,s,l,h){let d=n[r+0],p=n[r+1],f=n[r+2],m=n[r+3];const g=s[l+0],_=s[l+1],y=s[l+2],w=s[l+3];if(h===0){t[e+0]=d,t[e+1]=p,t[e+2]=f,t[e+3]=m;return}if(h===1){t[e+0]=g,t[e+1]=_,t[e+2]=y,t[e+3]=w;return}if(m!==w||d!==g||p!==_||f!==y){let S=1-h;const x=d*g+p*_+f*y+m*w,v=x>=0?1:-1,N=1-x*x;if(N>Number.EPSILON){const R=Math.sqrt(N),F=Math.atan2(R,x*v);S=Math.sin(S*F)/R,h=Math.sin(h*F)/R}const M=h*v;if(d=d*S+g*M,p=p*S+_*M,f=f*S+y*M,m=m*S+w*M,S===1-h){const R=1/Math.sqrt(d*d+p*p+f*f+m*m);d*=R,p*=R,f*=R,m*=R}}t[e]=d,t[e+1]=p,t[e+2]=f,t[e+3]=m}static multiplyQuaternionsFlat(t,e,n,r,s,l){const h=n[r],d=n[r+1],p=n[r+2],f=n[r+3],m=s[l],g=s[l+1],_=s[l+2],y=s[l+3];return t[e]=h*y+f*m+d*_-p*g,t[e+1]=d*y+f*g+p*m-h*_,t[e+2]=p*y+f*_+h*g-d*m,t[e+3]=f*y-h*m-d*g-p*_,t}get x(){return this._x}set x(t){this._x=t,this._onChangeCallback()}get y(){return this._y}set y(t){this._y=t,this._onChangeCallback()}get z(){return this._z}set z(t){this._z=t,this._onChangeCallback()}get w(){return this._w}set w(t){this._w=t,this._onChangeCallback()}set(t,e,n,r){return this._x=t,this._y=e,this._z=n,this._w=r,this._onChangeCallback(),this}clone(){return new this.constructor(this._x,this._y,this._z,this._w)}copy(t){return this._x=t.x,this._y=t.y,this._z=t.z,this._w=t.w,this._onChangeCallback(),this}setFromEuler(t,e){if(!(t&&t.isEuler))throw new Error("THREE.Quaternion: .setFromEuler() now expects an Euler rotation rather than a Vector3 and order.");const n=t._x,r=t._y,s=t._z,l=t._order,h=Math.cos,d=Math.sin,p=h(n/2),f=h(r/2),m=h(s/2),g=d(n/2),_=d(r/2),y=d(s/2);switch(l){case"XYZ":this._x=g*f*m+p*_*y,this._y=p*_*m-g*f*y,this._z=p*f*y+g*_*m,this._w=p*f*m-g*_*y;break;case"YXZ":this._x=g*f*m+p*_*y,this._y=p*_*m-g*f*y,this._z=p*f*y-g*_*m,this._w=p*f*m+g*_*y;break;case"ZXY":this._x=g*f*m-p*_*y,this._y=p*_*m+g*f*y,this._z=p*f*y+g*_*m,this._w=p*f*m-g*_*y;break;case"ZYX":this._x=g*f*m-p*_*y,this._y=p*_*m+g*f*y,this._z=p*f*y-g*_*m,this._w=p*f*m+g*_*y;break;case"YZX":this._x=g*f*m+p*_*y,this._y=p*_*m+g*f*y,this._z=p*f*y-g*_*m,this._w=p*f*m-g*_*y;break;case"XZY":this._x=g*f*m-p*_*y,this._y=p*_*m-g*f*y,this._z=p*f*y+g*_*m,this._w=p*f*m+g*_*y;break;default:console.warn("THREE.Quaternion: .setFromEuler() encountered an unknown order: "+l)}return e!==!1&&this._onChangeCallback(),this}setFromAxisAngle(t,e){const n=e/2,r=Math.sin(n);return this._x=t.x*r,this._y=t.y*r,this._z=t.z*r,this._w=Math.cos(n),this._onChangeCallback(),this}setFromRotationMatrix(t){const e=t.elements,n=e[0],r=e[4],s=e[8],l=e[1],h=e[5],d=e[9],p=e[2],f=e[6],m=e[10],g=n+h+m;if(g>0){const _=.5/Math.sqrt(g+1);this._w=.25/_,this._x=(f-d)*_,this._y=(s-p)*_,this._z=(l-r)*_}else if(n>h&&n>m){const _=2*Math.sqrt(1+n-h-m);this._w=(f-d)/_,this._x=.25*_,this._y=(r+l)/_,this._z=(s+p)/_}else if(h>m){const _=2*Math.sqrt(1+h-n-m);this._w=(s-p)/_,this._x=(r+l)/_,this._y=.25*_,this._z=(d+f)/_}else{const _=2*Math.sqrt(1+m-n-h);this._w=(l-r)/_,this._x=(s+p)/_,this._y=(d+f)/_,this._z=.25*_}return this._onChangeCallback(),this}setFromUnitVectors(t,e){let n=t.dot(e)+1;return n<Number.EPSILON?(n=0,Math.abs(t.x)>Math.abs(t.z)?(this._x=-t.y,this._y=t.x,this._z=0,this._w=n):(this._x=0,this._y=-t.z,this._z=t.y,this._w=n)):(this._x=t.y*e.z-t.z*e.y,this._y=t.z*e.x-t.x*e.z,this._z=t.x*e.y-t.y*e.x,this._w=n),this.normalize()}angleTo(t){return 2*Math.acos(Math.abs(We(this.dot(t),-1,1)))}rotateTowards(t,e){const n=this.angleTo(t);if(n===0)return this;const r=Math.min(1,e/n);return this.slerp(t,r),this}identity(){return this.set(0,0,0,1)}invert(){return this.conjugate()}conjugate(){return this._x*=-1,this._y*=-1,this._z*=-1,this._onChangeCallback(),this}dot(t){return this._x*t._x+this._y*t._y+this._z*t._z+this._w*t._w}lengthSq(){return this._x*this._x+this._y*this._y+this._z*this._z+this._w*this._w}length(){return Math.sqrt(this._x*this._x+this._y*this._y+this._z*this._z+this._w*this._w)}normalize(){let t=this.length();return t===0?(this._x=0,this._y=0,this._z=0,this._w=1):(t=1/t,this._x=this._x*t,this._y=this._y*t,this._z=this._z*t,this._w=this._w*t),this._onChangeCallback(),this}multiply(t,e){return e!==void 0?(console.warn("THREE.Quaternion: .multiply() now only accepts one argument. Use .multiplyQuaternions( a, b ) instead."),this.multiplyQuaternions(t,e)):this.multiplyQuaternions(this,t)}premultiply(t){return this.multiplyQuaternions(t,this)}multiplyQuaternions(t,e){const n=t._x,r=t._y,s=t._z,l=t._w,h=e._x,d=e._y,p=e._z,f=e._w;return this._x=n*f+l*h+r*p-s*d,this._y=r*f+l*d+s*h-n*p,this._z=s*f+l*p+n*d-r*h,this._w=l*f-n*h-r*d-s*p,this._onChangeCallback(),this}slerp(t,e){if(e===0)return this;if(e===1)return this.copy(t);const n=this._x,r=this._y,s=this._z,l=this._w;let h=l*t._w+n*t._x+r*t._y+s*t._z;if(h<0?(this._w=-t._w,this._x=-t._x,this._y=-t._y,this._z=-t._z,h=-h):this.copy(t),h>=1)return this._w=l,this._x=n,this._y=r,this._z=s,this;const d=1-h*h;if(d<=Number.EPSILON){const _=1-e;return this._w=_*l+e*this._w,this._x=_*n+e*this._x,this._y=_*r+e*this._y,this._z=_*s+e*this._z,this.normalize(),this._onChangeCallback(),this}const p=Math.sqrt(d),f=Math.atan2(p,h),m=Math.sin((1-e)*f)/p,g=Math.sin(e*f)/p;return this._w=l*m+this._w*g,this._x=n*m+this._x*g,this._y=r*m+this._y*g,this._z=s*m+this._z*g,this._onChangeCallback(),this}slerpQuaternions(t,e,n){this.copy(t).slerp(e,n)}random(){const t=Math.random(),e=Math.sqrt(1-t),n=Math.sqrt(t),r=2*Math.PI*Math.random(),s=2*Math.PI*Math.random();return this.set(e*Math.cos(r),n*Math.sin(s),n*Math.cos(s),e*Math.sin(r))}equals(t){return t._x===this._x&&t._y===this._y&&t._z===this._z&&t._w===this._w}fromArray(t,e=0){return this._x=t[e],this._y=t[e+1],this._z=t[e+2],this._w=t[e+3],this._onChangeCallback(),this}toArray(t=[],e=0){return t[e]=this._x,t[e+1]=this._y,t[e+2]=this._z,t[e+3]=this._w,t}fromBufferAttribute(t,e){return this._x=t.getX(e),this._y=t.getY(e),this._z=t.getZ(e),this._w=t.getW(e),this}_onChange(t){return this._onChangeCallback=t,this}_onChangeCallback(){}}Be.prototype.isQuaternion=!0;class D{constructor(t=0,e=0,n=0){this.x=t,this.y=e,this.z=n}set(t,e,n){return n===void 0&&(n=this.z),this.x=t,this.y=e,this.z=n,this}setScalar(t){return this.x=t,this.y=t,this.z=t,this}setX(t){return this.x=t,this}setY(t){return this.y=t,this}setZ(t){return this.z=t,this}setComponent(t,e){switch(t){case 0:this.x=e;break;case 1:this.y=e;break;case 2:this.z=e;break;default:throw new Error("index is out of range: "+t)}return this}getComponent(t){switch(t){case 0:return this.x;case 1:return this.y;case 2:return this.z;default:throw new Error("index is out of range: "+t)}}clone(){return new this.constructor(this.x,this.y,this.z)}copy(t){return this.x=t.x,this.y=t.y,this.z=t.z,this}add(t,e){return e!==void 0?(console.warn("THREE.Vector3: .add() now only accepts one argument. Use .addVectors( a, b ) instead."),this.addVectors(t,e)):(this.x+=t.x,this.y+=t.y,this.z+=t.z,this)}addScalar(t){return this.x+=t,this.y+=t,this.z+=t,this}addVectors(t,e){return this.x=t.x+e.x,this.y=t.y+e.y,this.z=t.z+e.z,this}addScaledVector(t,e){return this.x+=t.x*e,this.y+=t.y*e,this.z+=t.z*e,this}sub(t,e){return e!==void 0?(console.warn("THREE.Vector3: .sub() now only accepts one argument. Use .subVectors( a, b ) instead."),this.subVectors(t,e)):(this.x-=t.x,this.y-=t.y,this.z-=t.z,this)}subScalar(t){return this.x-=t,this.y-=t,this.z-=t,this}subVectors(t,e){return this.x=t.x-e.x,this.y=t.y-e.y,this.z=t.z-e.z,this}multiply(t,e){return e!==void 0?(console.warn("THREE.Vector3: .multiply() now only accepts one argument. Use .multiplyVectors( a, b ) instead."),this.multiplyVectors(t,e)):(this.x*=t.x,this.y*=t.y,this.z*=t.z,this)}multiplyScalar(t){return this.x*=t,this.y*=t,this.z*=t,this}multiplyVectors(t,e){return this.x=t.x*e.x,this.y=t.y*e.y,this.z=t.z*e.z,this}applyEuler(t){return t&&t.isEuler||console.error("THREE.Vector3: .applyEuler() now expects an Euler rotation rather than a Vector3 and order."),this.applyQuaternion(Nc.setFromEuler(t))}applyAxisAngle(t,e){return this.applyQuaternion(Nc.setFromAxisAngle(t,e))}applyMatrix3(t){const e=this.x,n=this.y,r=this.z,s=t.elements;return this.x=s[0]*e+s[3]*n+s[6]*r,this.y=s[1]*e+s[4]*n+s[7]*r,this.z=s[2]*e+s[5]*n+s[8]*r,this}applyNormalMatrix(t){return this.applyMatrix3(t).normalize()}applyMatrix4(t){const e=this.x,n=this.y,r=this.z,s=t.elements,l=1/(s[3]*e+s[7]*n+s[11]*r+s[15]);return this.x=(s[0]*e+s[4]*n+s[8]*r+s[12])*l,this.y=(s[1]*e+s[5]*n+s[9]*r+s[13])*l,this.z=(s[2]*e+s[6]*n+s[10]*r+s[14])*l,this}applyQuaternion(t){const e=this.x,n=this.y,r=this.z,s=t.x,l=t.y,h=t.z,d=t.w,p=d*e+l*r-h*n,f=d*n+h*e-s*r,m=d*r+s*n-l*e,g=-s*e-l*n-h*r;return this.x=p*d+g*-s+f*-h-m*-l,this.y=f*d+g*-l+m*-s-p*-h,this.z=m*d+g*-h+p*-l-f*-s,this}project(t){return this.applyMatrix4(t.matrixWorldInverse).applyMatrix4(t.projectionMatrix)}unproject(t){return this.applyMatrix4(t.projectionMatrixInverse).applyMatrix4(t.matrixWorld)}transformDirection(t){const e=this.x,n=this.y,r=this.z,s=t.elements;return this.x=s[0]*e+s[4]*n+s[8]*r,this.y=s[1]*e+s[5]*n+s[9]*r,this.z=s[2]*e+s[6]*n+s[10]*r,this.normalize()}divide(t){return this.x/=t.x,this.y/=t.y,this.z/=t.z,this}divideScalar(t){return this.multiplyScalar(1/t)}min(t){return this.x=Math.min(this.x,t.x),this.y=Math.min(this.y,t.y),this.z=Math.min(this.z,t.z),this}max(t){return this.x=Math.max(this.x,t.x),this.y=Math.max(this.y,t.y),this.z=Math.max(this.z,t.z),this}clamp(t,e){return this.x=Math.max(t.x,Math.min(e.x,this.x)),this.y=Math.max(t.y,Math.min(e.y,this.y)),this.z=Math.max(t.z,Math.min(e.z,this.z)),this}clampScalar(t,e){return this.x=Math.max(t,Math.min(e,this.x)),this.y=Math.max(t,Math.min(e,this.y)),this.z=Math.max(t,Math.min(e,this.z)),this}clampLength(t,e){const n=this.length();return this.divideScalar(n||1).multiplyScalar(Math.max(t,Math.min(e,n)))}floor(){return this.x=Math.floor(this.x),this.y=Math.floor(this.y),this.z=Math.floor(this.z),this}ceil(){return this.x=Math.ceil(this.x),this.y=Math.ceil(this.y),this.z=Math.ceil(this.z),this}round(){return this.x=Math.round(this.x),this.y=Math.round(this.y),this.z=Math.round(this.z),this}roundToZero(){return this.x=this.x<0?Math.ceil(this.x):Math.floor(this.x),this.y=this.y<0?Math.ceil(this.y):Math.floor(this.y),this.z=this.z<0?Math.ceil(this.z):Math.floor(this.z),this}negate(){return this.x=-this.x,this.y=-this.y,this.z=-this.z,this}dot(t){return this.x*t.x+this.y*t.y+this.z*t.z}lengthSq(){return this.x*this.x+this.y*this.y+this.z*this.z}length(){return Math.sqrt(this.x*this.x+this.y*this.y+this.z*this.z)}manhattanLength(){return Math.abs(this.x)+Math.abs(this.y)+Math.abs(this.z)}normalize(){return this.divideScalar(this.length()||1)}setLength(t){return this.normalize().multiplyScalar(t)}lerp(t,e){return this.x+=(t.x-this.x)*e,this.y+=(t.y-this.y)*e,this.z+=(t.z-this.z)*e,this}lerpVectors(t,e,n){return this.x=t.x+(e.x-t.x)*n,this.y=t.y+(e.y-t.y)*n,this.z=t.z+(e.z-t.z)*n,this}cross(t,e){return e!==void 0?(console.warn("THREE.Vector3: .cross() now only accepts one argument. Use .crossVectors( a, b ) instead."),this.crossVectors(t,e)):this.crossVectors(this,t)}crossVectors(t,e){const n=t.x,r=t.y,s=t.z,l=e.x,h=e.y,d=e.z;return this.x=r*d-s*h,this.y=s*l-n*d,this.z=n*h-r*l,this}projectOnVector(t){const e=t.lengthSq();if(e===0)return this.set(0,0,0);const n=t.dot(this)/e;return this.copy(t).multiplyScalar(n)}projectOnPlane(t){return Uo.copy(this).projectOnVector(t),this.sub(Uo)}reflect(t){return this.sub(Uo.copy(t).multiplyScalar(2*this.dot(t)))}angleTo(t){const e=Math.sqrt(this.lengthSq()*t.lengthSq());if(e===0)return Math.PI/2;const n=this.dot(t)/e;return Math.acos(We(n,-1,1))}distanceTo(t){return Math.sqrt(this.distanceToSquared(t))}distanceToSquared(t){const e=this.x-t.x,n=this.y-t.y,r=this.z-t.z;return e*e+n*n+r*r}manhattanDistanceTo(t){return Math.abs(this.x-t.x)+Math.abs(this.y-t.y)+Math.abs(this.z-t.z)}setFromSpherical(t){return this.setFromSphericalCoords(t.radius,t.phi,t.theta)}setFromSphericalCoords(t,e,n){const r=Math.sin(e)*t;return this.x=r*Math.sin(n),this.y=Math.cos(e)*t,this.z=r*Math.cos(n),this}setFromCylindrical(t){return this.setFromCylindricalCoords(t.radius,t.theta,t.y)}setFromCylindricalCoords(t,e,n){return this.x=t*Math.sin(e),this.y=n,this.z=t*Math.cos(e),this}setFromMatrixPosition(t){const e=t.elements;return this.x=e[12],this.y=e[13],this.z=e[14],this}setFromMatrixScale(t){const e=this.setFromMatrixColumn(t,0).length(),n=this.setFromMatrixColumn(t,1).length(),r=this.setFromMatrixColumn(t,2).length();return this.x=e,this.y=n,this.z=r,this}setFromMatrixColumn(t,e){return this.fromArray(t.elements,e*4)}setFromMatrix3Column(t,e){return this.fromArray(t.elements,e*3)}equals(t){return t.x===this.x&&t.y===this.y&&t.z===this.z}fromArray(t,e=0){return this.x=t[e],this.y=t[e+1],this.z=t[e+2],this}toArray(t=[],e=0){return t[e]=this.x,t[e+1]=this.y,t[e+2]=this.z,t}fromBufferAttribute(t,e,n){return n!==void 0&&console.warn("THREE.Vector3: offset has been removed from .fromBufferAttribute()."),this.x=t.getX(e),this.y=t.getY(e),this.z=t.getZ(e),this}random(){return this.x=Math.random(),this.y=Math.random(),this.z=Math.random(),this}randomDirection(){const t=(Math.random()-.5)*2,e=Math.random()*Math.PI*2,n=Math.sqrt(1-t**2);return this.x=n*Math.cos(e),this.y=n*Math.sin(e),this.z=t,this}*[Symbol.iterator](){yield this.x,yield this.y,yield this.z}}D.prototype.isVector3=!0;const Uo=new D,Nc=new Be;class nn{constructor(t=new D(1/0,1/0,1/0),e=new D(-1/0,-1/0,-1/0)){this.min=t,this.max=e}set(t,e){return this.min.copy(t),this.max.copy(e),this}setFromArray(t){let e=1/0,n=1/0,r=1/0,s=-1/0,l=-1/0,h=-1/0;for(let d=0,p=t.length;d<p;d+=3){const f=t[d],m=t[d+1],g=t[d+2];f<e&&(e=f),m<n&&(n=m),g<r&&(r=g),f>s&&(s=f),m>l&&(l=m),g>h&&(h=g)}return this.min.set(e,n,r),this.max.set(s,l,h),this}setFromBufferAttribute(t){let e=1/0,n=1/0,r=1/0,s=-1/0,l=-1/0,h=-1/0;for(let d=0,p=t.count;d<p;d++){const f=t.getX(d),m=t.getY(d),g=t.getZ(d);f<e&&(e=f),m<n&&(n=m),g<r&&(r=g),f>s&&(s=f),m>l&&(l=m),g>h&&(h=g)}return this.min.set(e,n,r),this.max.set(s,l,h),this}setFromPoints(t){this.makeEmpty();for(let e=0,n=t.length;e<n;e++)this.expandByPoint(t[e]);return this}setFromCenterAndSize(t,e){const n=Mr.copy(e).multiplyScalar(.5);return this.min.copy(t).sub(n),this.max.copy(t).add(n),this}setFromObject(t){return this.makeEmpty(),this.expandByObject(t)}clone(){return new this.constructor().copy(this)}copy(t){return this.min.copy(t.min),this.max.copy(t.max),this}makeEmpty(){return this.min.x=this.min.y=this.min.z=1/0,this.max.x=this.max.y=this.max.z=-1/0,this}isEmpty(){return this.max.x<this.min.x||this.max.y<this.min.y||this.max.z<this.min.z}getCenter(t){return this.isEmpty()?t.set(0,0,0):t.addVectors(this.min,this.max).multiplyScalar(.5)}getSize(t){return this.isEmpty()?t.set(0,0,0):t.subVectors(this.max,this.min)}expandByPoint(t){return this.min.min(t),this.max.max(t),this}expandByVector(t){return this.min.sub(t),this.max.add(t),this}expandByScalar(t){return this.min.addScalar(-t),this.max.addScalar(t),this}expandByObject(t){t.updateWorldMatrix(!1,!1);const e=t.geometry;e!==void 0&&(e.boundingBox===null&&e.computeBoundingBox(),Ho.copy(e.boundingBox),Ho.applyMatrix4(t.matrixWorld),this.union(Ho));const n=t.children;for(let r=0,s=n.length;r<s;r++)this.expandByObject(n[r]);return this}containsPoint(t){return!(t.x<this.min.x||t.x>this.max.x||t.y<this.min.y||t.y>this.max.y||t.z<this.min.z||t.z>this.max.z)}containsBox(t){return this.min.x<=t.min.x&&t.max.x<=this.max.x&&this.min.y<=t.min.y&&t.max.y<=this.max.y&&this.min.z<=t.min.z&&t.max.z<=this.max.z}getParameter(t,e){return e.set((t.x-this.min.x)/(this.max.x-this.min.x),(t.y-this.min.y)/(this.max.y-this.min.y),(t.z-this.min.z)/(this.max.z-this.min.z))}intersectsBox(t){return!(t.max.x<this.min.x||t.min.x>this.max.x||t.max.y<this.min.y||t.min.y>this.max.y||t.max.z<this.min.z||t.min.z>this.max.z)}intersectsSphere(t){return this.clampPoint(t.center,Mr),Mr.distanceToSquared(t.center)<=t.radius*t.radius}intersectsPlane(t){let e,n;return t.normal.x>0?(e=t.normal.x*this.min.x,n=t.normal.x*this.max.x):(e=t.normal.x*this.max.x,n=t.normal.x*this.min.x),t.normal.y>0?(e+=t.normal.y*this.min.y,n+=t.normal.y*this.max.y):(e+=t.normal.y*this.max.y,n+=t.normal.y*this.min.y),t.normal.z>0?(e+=t.normal.z*this.min.z,n+=t.normal.z*this.max.z):(e+=t.normal.z*this.max.z,n+=t.normal.z*this.min.z),e<=-t.constant&&n>=-t.constant}intersectsTriangle(t){if(this.isEmpty())return!1;this.getCenter(Sr),hs.subVectors(this.max,Sr),Si.subVectors(t.a,Sr),Ei.subVectors(t.b,Sr),Ti.subVectors(t.c,Sr),Fn.subVectors(Ei,Si),kn.subVectors(Ti,Ei),si.subVectors(Si,Ti);let e=[0,-Fn.z,Fn.y,0,-kn.z,kn.y,0,-si.z,si.y,Fn.z,0,-Fn.x,kn.z,0,-kn.x,si.z,0,-si.x,-Fn.y,Fn.x,0,-kn.y,kn.x,0,-si.y,si.x,0];return!Go(e,Si,Ei,Ti,hs)||(e=[1,0,0,0,1,0,0,0,1],!Go(e,Si,Ei,Ti,hs))?!1:(us.crossVectors(Fn,kn),e=[us.x,us.y,us.z],Go(e,Si,Ei,Ti,hs))}clampPoint(t,e){return e.copy(t).clamp(this.min,this.max)}distanceToPoint(t){return Mr.copy(t).clamp(this.min,this.max).sub(t).length()}getBoundingSphere(t){return this.getCenter(t.center),t.radius=this.getSize(Mr).length()*.5,t}intersect(t){return this.min.max(t.min),this.max.min(t.max),this.isEmpty()&&this.makeEmpty(),this}union(t){return this.min.min(t.min),this.max.max(t.max),this}applyMatrix4(t){return this.isEmpty()?this:(_n[0].set(this.min.x,this.min.y,this.min.z).applyMatrix4(t),_n[1].set(this.min.x,this.min.y,this.max.z).applyMatrix4(t),_n[2].set(this.min.x,this.max.y,this.min.z).applyMatrix4(t),_n[3].set(this.min.x,this.max.y,this.max.z).applyMatrix4(t),_n[4].set(this.max.x,this.min.y,this.min.z).applyMatrix4(t),_n[5].set(this.max.x,this.min.y,this.max.z).applyMatrix4(t),_n[6].set(this.max.x,this.max.y,this.min.z).applyMatrix4(t),_n[7].set(this.max.x,this.max.y,this.max.z).applyMatrix4(t),this.setFromPoints(_n),this)}translate(t){return this.min.add(t),this.max.add(t),this}equals(t){return t.min.equals(this.min)&&t.max.equals(this.max)}}nn.prototype.isBox3=!0;const _n=[new D,new D,new D,new D,new D,new D,new D,new D],Mr=new D,Ho=new nn,Si=new D,Ei=new D,Ti=new D,Fn=new D,kn=new D,si=new D,Sr=new D,hs=new D,us=new D,oi=new D;function Go(o,t,e,n,r){for(let s=0,l=o.length-3;s<=l;s+=3){oi.fromArray(o,s);const h=r.x*Math.abs(oi.x)+r.y*Math.abs(oi.y)+r.z*Math.abs(oi.z),d=t.dot(oi),p=e.dot(oi),f=n.dot(oi);if(Math.max(-Math.max(d,p,f),Math.min(d,p,f))>h)return!1}return!0}const Sg=new nn,Fc=new D,ds=new D,Wo=new D;class er{constructor(t=new D,e=-1){this.center=t,this.radius=e}set(t,e){return this.center.copy(t),this.radius=e,this}setFromPoints(t,e){const n=this.center;e!==void 0?n.copy(e):Sg.setFromPoints(t).getCenter(n);let r=0;for(let s=0,l=t.length;s<l;s++)r=Math.max(r,n.distanceToSquared(t[s]));return this.radius=Math.sqrt(r),this}copy(t){return this.center.copy(t.center),this.radius=t.radius,this}isEmpty(){return this.radius<0}makeEmpty(){return this.center.set(0,0,0),this.radius=-1,this}containsPoint(t){return t.distanceToSquared(this.center)<=this.radius*this.radius}distanceToPoint(t){return t.distanceTo(this.center)-this.radius}intersectsSphere(t){const e=this.radius+t.radius;return t.center.distanceToSquared(this.center)<=e*e}intersectsBox(t){return t.intersectsSphere(this)}intersectsPlane(t){return Math.abs(t.distanceToPoint(this.center))<=this.radius}clampPoint(t,e){const n=this.center.distanceToSquared(t);return e.copy(t),n>this.radius*this.radius&&(e.sub(this.center).normalize(),e.multiplyScalar(this.radius).add(this.center)),e}getBoundingBox(t){return this.isEmpty()?(t.makeEmpty(),t):(t.set(this.center,this.center),t.expandByScalar(this.radius),t)}applyMatrix4(t){return this.center.applyMatrix4(t),this.radius=this.radius*t.getMaxScaleOnAxis(),this}translate(t){return this.center.add(t),this}expandByPoint(t){Wo.subVectors(t,this.center);const e=Wo.lengthSq();if(e>this.radius*this.radius){const n=Math.sqrt(e),r=(n-this.radius)*.5;this.center.add(Wo.multiplyScalar(r/n)),this.radius+=r}return this}union(t){return this.center.equals(t.center)===!0?ds.set(0,0,1).multiplyScalar(t.radius):ds.subVectors(t.center,this.center).normalize().multiplyScalar(t.radius),this.expandByPoint(Fc.copy(t.center).add(ds)),this.expandByPoint(Fc.copy(t.center).sub(ds)),this}equals(t){return t.center.equals(this.center)&&t.radius===this.radius}clone(){return new this.constructor().copy(this)}}const xn=new D,qo=new D,ps=new D,Vn=new D,jo=new D,fs=new D,Xo=new D;class nr{constructor(t=new D,e=new D(0,0,-1)){this.origin=t,this.direction=e}set(t,e){return this.origin.copy(t),this.direction.copy(e),this}copy(t){return this.origin.copy(t.origin),this.direction.copy(t.direction),this}at(t,e){return e.copy(this.direction).multiplyScalar(t).add(this.origin)}lookAt(t){return this.direction.copy(t).sub(this.origin).normalize(),this}recast(t){return this.origin.copy(this.at(t,xn)),this}closestPointToPoint(t,e){e.subVectors(t,this.origin);const n=e.dot(this.direction);return n<0?e.copy(this.origin):e.copy(this.direction).multiplyScalar(n).add(this.origin)}distanceToPoint(t){return Math.sqrt(this.distanceSqToPoint(t))}distanceSqToPoint(t){const e=xn.subVectors(t,this.origin).dot(this.direction);return e<0?this.origin.distanceToSquared(t):(xn.copy(this.direction).multiplyScalar(e).add(this.origin),xn.distanceToSquared(t))}distanceSqToSegment(t,e,n,r){qo.copy(t).add(e).multiplyScalar(.5),ps.copy(e).sub(t).normalize(),Vn.copy(this.origin).sub(qo);const s=t.distanceTo(e)*.5,l=-this.direction.dot(ps),h=Vn.dot(this.direction),d=-Vn.dot(ps),p=Vn.lengthSq(),f=Math.abs(1-l*l);let m,g,_,y;if(f>0)if(m=l*d-h,g=l*h-d,y=s*f,m>=0)if(g>=-y)if(g<=y){const w=1/f;m*=w,g*=w,_=m*(m+l*g+2*h)+g*(l*m+g+2*d)+p}else g=s,m=Math.max(0,-(l*g+h)),_=-m*m+g*(g+2*d)+p;else g=-s,m=Math.max(0,-(l*g+h)),_=-m*m+g*(g+2*d)+p;else g<=-y?(m=Math.max(0,-(-l*s+h)),g=m>0?-s:Math.min(Math.max(-s,-d),s),_=-m*m+g*(g+2*d)+p):g<=y?(m=0,g=Math.min(Math.max(-s,-d),s),_=g*(g+2*d)+p):(m=Math.max(0,-(l*s+h)),g=m>0?s:Math.min(Math.max(-s,-d),s),_=-m*m+g*(g+2*d)+p);else g=l>0?-s:s,m=Math.max(0,-(l*g+h)),_=-m*m+g*(g+2*d)+p;return n&&n.copy(this.direction).multiplyScalar(m).add(this.origin),r&&r.copy(ps).multiplyScalar(g).add(qo),_}intersectSphere(t,e){xn.subVectors(t.center,this.origin);const n=xn.dot(this.direction),r=xn.dot(xn)-n*n,s=t.radius*t.radius;if(r>s)return null;const l=Math.sqrt(s-r),h=n-l,d=n+l;return h<0&&d<0?null:h<0?this.at(d,e):this.at(h,e)}intersectsSphere(t){return this.distanceSqToPoint(t.center)<=t.radius*t.radius}distanceToPlane(t){const e=t.normal.dot(this.direction);if(e===0)return t.distanceToPoint(this.origin)===0?0:null;const n=-(this.origin.dot(t.normal)+t.constant)/e;return n>=0?n:null}intersectPlane(t,e){const n=this.distanceToPlane(t);return n===null?null:this.at(n,e)}intersectsPlane(t){const e=t.distanceToPoint(this.origin);return e===0||t.normal.dot(this.direction)*e<0}intersectBox(t,e){let n,r,s,l,h,d;const p=1/this.direction.x,f=1/this.direction.y,m=1/this.direction.z,g=this.origin;return p>=0?(n=(t.min.x-g.x)*p,r=(t.max.x-g.x)*p):(n=(t.max.x-g.x)*p,r=(t.min.x-g.x)*p),f>=0?(s=(t.min.y-g.y)*f,l=(t.max.y-g.y)*f):(s=(t.max.y-g.y)*f,l=(t.min.y-g.y)*f),n>l||s>r||((s>n||n!==n)&&(n=s),(l<r||r!==r)&&(r=l),m>=0?(h=(t.min.z-g.z)*m,d=(t.max.z-g.z)*m):(h=(t.max.z-g.z)*m,d=(t.min.z-g.z)*m),n>d||h>r)||((h>n||n!==n)&&(n=h),(d<r||r!==r)&&(r=d),r<0)?null:this.at(n>=0?n:r,e)}intersectsBox(t){return this.intersectBox(t,xn)!==null}intersectTriangle(t,e,n,r,s){jo.subVectors(e,t),fs.subVectors(n,t),Xo.crossVectors(jo,fs);let l=this.direction.dot(Xo),h;if(l>0){if(r)return null;h=1}else if(l<0)h=-1,l=-l;else return null;Vn.subVectors(this.origin,t);const d=h*this.direction.dot(fs.crossVectors(Vn,fs));if(d<0)return null;const p=h*this.direction.dot(jo.cross(Vn));if(p<0||d+p>l)return null;const f=-h*Vn.dot(Xo);return f<0?null:this.at(f/l,s)}applyMatrix4(t){return this.origin.applyMatrix4(t),this.direction.transformDirection(t),this}equals(t){return t.origin.equals(this.origin)&&t.direction.equals(this.direction)}clone(){return new this.constructor().copy(this)}}class At{constructor(){this.elements=[1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1],arguments.length>0&&console.error("THREE.Matrix4: the constructor no longer reads arguments. use .set() instead.")}set(t,e,n,r,s,l,h,d,p,f,m,g,_,y,w,S){const x=this.elements;return x[0]=t,x[4]=e,x[8]=n,x[12]=r,x[1]=s,x[5]=l,x[9]=h,x[13]=d,x[2]=p,x[6]=f,x[10]=m,x[14]=g,x[3]=_,x[7]=y,x[11]=w,x[15]=S,this}identity(){return this.set(1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1),this}clone(){return new At().fromArray(this.elements)}copy(t){const e=this.elements,n=t.elements;return e[0]=n[0],e[1]=n[1],e[2]=n[2],e[3]=n[3],e[4]=n[4],e[5]=n[5],e[6]=n[6],e[7]=n[7],e[8]=n[8],e[9]=n[9],e[10]=n[10],e[11]=n[11],e[12]=n[12],e[13]=n[13],e[14]=n[14],e[15]=n[15],this}copyPosition(t){const e=this.elements,n=t.elements;return e[12]=n[12],e[13]=n[13],e[14]=n[14],this}setFromMatrix3(t){const e=t.elements;return this.set(e[0],e[3],e[6],0,e[1],e[4],e[7],0,e[2],e[5],e[8],0,0,0,0,1),this}extractBasis(t,e,n){return t.setFromMatrixColumn(this,0),e.setFromMatrixColumn(this,1),n.setFromMatrixColumn(this,2),this}makeBasis(t,e,n){return this.set(t.x,e.x,n.x,0,t.y,e.y,n.y,0,t.z,e.z,n.z,0,0,0,0,1),this}extractRotation(t){const e=this.elements,n=t.elements,r=1/Ci.setFromMatrixColumn(t,0).length(),s=1/Ci.setFromMatrixColumn(t,1).length(),l=1/Ci.setFromMatrixColumn(t,2).length();return e[0]=n[0]*r,e[1]=n[1]*r,e[2]=n[2]*r,e[3]=0,e[4]=n[4]*s,e[5]=n[5]*s,e[6]=n[6]*s,e[7]=0,e[8]=n[8]*l,e[9]=n[9]*l,e[10]=n[10]*l,e[11]=0,e[12]=0,e[13]=0,e[14]=0,e[15]=1,this}makeRotationFromEuler(t){t&&t.isEuler||console.error("THREE.Matrix4: .makeRotationFromEuler() now expects a Euler rotation rather than a Vector3 and order.");const e=this.elements,n=t.x,r=t.y,s=t.z,l=Math.cos(n),h=Math.sin(n),d=Math.cos(r),p=Math.sin(r),f=Math.cos(s),m=Math.sin(s);if(t.order==="XYZ"){const g=l*f,_=l*m,y=h*f,w=h*m;e[0]=d*f,e[4]=-d*m,e[8]=p,e[1]=_+y*p,e[5]=g-w*p,e[9]=-h*d,e[2]=w-g*p,e[6]=y+_*p,e[10]=l*d}else if(t.order==="YXZ"){const g=d*f,_=d*m,y=p*f,w=p*m;e[0]=g+w*h,e[4]=y*h-_,e[8]=l*p,e[1]=l*m,e[5]=l*f,e[9]=-h,e[2]=_*h-y,e[6]=w+g*h,e[10]=l*d}else if(t.order==="ZXY"){const g=d*f,_=d*m,y=p*f,w=p*m;e[0]=g-w*h,e[4]=-l*m,e[8]=y+_*h,e[1]=_+y*h,e[5]=l*f,e[9]=w-g*h,e[2]=-l*p,e[6]=h,e[10]=l*d}else if(t.order==="ZYX"){const g=l*f,_=l*m,y=h*f,w=h*m;e[0]=d*f,e[4]=y*p-_,e[8]=g*p+w,e[1]=d*m,e[5]=w*p+g,e[9]=_*p-y,e[2]=-p,e[6]=h*d,e[10]=l*d}else if(t.order==="YZX"){const g=l*d,_=l*p,y=h*d,w=h*p;e[0]=d*f,e[4]=w-g*m,e[8]=y*m+_,e[1]=m,e[5]=l*f,e[9]=-h*f,e[2]=-p*f,e[6]=_*m+y,e[10]=g-w*m}else if(t.order==="XZY"){const g=l*d,_=l*p,y=h*d,w=h*p;e[0]=d*f,e[4]=-m,e[8]=p*f,e[1]=g*m+w,e[5]=l*f,e[9]=_*m-y,e[2]=y*m-_,e[6]=h*f,e[10]=w*m+g}return e[3]=0,e[7]=0,e[11]=0,e[12]=0,e[13]=0,e[14]=0,e[15]=1,this}makeRotationFromQuaternion(t){return this.compose(Eg,t,Tg)}lookAt(t,e,n){const r=this.elements;return He.subVectors(t,e),He.lengthSq()===0&&(He.z=1),He.normalize(),Bn.crossVectors(n,He),Bn.lengthSq()===0&&(Math.abs(n.z)===1?He.x+=1e-4:He.z+=1e-4,He.normalize(),Bn.crossVectors(n,He)),Bn.normalize(),ms.crossVectors(He,Bn),r[0]=Bn.x,r[4]=ms.x,r[8]=He.x,r[1]=Bn.y,r[5]=ms.y,r[9]=He.y,r[2]=Bn.z,r[6]=ms.z,r[10]=He.z,this}multiply(t,e){return e!==void 0?(console.warn("THREE.Matrix4: .multiply() now only accepts one argument. Use .multiplyMatrices( a, b ) instead."),this.multiplyMatrices(t,e)):this.multiplyMatrices(this,t)}premultiply(t){return this.multiplyMatrices(t,this)}multiplyMatrices(t,e){const n=t.elements,r=e.elements,s=this.elements,l=n[0],h=n[4],d=n[8],p=n[12],f=n[1],m=n[5],g=n[9],_=n[13],y=n[2],w=n[6],S=n[10],x=n[14],v=n[3],N=n[7],M=n[11],R=n[15],F=r[0],k=r[4],j=r[8],ot=r[12],Y=r[1],V=r[5],C=r[9],A=r[13],H=r[2],q=r[6],O=r[10],U=r[14],X=r[3],_t=r[7],J=r[11],Z=r[15];return s[0]=l*F+h*Y+d*H+p*X,s[4]=l*k+h*V+d*q+p*_t,s[8]=l*j+h*C+d*O+p*J,s[12]=l*ot+h*A+d*U+p*Z,s[1]=f*F+m*Y+g*H+_*X,s[5]=f*k+m*V+g*q+_*_t,s[9]=f*j+m*C+g*O+_*J,s[13]=f*ot+m*A+g*U+_*Z,s[2]=y*F+w*Y+S*H+x*X,s[6]=y*k+w*V+S*q+x*_t,s[10]=y*j+w*C+S*O+x*J,s[14]=y*ot+w*A+S*U+x*Z,s[3]=v*F+N*Y+M*H+R*X,s[7]=v*k+N*V+M*q+R*_t,s[11]=v*j+N*C+M*O+R*J,s[15]=v*ot+N*A+M*U+R*Z,this}multiplyScalar(t){const e=this.elements;return e[0]*=t,e[4]*=t,e[8]*=t,e[12]*=t,e[1]*=t,e[5]*=t,e[9]*=t,e[13]*=t,e[2]*=t,e[6]*=t,e[10]*=t,e[14]*=t,e[3]*=t,e[7]*=t,e[11]*=t,e[15]*=t,this}determinant(){const t=this.elements,e=t[0],n=t[4],r=t[8],s=t[12],l=t[1],h=t[5],d=t[9],p=t[13],f=t[2],m=t[6],g=t[10],_=t[14],y=t[3],w=t[7],S=t[11],x=t[15];return y*(+s*d*m-r*p*m-s*h*g+n*p*g+r*h*_-n*d*_)+w*(+e*d*_-e*p*g+s*l*g-r*l*_+r*p*f-s*d*f)+S*(+e*p*m-e*h*_-s*l*m+n*l*_+s*h*f-n*p*f)+x*(-r*h*f-e*d*m+e*h*g+r*l*m-n*l*g+n*d*f)}transpose(){const t=this.elements;let e;return e=t[1],t[1]=t[4],t[4]=e,e=t[2],t[2]=t[8],t[8]=e,e=t[6],t[6]=t[9],t[9]=e,e=t[3],t[3]=t[12],t[12]=e,e=t[7],t[7]=t[13],t[13]=e,e=t[11],t[11]=t[14],t[14]=e,this}setPosition(t,e,n){const r=this.elements;return t.isVector3?(r[12]=t.x,r[13]=t.y,r[14]=t.z):(r[12]=t,r[13]=e,r[14]=n),this}invert(){const t=this.elements,e=t[0],n=t[1],r=t[2],s=t[3],l=t[4],h=t[5],d=t[6],p=t[7],f=t[8],m=t[9],g=t[10],_=t[11],y=t[12],w=t[13],S=t[14],x=t[15],v=m*S*p-w*g*p+w*d*_-h*S*_-m*d*x+h*g*x,N=y*g*p-f*S*p-y*d*_+l*S*_+f*d*x-l*g*x,M=f*w*p-y*m*p+y*h*_-l*w*_-f*h*x+l*m*x,R=y*m*d-f*w*d-y*h*g+l*w*g+f*h*S-l*m*S,F=e*v+n*N+r*M+s*R;if(F===0)return this.set(0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0);const k=1/F;return t[0]=v*k,t[1]=(w*g*s-m*S*s-w*r*_+n*S*_+m*r*x-n*g*x)*k,t[2]=(h*S*s-w*d*s+w*r*p-n*S*p-h*r*x+n*d*x)*k,t[3]=(m*d*s-h*g*s-m*r*p+n*g*p+h*r*_-n*d*_)*k,t[4]=N*k,t[5]=(f*S*s-y*g*s+y*r*_-e*S*_-f*r*x+e*g*x)*k,t[6]=(y*d*s-l*S*s-y*r*p+e*S*p+l*r*x-e*d*x)*k,t[7]=(l*g*s-f*d*s+f*r*p-e*g*p-l*r*_+e*d*_)*k,t[8]=M*k,t[9]=(y*m*s-f*w*s-y*n*_+e*w*_+f*n*x-e*m*x)*k,t[10]=(l*w*s-y*h*s+y*n*p-e*w*p-l*n*x+e*h*x)*k,t[11]=(f*h*s-l*m*s-f*n*p+e*m*p+l*n*_-e*h*_)*k,t[12]=R*k,t[13]=(f*w*r-y*m*r+y*n*g-e*w*g-f*n*S+e*m*S)*k,t[14]=(y*h*r-l*w*r-y*n*d+e*w*d+l*n*S-e*h*S)*k,t[15]=(l*m*r-f*h*r+f*n*d-e*m*d-l*n*g+e*h*g)*k,this}scale(t){const e=this.elements,n=t.x,r=t.y,s=t.z;return e[0]*=n,e[4]*=r,e[8]*=s,e[1]*=n,e[5]*=r,e[9]*=s,e[2]*=n,e[6]*=r,e[10]*=s,e[3]*=n,e[7]*=r,e[11]*=s,this}getMaxScaleOnAxis(){const t=this.elements,e=t[0]*t[0]+t[1]*t[1]+t[2]*t[2],n=t[4]*t[4]+t[5]*t[5]+t[6]*t[6],r=t[8]*t[8]+t[9]*t[9]+t[10]*t[10];return Math.sqrt(Math.max(e,n,r))}makeTranslation(t,e,n){return this.set(1,0,0,t,0,1,0,e,0,0,1,n,0,0,0,1),this}makeRotationX(t){const e=Math.cos(t),n=Math.sin(t);return this.set(1,0,0,0,0,e,-n,0,0,n,e,0,0,0,0,1),this}makeRotationY(t){const e=Math.cos(t),n=Math.sin(t);return this.set(e,0,n,0,0,1,0,0,-n,0,e,0,0,0,0,1),this}makeRotationZ(t){const e=Math.cos(t),n=Math.sin(t);return this.set(e,-n,0,0,n,e,0,0,0,0,1,0,0,0,0,1),this}makeRotationAxis(t,e){const n=Math.cos(e),r=Math.sin(e),s=1-n,l=t.x,h=t.y,d=t.z,p=s*l,f=s*h;return this.set(p*l+n,p*h-r*d,p*d+r*h,0,p*h+r*d,f*h+n,f*d-r*l,0,p*d-r*h,f*d+r*l,s*d*d+n,0,0,0,0,1),this}makeScale(t,e,n){return this.set(t,0,0,0,0,e,0,0,0,0,n,0,0,0,0,1),this}makeShear(t,e,n,r,s,l){return this.set(1,n,s,0,t,1,l,0,e,r,1,0,0,0,0,1),this}compose(t,e,n){const r=this.elements,s=e._x,l=e._y,h=e._z,d=e._w,p=s+s,f=l+l,m=h+h,g=s*p,_=s*f,y=s*m,w=l*f,S=l*m,x=h*m,v=d*p,N=d*f,M=d*m,R=n.x,F=n.y,k=n.z;return r[0]=(1-(w+x))*R,r[1]=(_+M)*R,r[2]=(y-N)*R,r[3]=0,r[4]=(_-M)*F,r[5]=(1-(g+x))*F,r[6]=(S+v)*F,r[7]=0,r[8]=(y+N)*k,r[9]=(S-v)*k,r[10]=(1-(g+w))*k,r[11]=0,r[12]=t.x,r[13]=t.y,r[14]=t.z,r[15]=1,this}decompose(t,e,n){const r=this.elements;let s=Ci.set(r[0],r[1],r[2]).length();const l=Ci.set(r[4],r[5],r[6]).length(),h=Ci.set(r[8],r[9],r[10]).length();this.determinant()<0&&(s=-s),t.x=r[12],t.y=r[13],t.z=r[14],Ke.copy(this);const p=1/s,f=1/l,m=1/h;return Ke.elements[0]*=p,Ke.elements[1]*=p,Ke.elements[2]*=p,Ke.elements[4]*=f,Ke.elements[5]*=f,Ke.elements[6]*=f,Ke.elements[8]*=m,Ke.elements[9]*=m,Ke.elements[10]*=m,e.setFromRotationMatrix(Ke),n.x=s,n.y=l,n.z=h,this}makePerspective(t,e,n,r,s,l){l===void 0&&console.warn("THREE.Matrix4: .makePerspective() has been redefined and has a new signature. Please check the docs.");const h=this.elements,d=2*s/(e-t),p=2*s/(n-r),f=(e+t)/(e-t),m=(n+r)/(n-r),g=-(l+s)/(l-s),_=-2*l*s/(l-s);return h[0]=d,h[4]=0,h[8]=f,h[12]=0,h[1]=0,h[5]=p,h[9]=m,h[13]=0,h[2]=0,h[6]=0,h[10]=g,h[14]=_,h[3]=0,h[7]=0,h[11]=-1,h[15]=0,this}makeOrthographic(t,e,n,r,s,l){const h=this.elements,d=1/(e-t),p=1/(n-r),f=1/(l-s),m=(e+t)*d,g=(n+r)*p,_=(l+s)*f;return h[0]=2*d,h[4]=0,h[8]=0,h[12]=-m,h[1]=0,h[5]=2*p,h[9]=0,h[13]=-g,h[2]=0,h[6]=0,h[10]=-2*f,h[14]=-_,h[3]=0,h[7]=0,h[11]=0,h[15]=1,this}equals(t){const e=this.elements,n=t.elements;for(let r=0;r<16;r++)if(e[r]!==n[r])return!1;return!0}fromArray(t,e=0){for(let n=0;n<16;n++)this.elements[n]=t[n+e];return this}toArray(t=[],e=0){const n=this.elements;return t[e]=n[0],t[e+1]=n[1],t[e+2]=n[2],t[e+3]=n[3],t[e+4]=n[4],t[e+5]=n[5],t[e+6]=n[6],t[e+7]=n[7],t[e+8]=n[8],t[e+9]=n[9],t[e+10]=n[10],t[e+11]=n[11],t[e+12]=n[12],t[e+13]=n[13],t[e+14]=n[14],t[e+15]=n[15],t}}At.prototype.isMatrix4=!0;const Ci=new D,Ke=new At,Eg=new D(0,0,0),Tg=new D(1,1,1),Bn=new D,ms=new D,He=new D,kc=new At,Vc=new Be;class ir{constructor(t=0,e=0,n=0,r=ir.DefaultOrder){this._x=t,this._y=e,this._z=n,this._order=r}get x(){return this._x}set x(t){this._x=t,this._onChangeCallback()}get y(){return this._y}set y(t){this._y=t,this._onChangeCallback()}get z(){return this._z}set z(t){this._z=t,this._onChangeCallback()}get order(){return this._order}set order(t){this._order=t,this._onChangeCallback()}set(t,e,n,r=this._order){return this._x=t,this._y=e,this._z=n,this._order=r,this._onChangeCallback(),this}clone(){return new this.constructor(this._x,this._y,this._z,this._order)}copy(t){return this._x=t._x,this._y=t._y,this._z=t._z,this._order=t._order,this._onChangeCallback(),this}setFromRotationMatrix(t,e=this._order,n=!0){const r=t.elements,s=r[0],l=r[4],h=r[8],d=r[1],p=r[5],f=r[9],m=r[2],g=r[6],_=r[10];switch(e){case"XYZ":this._y=Math.asin(We(h,-1,1)),Math.abs(h)<.9999999?(this._x=Math.atan2(-f,_),this._z=Math.atan2(-l,s)):(this._x=Math.atan2(g,p),this._z=0);break;case"YXZ":this._x=Math.asin(-We(f,-1,1)),Math.abs(f)<.9999999?(this._y=Math.atan2(h,_),this._z=Math.atan2(d,p)):(this._y=Math.atan2(-m,s),this._z=0);break;case"ZXY":this._x=Math.asin(We(g,-1,1)),Math.abs(g)<.9999999?(this._y=Math.atan2(-m,_),this._z=Math.atan2(-l,p)):(this._y=0,this._z=Math.atan2(d,s));break;case"ZYX":this._y=Math.asin(-We(m,-1,1)),Math.abs(m)<.9999999?(this._x=Math.atan2(g,_),this._z=Math.atan2(d,s)):(this._x=0,this._z=Math.atan2(-l,p));break;case"YZX":this._z=Math.asin(We(d,-1,1)),Math.abs(d)<.9999999?(this._x=Math.atan2(-f,p),this._y=Math.atan2(-m,s)):(this._x=0,this._y=Math.atan2(h,_));break;case"XZY":this._z=Math.asin(-We(l,-1,1)),Math.abs(l)<.9999999?(this._x=Math.atan2(g,p),this._y=Math.atan2(h,s)):(this._x=Math.atan2(-f,_),this._y=0);break;default:console.warn("THREE.Euler: .setFromRotationMatrix() encountered an unknown order: "+e)}return this._order=e,n===!0&&this._onChangeCallback(),this}setFromQuaternion(t,e,n){return kc.makeRotationFromQuaternion(t),this.setFromRotationMatrix(kc,e,n)}setFromVector3(t,e=this._order){return this.set(t.x,t.y,t.z,e)}reorder(t){return Vc.setFromEuler(this),this.setFromQuaternion(Vc,t)}equals(t){return t._x===this._x&&t._y===this._y&&t._z===this._z&&t._order===this._order}fromArray(t){return this._x=t[0],this._y=t[1],this._z=t[2],t[3]!==void 0&&(this._order=t[3]),this._onChangeCallback(),this}toArray(t=[],e=0){return t[e]=this._x,t[e+1]=this._y,t[e+2]=this._z,t[e+3]=this._order,t}toVector3(t){return t?t.set(this._x,this._y,this._z):new D(this._x,this._y,this._z)}_onChange(t){return this._onChangeCallback=t,this}_onChangeCallback(){}}ir.prototype.isEuler=!0;ir.DefaultOrder="XYZ";ir.RotationOrders=["XYZ","YZX","ZXY","XZY","YXZ","ZYX"];class jh{constructor(){this.mask=1}set(t){this.mask=(1<<t|0)>>>0}enable(t){this.mask|=1<<t|0}enableAll(){this.mask=-1}toggle(t){this.mask^=1<<t|0}disable(t){this.mask&=~(1<<t|0)}disableAll(){this.mask=0}test(t){return(this.mask&t.mask)!==0}isEnabled(t){return(this.mask&(1<<t|0))!==0}}let Cg=0;const Bc=new D,Ai=new Be,bn=new At,gs=new D,Er=new D,Ag=new D,Pg=new Be,zc=new D(1,0,0),Oc=new D(0,1,0),Uc=new D(0,0,1),Lg={type:"added"},Hc={type:"removed"};class te extends pi{constructor(){super(),Object.defineProperty(this,"id",{value:Cg++}),this.uuid=cn(),this.name="",this.type="Object3D",this.parent=null,this.children=[],this.up=te.DefaultUp.clone();const t=new D,e=new ir,n=new Be,r=new D(1,1,1);function s(){n.setFromEuler(e,!1)}function l(){e.setFromQuaternion(n,void 0,!1)}e._onChange(s),n._onChange(l),Object.defineProperties(this,{position:{configurable:!0,enumerable:!0,value:t},rotation:{configurable:!0,enumerable:!0,value:e},quaternion:{configurable:!0,enumerable:!0,value:n},scale:{configurable:!0,enumerable:!0,value:r},modelViewMatrix:{value:new At},normalMatrix:{value:new Te}}),this.matrix=new At,this.matrixWorld=new At,this.matrixAutoUpdate=te.DefaultMatrixAutoUpdate,this.matrixWorldNeedsUpdate=!1,this.layers=new jh,this.visible=!0,this.castShadow=!1,this.receiveShadow=!1,this.frustumCulled=!0,this.renderOrder=0,this.animations=[],this.userData={}}onBeforeRender(){}onAfterRender(){}applyMatrix4(t){this.matrixAutoUpdate&&this.updateMatrix(),this.matrix.premultiply(t),this.matrix.decompose(this.position,this.quaternion,this.scale)}applyQuaternion(t){return this.quaternion.premultiply(t),this}setRotationFromAxisAngle(t,e){this.quaternion.setFromAxisAngle(t,e)}setRotationFromEuler(t){this.quaternion.setFromEuler(t,!0)}setRotationFromMatrix(t){this.quaternion.setFromRotationMatrix(t)}setRotationFromQuaternion(t){this.quaternion.copy(t)}rotateOnAxis(t,e){return Ai.setFromAxisAngle(t,e),this.quaternion.multiply(Ai),this}rotateOnWorldAxis(t,e){return Ai.setFromAxisAngle(t,e),this.quaternion.premultiply(Ai),this}rotateX(t){return this.rotateOnAxis(zc,t)}rotateY(t){return this.rotateOnAxis(Oc,t)}rotateZ(t){return this.rotateOnAxis(Uc,t)}translateOnAxis(t,e){return Bc.copy(t).applyQuaternion(this.quaternion),this.position.add(Bc.multiplyScalar(e)),this}translateX(t){return this.translateOnAxis(zc,t)}translateY(t){return this.translateOnAxis(Oc,t)}translateZ(t){return this.translateOnAxis(Uc,t)}localToWorld(t){return t.applyMatrix4(this.matrixWorld)}worldToLocal(t){return t.applyMatrix4(bn.copy(this.matrixWorld).invert())}lookAt(t,e,n){t.isVector3?gs.copy(t):gs.set(t,e,n);const r=this.parent;this.updateWorldMatrix(!0,!1),Er.setFromMatrixPosition(this.matrixWorld),this.isCamera||this.isLight?bn.lookAt(Er,gs,this.up):bn.lookAt(gs,Er,this.up),this.quaternion.setFromRotationMatrix(bn),r&&(bn.extractRotation(r.matrixWorld),Ai.setFromRotationMatrix(bn),this.quaternion.premultiply(Ai.invert()))}add(t){if(arguments.length>1){for(let e=0;e<arguments.length;e++)this.add(arguments[e]);return this}return t===this?(console.error("THREE.Object3D.add: object can't be added as a child of itself.",t),this):(t&&t.isObject3D?(t.parent!==null&&t.parent.remove(t),t.parent=this,this.children.push(t),t.dispatchEvent(Lg)):console.error("THREE.Object3D.add: object not an instance of THREE.Object3D.",t),this)}remove(t){if(arguments.length>1){for(let n=0;n<arguments.length;n++)this.remove(arguments[n]);return this}const e=this.children.indexOf(t);return e!==-1&&(t.parent=null,this.children.splice(e,1),t.dispatchEvent(Hc)),this}removeFromParent(){const t=this.parent;return t!==null&&t.remove(this),this}clear(){for(let t=0;t<this.children.length;t++){const e=this.children[t];e.parent=null,e.dispatchEvent(Hc)}return this.children.length=0,this}attach(t){return this.updateWorldMatrix(!0,!1),bn.copy(this.matrixWorld).invert(),t.parent!==null&&(t.parent.updateWorldMatrix(!0,!1),bn.multiply(t.parent.matrixWorld)),t.applyMatrix4(bn),this.add(t),t.updateWorldMatrix(!1,!0),this}getObjectById(t){return this.getObjectByProperty("id",t)}getObjectByName(t){return this.getObjectByProperty("name",t)}getObjectByProperty(t,e){if(this[t]===e)return this;for(let n=0,r=this.children.length;n<r;n++){const l=this.children[n].getObjectByProperty(t,e);if(l!==void 0)return l}}getWorldPosition(t){return this.updateWorldMatrix(!0,!1),t.setFromMatrixPosition(this.matrixWorld)}getWorldQuaternion(t){return this.updateWorldMatrix(!0,!1),this.matrixWorld.decompose(Er,t,Ag),t}getWorldScale(t){return this.updateWorldMatrix(!0,!1),this.matrixWorld.decompose(Er,Pg,t),t}getWorldDirection(t){this.updateWorldMatrix(!0,!1);const e=this.matrixWorld.elements;return t.set(e[8],e[9],e[10]).normalize()}raycast(){}traverse(t){t(this);const e=this.children;for(let n=0,r=e.length;n<r;n++)e[n].traverse(t)}traverseVisible(t){if(this.visible===!1)return;t(this);const e=this.children;for(let n=0,r=e.length;n<r;n++)e[n].traverseVisible(t)}traverseAncestors(t){const e=this.parent;e!==null&&(t(e),e.traverseAncestors(t))}updateMatrix(){this.matrix.compose(this.position,this.quaternion,this.scale),this.matrixWorldNeedsUpdate=!0}updateMatrixWorld(t){this.matrixAutoUpdate&&this.updateMatrix(),(this.matrixWorldNeedsUpdate||t)&&(this.parent===null?this.matrixWorld.copy(this.matrix):this.matrixWorld.multiplyMatrices(this.parent.matrixWorld,this.matrix),this.matrixWorldNeedsUpdate=!1,t=!0);const e=this.children;for(let n=0,r=e.length;n<r;n++)e[n].updateMatrixWorld(t)}updateWorldMatrix(t,e){const n=this.parent;if(t===!0&&n!==null&&n.updateWorldMatrix(!0,!1),this.matrixAutoUpdate&&this.updateMatrix(),this.parent===null?this.matrixWorld.copy(this.matrix):this.matrixWorld.multiplyMatrices(this.parent.matrixWorld,this.matrix),e===!0){const r=this.children;for(let s=0,l=r.length;s<l;s++)r[s].updateWorldMatrix(!1,!0)}}toJSON(t){const e=t===void 0||typeof t=="string",n={};e&&(t={geometries:{},materials:{},textures:{},images:{},shapes:{},skeletons:{},animations:{}},n.metadata={version:4.5,type:"Object",generator:"Object3D.toJSON"});const r={};r.uuid=this.uuid,r.type=this.type,this.name!==""&&(r.name=this.name),this.castShadow===!0&&(r.castShadow=!0),this.receiveShadow===!0&&(r.receiveShadow=!0),this.visible===!1&&(r.visible=!1),this.frustumCulled===!1&&(r.frustumCulled=!1),this.renderOrder!==0&&(r.renderOrder=this.renderOrder),JSON.stringify(this.userData)!=="{}"&&(r.userData=this.userData),r.layers=this.layers.mask,r.matrix=this.matrix.toArray(),this.matrixAutoUpdate===!1&&(r.matrixAutoUpdate=!1),this.isInstancedMesh&&(r.type="InstancedMesh",r.count=this.count,r.instanceMatrix=this.instanceMatrix.toJSON(),this.instanceColor!==null&&(r.instanceColor=this.instanceColor.toJSON()));function s(h,d){return h[d.uuid]===void 0&&(h[d.uuid]=d.toJSON(t)),d.uuid}if(this.isScene)this.background&&(this.background.isColor?r.background=this.background.toJSON():this.background.isTexture&&(r.background=this.background.toJSON(t).uuid)),this.environment&&this.environment.isTexture&&(r.environment=this.environment.toJSON(t).uuid);else if(this.isMesh||this.isLine||this.isPoints){r.geometry=s(t.geometries,this.geometry);const h=this.geometry.parameters;if(h!==void 0&&h.shapes!==void 0){const d=h.shapes;if(Array.isArray(d))for(let p=0,f=d.length;p<f;p++){const m=d[p];s(t.shapes,m)}else s(t.shapes,d)}}if(this.isSkinnedMesh&&(r.bindMode=this.bindMode,r.bindMatrix=this.bindMatrix.toArray(),this.skeleton!==void 0&&(s(t.skeletons,this.skeleton),r.skeleton=this.skeleton.uuid)),this.material!==void 0)if(Array.isArray(this.material)){const h=[];for(let d=0,p=this.material.length;d<p;d++)h.push(s(t.materials,this.material[d]));r.material=h}else r.material=s(t.materials,this.material);if(this.children.length>0){r.children=[];for(let h=0;h<this.children.length;h++)r.children.push(this.children[h].toJSON(t).object)}if(this.animations.length>0){r.animations=[];for(let h=0;h<this.animations.length;h++){const d=this.animations[h];r.animations.push(s(t.animations,d))}}if(e){const h=l(t.geometries),d=l(t.materials),p=l(t.textures),f=l(t.images),m=l(t.shapes),g=l(t.skeletons),_=l(t.animations);h.length>0&&(n.geometries=h),d.length>0&&(n.materials=d),p.length>0&&(n.textures=p),f.length>0&&(n.images=f),m.length>0&&(n.shapes=m),g.length>0&&(n.skeletons=g),_.length>0&&(n.animations=_)}return n.object=r,n;function l(h){const d=[];for(const p in h){const f=h[p];delete f.metadata,d.push(f)}return d}}clone(t){return new this.constructor().copy(this,t)}copy(t,e=!0){if(this.name=t.name,this.up.copy(t.up),this.position.copy(t.position),this.rotation.order=t.rotation.order,this.quaternion.copy(t.quaternion),this.scale.copy(t.scale),this.matrix.copy(t.matrix),this.matrixWorld.copy(t.matrixWorld),this.matrixAutoUpdate=t.matrixAutoUpdate,this.matrixWorldNeedsUpdate=t.matrixWorldNeedsUpdate,this.layers.mask=t.layers.mask,this.visible=t.visible,this.castShadow=t.castShadow,this.receiveShadow=t.receiveShadow,this.frustumCulled=t.frustumCulled,this.renderOrder=t.renderOrder,this.userData=JSON.parse(JSON.stringify(t.userData)),e===!0)for(let n=0;n<t.children.length;n++){const r=t.children[n];this.add(r.clone())}return this}}te.DefaultUp=new D(0,1,0);te.DefaultMatrixAutoUpdate=!0;te.prototype.isObject3D=!0;const Qe=new D,yn=new D,$o=new D,wn=new D,Pi=new D,Li=new D,Gc=new D,Yo=new D,Jo=new D,Zo=new D;class fe{constructor(t=new D,e=new D,n=new D){this.a=t,this.b=e,this.c=n}static getNormal(t,e,n,r){r.subVectors(n,e),Qe.subVectors(t,e),r.cross(Qe);const s=r.lengthSq();return s>0?r.multiplyScalar(1/Math.sqrt(s)):r.set(0,0,0)}static getBarycoord(t,e,n,r,s){Qe.subVectors(r,e),yn.subVectors(n,e),$o.subVectors(t,e);const l=Qe.dot(Qe),h=Qe.dot(yn),d=Qe.dot($o),p=yn.dot(yn),f=yn.dot($o),m=l*p-h*h;if(m===0)return s.set(-2,-1,-1);const g=1/m,_=(p*d-h*f)*g,y=(l*f-h*d)*g;return s.set(1-_-y,y,_)}static containsPoint(t,e,n,r){return this.getBarycoord(t,e,n,r,wn),wn.x>=0&&wn.y>=0&&wn.x+wn.y<=1}static getUV(t,e,n,r,s,l,h,d){return this.getBarycoord(t,e,n,r,wn),d.set(0,0),d.addScaledVector(s,wn.x),d.addScaledVector(l,wn.y),d.addScaledVector(h,wn.z),d}static isFrontFacing(t,e,n,r){return Qe.subVectors(n,e),yn.subVectors(t,e),Qe.cross(yn).dot(r)<0}set(t,e,n){return this.a.copy(t),this.b.copy(e),this.c.copy(n),this}setFromPointsAndIndices(t,e,n,r){return this.a.copy(t[e]),this.b.copy(t[n]),this.c.copy(t[r]),this}setFromAttributeAndIndices(t,e,n,r){return this.a.fromBufferAttribute(t,e),this.b.fromBufferAttribute(t,n),this.c.fromBufferAttribute(t,r),this}clone(){return new this.constructor().copy(this)}copy(t){return this.a.copy(t.a),this.b.copy(t.b),this.c.copy(t.c),this}getArea(){return Qe.subVectors(this.c,this.b),yn.subVectors(this.a,this.b),Qe.cross(yn).length()*.5}getMidpoint(t){return t.addVectors(this.a,this.b).add(this.c).multiplyScalar(1/3)}getNormal(t){return fe.getNormal(this.a,this.b,this.c,t)}getPlane(t){return t.setFromCoplanarPoints(this.a,this.b,this.c)}getBarycoord(t,e){return fe.getBarycoord(t,this.a,this.b,this.c,e)}getUV(t,e,n,r,s){return fe.getUV(t,this.a,this.b,this.c,e,n,r,s)}containsPoint(t){return fe.containsPoint(t,this.a,this.b,this.c)}isFrontFacing(t){return fe.isFrontFacing(this.a,this.b,this.c,t)}intersectsBox(t){return t.intersectsTriangle(this)}closestPointToPoint(t,e){const n=this.a,r=this.b,s=this.c;let l,h;Pi.subVectors(r,n),Li.subVectors(s,n),Yo.subVectors(t,n);const d=Pi.dot(Yo),p=Li.dot(Yo);if(d<=0&&p<=0)return e.copy(n);Jo.subVectors(t,r);const f=Pi.dot(Jo),m=Li.dot(Jo);if(f>=0&&m<=f)return e.copy(r);const g=d*m-f*p;if(g<=0&&d>=0&&f<=0)return l=d/(d-f),e.copy(n).addScaledVector(Pi,l);Zo.subVectors(t,s);const _=Pi.dot(Zo),y=Li.dot(Zo);if(y>=0&&_<=y)return e.copy(s);const w=_*p-d*y;if(w<=0&&p>=0&&y<=0)return h=p/(p-y),e.copy(n).addScaledVector(Li,h);const S=f*y-_*m;if(S<=0&&m-f>=0&&_-y>=0)return Gc.subVectors(s,r),h=(m-f)/(m-f+(_-y)),e.copy(r).addScaledVector(Gc,h);const x=1/(S+w+g);return l=w*x,h=g*x,e.copy(n).addScaledVector(Pi,l).addScaledVector(Li,h)}equals(t){return t.a.equals(this.a)&&t.b.equals(this.b)&&t.c.equals(this.c)}}let Rg=0;class Pe extends pi{constructor(){super(),Object.defineProperty(this,"id",{value:Rg++}),this.uuid=cn(),this.name="",this.type="Material",this.fog=!0,this.blending=kr,this.side=zr,this.vertexColors=!1,this.opacity=1,this.format=be,this.transparent=!1,this.blendSrc=Uh,this.blendDst=Hh,this.blendEquation=Hi,this.blendSrcAlpha=null,this.blendDstAlpha=null,this.blendEquationAlpha=null,this.depthFunc=ba,this.depthTest=!0,this.depthWrite=!0,this.stencilWriteMask=255,this.stencilFunc=xg,this.stencilRef=0,this.stencilFuncMask=255,this.stencilFail=Vo,this.stencilZFail=Vo,this.stencilZPass=Vo,this.stencilWrite=!1,this.clippingPlanes=null,this.clipIntersection=!1,this.clipShadows=!1,this.shadowSide=null,this.colorWrite=!0,this.precision=null,this.polygonOffset=!1,this.polygonOffsetFactor=0,this.polygonOffsetUnits=0,this.dithering=!1,this.alphaToCoverage=!1,this.premultipliedAlpha=!1,this.visible=!0,this.toneMapped=!0,this.userData={},this.version=0,this._alphaTest=0}get alphaTest(){return this._alphaTest}set alphaTest(t){this._alphaTest>0!=t>0&&this.version++,this._alphaTest=t}onBuild(){}onBeforeRender(){}onBeforeCompile(){}customProgramCacheKey(){return this.onBeforeCompile.toString()}setValues(t){if(t!==void 0)for(const e in t){const n=t[e];if(n===void 0){console.warn("THREE.Material: '"+e+"' parameter is undefined.");continue}if(e==="shading"){console.warn("THREE."+this.type+": .shading has been removed. Use the boolean .flatShading instead."),this.flatShading=n===Oh;continue}const r=this[e];if(r===void 0){console.warn("THREE."+this.type+": '"+e+"' is not a property of this material.");continue}r&&r.isColor?r.set(n):r&&r.isVector3&&n&&n.isVector3?r.copy(n):this[e]=n}}toJSON(t){const e=t===void 0||typeof t=="string";e&&(t={textures:{},images:{}});const n={metadata:{version:4.5,type:"Material",generator:"Material.toJSON"}};n.uuid=this.uuid,n.type=this.type,this.name!==""&&(n.name=this.name),this.color&&this.color.isColor&&(n.color=this.color.getHex()),this.roughness!==void 0&&(n.roughness=this.roughness),this.metalness!==void 0&&(n.metalness=this.metalness),this.sheen!==void 0&&(n.sheen=this.sheen),this.sheenColor&&this.sheenColor.isColor&&(n.sheenColor=this.sheenColor.getHex()),this.sheenRoughness!==void 0&&(n.sheenRoughness=this.sheenRoughness),this.emissive&&this.emissive.isColor&&(n.emissive=this.emissive.getHex()),this.emissiveIntensity&&this.emissiveIntensity!==1&&(n.emissiveIntensity=this.emissiveIntensity),this.specular&&this.specular.isColor&&(n.specular=this.specular.getHex()),this.specularIntensity!==void 0&&(n.specularIntensity=this.specularIntensity),this.specularColor&&this.specularColor.isColor&&(n.specularColor=this.specularColor.getHex()),this.shininess!==void 0&&(n.shininess=this.shininess),this.clearcoat!==void 0&&(n.clearcoat=this.clearcoat),this.clearcoatRoughness!==void 0&&(n.clearcoatRoughness=this.clearcoatRoughness),this.clearcoatMap&&this.clearcoatMap.isTexture&&(n.clearcoatMap=this.clearcoatMap.toJSON(t).uuid),this.clearcoatRoughnessMap&&this.clearcoatRoughnessMap.isTexture&&(n.clearcoatRoughnessMap=this.clearcoatRoughnessMap.toJSON(t).uuid),this.clearcoatNormalMap&&this.clearcoatNormalMap.isTexture&&(n.clearcoatNormalMap=this.clearcoatNormalMap.toJSON(t).uuid,n.clearcoatNormalScale=this.clearcoatNormalScale.toArray()),this.map&&this.map.isTexture&&(n.map=this.map.toJSON(t).uuid),this.matcap&&this.matcap.isTexture&&(n.matcap=this.matcap.toJSON(t).uuid),this.alphaMap&&this.alphaMap.isTexture&&(n.alphaMap=this.alphaMap.toJSON(t).uuid),this.lightMap&&this.lightMap.isTexture&&(n.lightMap=this.lightMap.toJSON(t).uuid,n.lightMapIntensity=this.lightMapIntensity),this.aoMap&&this.aoMap.isTexture&&(n.aoMap=this.aoMap.toJSON(t).uuid,n.aoMapIntensity=this.aoMapIntensity),this.bumpMap&&this.bumpMap.isTexture&&(n.bumpMap=this.bumpMap.toJSON(t).uuid,n.bumpScale=this.bumpScale),this.normalMap&&this.normalMap.isTexture&&(n.normalMap=this.normalMap.toJSON(t).uuid,n.normalMapType=this.normalMapType,n.normalScale=this.normalScale.toArray()),this.displacementMap&&this.displacementMap.isTexture&&(n.displacementMap=this.displacementMap.toJSON(t).uuid,n.displacementScale=this.displacementScale,n.displacementBias=this.displacementBias),this.roughnessMap&&this.roughnessMap.isTexture&&(n.roughnessMap=this.roughnessMap.toJSON(t).uuid),this.metalnessMap&&this.metalnessMap.isTexture&&(n.metalnessMap=this.metalnessMap.toJSON(t).uuid),this.emissiveMap&&this.emissiveMap.isTexture&&(n.emissiveMap=this.emissiveMap.toJSON(t).uuid),this.specularMap&&this.specularMap.isTexture&&(n.specularMap=this.specularMap.toJSON(t).uuid),this.specularIntensityMap&&this.specularIntensityMap.isTexture&&(n.specularIntensityMap=this.specularIntensityMap.toJSON(t).uuid),this.specularColorMap&&this.specularColorMap.isTexture&&(n.specularColorMap=this.specularColorMap.toJSON(t).uuid),this.envMap&&this.envMap.isTexture&&(n.envMap=this.envMap.toJSON(t).uuid,this.combine!==void 0&&(n.combine=this.combine)),this.envMapIntensity!==void 0&&(n.envMapIntensity=this.envMapIntensity),this.reflectivity!==void 0&&(n.reflectivity=this.reflectivity),this.refractionRatio!==void 0&&(n.refractionRatio=this.refractionRatio),this.gradientMap&&this.gradientMap.isTexture&&(n.gradientMap=this.gradientMap.toJSON(t).uuid),this.transmission!==void 0&&(n.transmission=this.transmission),this.transmissionMap&&this.transmissionMap.isTexture&&(n.transmissionMap=this.transmissionMap.toJSON(t).uuid),this.thickness!==void 0&&(n.thickness=this.thickness),this.thicknessMap&&this.thicknessMap.isTexture&&(n.thicknessMap=this.thicknessMap.toJSON(t).uuid),this.attenuationDistance!==void 0&&(n.attenuationDistance=this.attenuationDistance),this.attenuationColor!==void 0&&(n.attenuationColor=this.attenuationColor.getHex()),this.size!==void 0&&(n.size=this.size),this.shadowSide!==null&&(n.shadowSide=this.shadowSide),this.sizeAttenuation!==void 0&&(n.sizeAttenuation=this.sizeAttenuation),this.blending!==kr&&(n.blending=this.blending),this.side!==zr&&(n.side=this.side),this.vertexColors&&(n.vertexColors=!0),this.opacity<1&&(n.opacity=this.opacity),this.format!==be&&(n.format=this.format),this.transparent===!0&&(n.transparent=this.transparent),n.depthFunc=this.depthFunc,n.depthTest=this.depthTest,n.depthWrite=this.depthWrite,n.colorWrite=this.colorWrite,n.stencilWrite=this.stencilWrite,n.stencilWriteMask=this.stencilWriteMask,n.stencilFunc=this.stencilFunc,n.stencilRef=this.stencilRef,n.stencilFuncMask=this.stencilFuncMask,n.stencilFail=this.stencilFail,n.stencilZFail=this.stencilZFail,n.stencilZPass=this.stencilZPass,this.rotation&&this.rotation!==0&&(n.rotation=this.rotation),this.polygonOffset===!0&&(n.polygonOffset=!0),this.polygonOffsetFactor!==0&&(n.polygonOffsetFactor=this.polygonOffsetFactor),this.polygonOffsetUnits!==0&&(n.polygonOffsetUnits=this.polygonOffsetUnits),this.linewidth&&this.linewidth!==1&&(n.linewidth=this.linewidth),this.dashSize!==void 0&&(n.dashSize=this.dashSize),this.gapSize!==void 0&&(n.gapSize=this.gapSize),this.scale!==void 0&&(n.scale=this.scale),this.dithering===!0&&(n.dithering=!0),this.alphaTest>0&&(n.alphaTest=this.alphaTest),this.alphaToCoverage===!0&&(n.alphaToCoverage=this.alphaToCoverage),this.premultipliedAlpha===!0&&(n.premultipliedAlpha=this.premultipliedAlpha),this.wireframe===!0&&(n.wireframe=this.wireframe),this.wireframeLinewidth>1&&(n.wireframeLinewidth=this.wireframeLinewidth),this.wireframeLinecap!=="round"&&(n.wireframeLinecap=this.wireframeLinecap),this.wireframeLinejoin!=="round"&&(n.wireframeLinejoin=this.wireframeLinejoin),this.flatShading===!0&&(n.flatShading=this.flatShading),this.visible===!1&&(n.visible=!1),this.toneMapped===!1&&(n.toneMapped=!1),JSON.stringify(this.userData)!=="{}"&&(n.userData=this.userData);function r(s){const l=[];for(const h in s){const d=s[h];delete d.metadata,l.push(d)}return l}if(e){const s=r(t.textures),l=r(t.images);s.length>0&&(n.textures=s),l.length>0&&(n.images=l)}return n}clone(){return new this.constructor().copy(this)}copy(t){this.name=t.name,this.fog=t.fog,this.blending=t.blending,this.side=t.side,this.vertexColors=t.vertexColors,this.opacity=t.opacity,this.format=t.format,this.transparent=t.transparent,this.blendSrc=t.blendSrc,this.blendDst=t.blendDst,this.blendEquation=t.blendEquation,this.blendSrcAlpha=t.blendSrcAlpha,this.blendDstAlpha=t.blendDstAlpha,this.blendEquationAlpha=t.blendEquationAlpha,this.depthFunc=t.depthFunc,this.depthTest=t.depthTest,this.depthWrite=t.depthWrite,this.stencilWriteMask=t.stencilWriteMask,this.stencilFunc=t.stencilFunc,this.stencilRef=t.stencilRef,this.stencilFuncMask=t.stencilFuncMask,this.stencilFail=t.stencilFail,this.stencilZFail=t.stencilZFail,this.stencilZPass=t.stencilZPass,this.stencilWrite=t.stencilWrite;const e=t.clippingPlanes;let n=null;if(e!==null){const r=e.length;n=new Array(r);for(let s=0;s!==r;++s)n[s]=e[s].clone()}return this.clippingPlanes=n,this.clipIntersection=t.clipIntersection,this.clipShadows=t.clipShadows,this.shadowSide=t.shadowSide,this.colorWrite=t.colorWrite,this.precision=t.precision,this.polygonOffset=t.polygonOffset,this.polygonOffsetFactor=t.polygonOffsetFactor,this.polygonOffsetUnits=t.polygonOffsetUnits,this.dithering=t.dithering,this.alphaTest=t.alphaTest,this.alphaToCoverage=t.alphaToCoverage,this.premultipliedAlpha=t.premultipliedAlpha,this.visible=t.visible,this.toneMapped=t.toneMapped,this.userData=JSON.parse(JSON.stringify(t.userData)),this}dispose(){this.dispatchEvent({type:"dispose"})}set needsUpdate(t){t===!0&&this.version++}}Pe.prototype.isMaterial=!0;const Xh={aliceblue:15792383,antiquewhite:16444375,aqua:65535,aquamarine:8388564,azure:15794175,beige:16119260,bisque:16770244,black:0,blanchedalmond:16772045,blue:255,blueviolet:9055202,brown:10824234,burlywood:14596231,cadetblue:6266528,chartreuse:8388352,chocolate:13789470,coral:16744272,cornflowerblue:6591981,cornsilk:16775388,crimson:14423100,cyan:65535,darkblue:139,darkcyan:35723,darkgoldenrod:12092939,darkgray:11119017,darkgreen:25600,darkgrey:11119017,darkkhaki:12433259,darkmagenta:9109643,darkolivegreen:5597999,darkorange:16747520,darkorchid:10040012,darkred:9109504,darksalmon:15308410,darkseagreen:9419919,darkslateblue:4734347,darkslategray:3100495,darkslategrey:3100495,darkturquoise:52945,darkviolet:9699539,deeppink:16716947,deepskyblue:49151,dimgray:6908265,dimgrey:6908265,dodgerblue:2003199,firebrick:11674146,floralwhite:16775920,forestgreen:2263842,fuchsia:16711935,gainsboro:14474460,ghostwhite:16316671,gold:16766720,goldenrod:14329120,gray:8421504,green:32768,greenyellow:11403055,grey:8421504,honeydew:15794160,hotpink:16738740,indianred:13458524,indigo:4915330,ivory:16777200,khaki:15787660,lavender:15132410,lavenderblush:16773365,lawngreen:8190976,lemonchiffon:16775885,lightblue:11393254,lightcoral:15761536,lightcyan:14745599,lightgoldenrodyellow:16448210,lightgray:13882323,lightgreen:9498256,lightgrey:13882323,lightpink:16758465,lightsalmon:16752762,lightseagreen:2142890,lightskyblue:8900346,lightslategray:7833753,lightslategrey:7833753,lightsteelblue:11584734,lightyellow:16777184,lime:65280,limegreen:3329330,linen:16445670,magenta:16711935,maroon:8388608,mediumaquamarine:6737322,mediumblue:205,mediumorchid:12211667,mediumpurple:9662683,mediumseagreen:3978097,mediumslateblue:8087790,mediumspringgreen:64154,mediumturquoise:4772300,mediumvioletred:13047173,midnightblue:1644912,mintcream:16121850,mistyrose:16770273,moccasin:16770229,navajowhite:16768685,navy:128,oldlace:16643558,olive:8421376,olivedrab:7048739,orange:16753920,orangered:16729344,orchid:14315734,palegoldenrod:15657130,palegreen:10025880,paleturquoise:11529966,palevioletred:14381203,papayawhip:16773077,peachpuff:16767673,peru:13468991,pink:16761035,plum:14524637,powderblue:11591910,purple:8388736,rebeccapurple:6697881,red:16711680,rosybrown:12357519,royalblue:4286945,saddlebrown:9127187,salmon:16416882,sandybrown:16032864,seagreen:3050327,seashell:16774638,sienna:10506797,silver:12632256,skyblue:8900331,slateblue:6970061,slategray:7372944,slategrey:7372944,snow:16775930,springgreen:65407,steelblue:4620980,tan:13808780,teal:32896,thistle:14204888,tomato:16737095,turquoise:4251856,violet:15631086,wheat:16113331,white:16777215,whitesmoke:16119285,yellow:16776960,yellowgreen:10145074},tn={h:0,s:0,l:0},vs={h:0,s:0,l:0};function Ko(o,t,e){return e<0&&(e+=1),e>1&&(e-=1),e<1/6?o+(t-o)*6*e:e<1/2?t:e<2/3?o+(t-o)*6*(2/3-e):o}function Qo(o){return o<.04045?o*.0773993808:Math.pow(o*.9478672986+.0521327014,2.4)}function ta(o){return o<.0031308?o*12.92:1.055*Math.pow(o,.41666)-.055}class Et{constructor(t,e,n){return e===void 0&&n===void 0?this.set(t):this.setRGB(t,e,n)}set(t){return t&&t.isColor?this.copy(t):typeof t=="number"?this.setHex(t):typeof t=="string"&&this.setStyle(t),this}setScalar(t){return this.r=t,this.g=t,this.b=t,this}setHex(t){return t=Math.floor(t),this.r=(t>>16&255)/255,this.g=(t>>8&255)/255,this.b=(t&255)/255,this}setRGB(t,e,n){return this.r=t,this.g=e,this.b=n,this}setHSL(t,e,n){if(t=bg(t,1),e=We(e,0,1),n=We(n,0,1),e===0)this.r=this.g=this.b=n;else{const r=n<=.5?n*(1+e):n+e-n*e,s=2*n-r;this.r=Ko(s,r,t+1/3),this.g=Ko(s,r,t),this.b=Ko(s,r,t-1/3)}return this}setStyle(t){function e(r){r!==void 0&&parseFloat(r)<1&&console.warn("THREE.Color: Alpha component of "+t+" will be ignored.")}let n;if(n=/^((?:rgb|hsl)a?)\(([^\)]*)\)/.exec(t)){let r;const s=n[1],l=n[2];switch(s){case"rgb":case"rgba":if(r=/^\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(l))return this.r=Math.min(255,parseInt(r[1],10))/255,this.g=Math.min(255,parseInt(r[2],10))/255,this.b=Math.min(255,parseInt(r[3],10))/255,e(r[4]),this;if(r=/^\s*(\d+)\%\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(l))return this.r=Math.min(100,parseInt(r[1],10))/100,this.g=Math.min(100,parseInt(r[2],10))/100,this.b=Math.min(100,parseInt(r[3],10))/100,e(r[4]),this;break;case"hsl":case"hsla":if(r=/^\s*(\d*\.?\d+)\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(l)){const h=parseFloat(r[1])/360,d=parseInt(r[2],10)/100,p=parseInt(r[3],10)/100;return e(r[4]),this.setHSL(h,d,p)}break}}else if(n=/^\#([A-Fa-f\d]+)$/.exec(t)){const r=n[1],s=r.length;if(s===3)return this.r=parseInt(r.charAt(0)+r.charAt(0),16)/255,this.g=parseInt(r.charAt(1)+r.charAt(1),16)/255,this.b=parseInt(r.charAt(2)+r.charAt(2),16)/255,this;if(s===6)return this.r=parseInt(r.charAt(0)+r.charAt(1),16)/255,this.g=parseInt(r.charAt(2)+r.charAt(3),16)/255,this.b=parseInt(r.charAt(4)+r.charAt(5),16)/255,this}return t&&t.length>0?this.setColorName(t):this}setColorName(t){const e=Xh[t.toLowerCase()];return e!==void 0?this.setHex(e):console.warn("THREE.Color: Unknown color "+t),this}clone(){return new this.constructor(this.r,this.g,this.b)}copy(t){return this.r=t.r,this.g=t.g,this.b=t.b,this}copySRGBToLinear(t){return this.r=Qo(t.r),this.g=Qo(t.g),this.b=Qo(t.b),this}copyLinearToSRGB(t){return this.r=ta(t.r),this.g=ta(t.g),this.b=ta(t.b),this}convertSRGBToLinear(){return this.copySRGBToLinear(this),this}convertLinearToSRGB(){return this.copyLinearToSRGB(this),this}getHex(){return this.r*255<<16^this.g*255<<8^this.b*255<<0}getHexString(){return("000000"+this.getHex().toString(16)).slice(-6)}getHSL(t){const e=this.r,n=this.g,r=this.b,s=Math.max(e,n,r),l=Math.min(e,n,r);let h,d;const p=(l+s)/2;if(l===s)h=0,d=0;else{const f=s-l;switch(d=p<=.5?f/(s+l):f/(2-s-l),s){case e:h=(n-r)/f+(n<r?6:0);break;case n:h=(r-e)/f+2;break;case r:h=(e-n)/f+4;break}h/=6}return t.h=h,t.s=d,t.l=p,t}getStyle(){return"rgb("+(this.r*255|0)+","+(this.g*255|0)+","+(this.b*255|0)+")"}offsetHSL(t,e,n){return this.getHSL(tn),tn.h+=t,tn.s+=e,tn.l+=n,this.setHSL(tn.h,tn.s,tn.l),this}add(t){return this.r+=t.r,this.g+=t.g,this.b+=t.b,this}addColors(t,e){return this.r=t.r+e.r,this.g=t.g+e.g,this.b=t.b+e.b,this}addScalar(t){return this.r+=t,this.g+=t,this.b+=t,this}sub(t){return this.r=Math.max(0,this.r-t.r),this.g=Math.max(0,this.g-t.g),this.b=Math.max(0,this.b-t.b),this}multiply(t){return this.r*=t.r,this.g*=t.g,this.b*=t.b,this}multiplyScalar(t){return this.r*=t,this.g*=t,this.b*=t,this}lerp(t,e){return this.r+=(t.r-this.r)*e,this.g+=(t.g-this.g)*e,this.b+=(t.b-this.b)*e,this}lerpColors(t,e,n){return this.r=t.r+(e.r-t.r)*n,this.g=t.g+(e.g-t.g)*n,this.b=t.b+(e.b-t.b)*n,this}lerpHSL(t,e){this.getHSL(tn),t.getHSL(vs);const n=zo(tn.h,vs.h,e),r=zo(tn.s,vs.s,e),s=zo(tn.l,vs.l,e);return this.setHSL(n,r,s),this}equals(t){return t.r===this.r&&t.g===this.g&&t.b===this.b}fromArray(t,e=0){return this.r=t[e],this.g=t[e+1],this.b=t[e+2],this}toArray(t=[],e=0){return t[e]=this.r,t[e+1]=this.g,t[e+2]=this.b,t}fromBufferAttribute(t,e){return this.r=t.getX(e),this.g=t.getY(e),this.b=t.getZ(e),t.normalized===!0&&(this.r/=255,this.g/=255,this.b/=255),this}toJSON(){return this.getHex()}}Et.NAMES=Xh;Et.prototype.isColor=!0;Et.prototype.r=1;Et.prototype.g=1;Et.prototype.b=1;class ka extends Pe{constructor(t){super(),this.type="MeshBasicMaterial",this.color=new Et(16777215),this.map=null,this.lightMap=null,this.lightMapIntensity=1,this.aoMap=null,this.aoMapIntensity=1,this.specularMap=null,this.alphaMap=null,this.envMap=null,this.combine=Zs,this.reflectivity=1,this.refractionRatio=.98,this.wireframe=!1,this.wireframeLinewidth=1,this.wireframeLinecap="round",this.wireframeLinejoin="round",this.setValues(t)}copy(t){return super.copy(t),this.color.copy(t.color),this.map=t.map,this.lightMap=t.lightMap,this.lightMapIntensity=t.lightMapIntensity,this.aoMap=t.aoMap,this.aoMapIntensity=t.aoMapIntensity,this.specularMap=t.specularMap,this.alphaMap=t.alphaMap,this.envMap=t.envMap,this.combine=t.combine,this.reflectivity=t.reflectivity,this.refractionRatio=t.refractionRatio,this.wireframe=t.wireframe,this.wireframeLinewidth=t.wireframeLinewidth,this.wireframeLinecap=t.wireframeLinecap,this.wireframeLinejoin=t.wireframeLinejoin,this}}ka.prototype.isMeshBasicMaterial=!0;const se=new D,_s=new st;class _e{constructor(t,e,n){if(Array.isArray(t))throw new TypeError("THREE.BufferAttribute: array should be a Typed Array.");this.name="",this.array=t,this.itemSize=e,this.count=t!==void 0?t.length/e:0,this.normalized=n===!0,this.usage=Ur,this.updateRange={offset:0,count:-1},this.version=0}onUploadCallback(){}set needsUpdate(t){t===!0&&this.version++}setUsage(t){return this.usage=t,this}copy(t){return this.name=t.name,this.array=new t.array.constructor(t.array),this.itemSize=t.itemSize,this.count=t.count,this.normalized=t.normalized,this.usage=t.usage,this}copyAt(t,e,n){t*=this.itemSize,n*=e.itemSize;for(let r=0,s=this.itemSize;r<s;r++)this.array[t+r]=e.array[n+r];return this}copyArray(t){return this.array.set(t),this}copyColorsArray(t){const e=this.array;let n=0;for(let r=0,s=t.length;r<s;r++){let l=t[r];l===void 0&&(console.warn("THREE.BufferAttribute.copyColorsArray(): color is undefined",r),l=new Et),e[n++]=l.r,e[n++]=l.g,e[n++]=l.b}return this}copyVector2sArray(t){const e=this.array;let n=0;for(let r=0,s=t.length;r<s;r++){let l=t[r];l===void 0&&(console.warn("THREE.BufferAttribute.copyVector2sArray(): vector is undefined",r),l=new st),e[n++]=l.x,e[n++]=l.y}return this}copyVector3sArray(t){const e=this.array;let n=0;for(let r=0,s=t.length;r<s;r++){let l=t[r];l===void 0&&(console.warn("THREE.BufferAttribute.copyVector3sArray(): vector is undefined",r),l=new D),e[n++]=l.x,e[n++]=l.y,e[n++]=l.z}return this}copyVector4sArray(t){const e=this.array;let n=0;for(let r=0,s=t.length;r<s;r++){let l=t[r];l===void 0&&(console.warn("THREE.BufferAttribute.copyVector4sArray(): vector is undefined",r),l=new re),e[n++]=l.x,e[n++]=l.y,e[n++]=l.z,e[n++]=l.w}return this}applyMatrix3(t){if(this.itemSize===2)for(let e=0,n=this.count;e<n;e++)_s.fromBufferAttribute(this,e),_s.applyMatrix3(t),this.setXY(e,_s.x,_s.y);else if(this.itemSize===3)for(let e=0,n=this.count;e<n;e++)se.fromBufferAttribute(this,e),se.applyMatrix3(t),this.setXYZ(e,se.x,se.y,se.z);return this}applyMatrix4(t){for(let e=0,n=this.count;e<n;e++)se.x=this.getX(e),se.y=this.getY(e),se.z=this.getZ(e),se.applyMatrix4(t),this.setXYZ(e,se.x,se.y,se.z);return this}applyNormalMatrix(t){for(let e=0,n=this.count;e<n;e++)se.x=this.getX(e),se.y=this.getY(e),se.z=this.getZ(e),se.applyNormalMatrix(t),this.setXYZ(e,se.x,se.y,se.z);return this}transformDirection(t){for(let e=0,n=this.count;e<n;e++)se.x=this.getX(e),se.y=this.getY(e),se.z=this.getZ(e),se.transformDirection(t),this.setXYZ(e,se.x,se.y,se.z);return this}set(t,e=0){return this.array.set(t,e),this}getX(t){return this.array[t*this.itemSize]}setX(t,e){return this.array[t*this.itemSize]=e,this}getY(t){return this.array[t*this.itemSize+1]}setY(t,e){return this.array[t*this.itemSize+1]=e,this}getZ(t){return this.array[t*this.itemSize+2]}setZ(t,e){return this.array[t*this.itemSize+2]=e,this}getW(t){return this.array[t*this.itemSize+3]}setW(t,e){return this.array[t*this.itemSize+3]=e,this}setXY(t,e,n){return t*=this.itemSize,this.array[t+0]=e,this.array[t+1]=n,this}setXYZ(t,e,n,r){return t*=this.itemSize,this.array[t+0]=e,this.array[t+1]=n,this.array[t+2]=r,this}setXYZW(t,e,n,r,s){return t*=this.itemSize,this.array[t+0]=e,this.array[t+1]=n,this.array[t+2]=r,this.array[t+3]=s,this}onUpload(t){return this.onUploadCallback=t,this}clone(){return new this.constructor(this.array,this.itemSize).copy(this)}toJSON(){const t={itemSize:this.itemSize,type:this.array.constructor.name,array:Array.prototype.slice.call(this.array),normalized:this.normalized};return this.name!==""&&(t.name=this.name),this.usage!==Ur&&(t.usage=this.usage),(this.updateRange.offset!==0||this.updateRange.count!==-1)&&(t.updateRange=this.updateRange),t}}_e.prototype.isBufferAttribute=!0;class $h extends _e{constructor(t,e,n){super(new Uint16Array(t),e,n)}}class Yh extends _e{constructor(t,e,n){super(new Uint32Array(t),e,n)}}class Dg extends _e{constructor(t,e,n){super(new Uint16Array(t),e,n)}}Dg.prototype.isFloat16BufferAttribute=!0;class ye extends _e{constructor(t,e,n){super(new Float32Array(t),e,n)}}let Ig=0;const $e=new At,ea=new te,Ri=new D,Ge=new nn,Tr=new nn,xe=new D;class ce extends pi{constructor(){super(),Object.defineProperty(this,"id",{value:Ig++}),this.uuid=cn(),this.name="",this.type="BufferGeometry",this.index=null,this.attributes={},this.morphAttributes={},this.morphTargetsRelative=!1,this.groups=[],this.boundingBox=null,this.boundingSphere=null,this.drawRange={start:0,count:1/0},this.userData={}}getIndex(){return this.index}setIndex(t){return Array.isArray(t)?this.index=new(qh(t)>65535?Yh:$h)(t,1):this.index=t,this}getAttribute(t){return this.attributes[t]}setAttribute(t,e){return this.attributes[t]=e,this}deleteAttribute(t){return delete this.attributes[t],this}hasAttribute(t){return this.attributes[t]!==void 0}addGroup(t,e,n=0){this.groups.push({start:t,count:e,materialIndex:n})}clearGroups(){this.groups=[]}setDrawRange(t,e){this.drawRange.start=t,this.drawRange.count=e}applyMatrix4(t){const e=this.attributes.position;e!==void 0&&(e.applyMatrix4(t),e.needsUpdate=!0);const n=this.attributes.normal;if(n!==void 0){const s=new Te().getNormalMatrix(t);n.applyNormalMatrix(s),n.needsUpdate=!0}const r=this.attributes.tangent;return r!==void 0&&(r.transformDirection(t),r.needsUpdate=!0),this.boundingBox!==null&&this.computeBoundingBox(),this.boundingSphere!==null&&this.computeBoundingSphere(),this}applyQuaternion(t){return $e.makeRotationFromQuaternion(t),this.applyMatrix4($e),this}rotateX(t){return $e.makeRotationX(t),this.applyMatrix4($e),this}rotateY(t){return $e.makeRotationY(t),this.applyMatrix4($e),this}rotateZ(t){return $e.makeRotationZ(t),this.applyMatrix4($e),this}translate(t,e,n){return $e.makeTranslation(t,e,n),this.applyMatrix4($e),this}scale(t,e,n){return $e.makeScale(t,e,n),this.applyMatrix4($e),this}lookAt(t){return ea.lookAt(t),ea.updateMatrix(),this.applyMatrix4(ea.matrix),this}center(){return this.computeBoundingBox(),this.boundingBox.getCenter(Ri).negate(),this.translate(Ri.x,Ri.y,Ri.z),this}setFromPoints(t){const e=[];for(let n=0,r=t.length;n<r;n++){const s=t[n];e.push(s.x,s.y,s.z||0)}return this.setAttribute("position",new ye(e,3)),this}computeBoundingBox(){this.boundingBox===null&&(this.boundingBox=new nn);const t=this.attributes.position,e=this.morphAttributes.position;if(t&&t.isGLBufferAttribute){console.error('THREE.BufferGeometry.computeBoundingBox(): GLBufferAttribute requires a manual bounding box. Alternatively set "mesh.frustumCulled" to "false".',this),this.boundingBox.set(new D(-1/0,-1/0,-1/0),new D(1/0,1/0,1/0));return}if(t!==void 0){if(this.boundingBox.setFromBufferAttribute(t),e)for(let n=0,r=e.length;n<r;n++){const s=e[n];Ge.setFromBufferAttribute(s),this.morphTargetsRelative?(xe.addVectors(this.boundingBox.min,Ge.min),this.boundingBox.expandByPoint(xe),xe.addVectors(this.boundingBox.max,Ge.max),this.boundingBox.expandByPoint(xe)):(this.boundingBox.expandByPoint(Ge.min),this.boundingBox.expandByPoint(Ge.max))}}else this.boundingBox.makeEmpty();(isNaN(this.boundingBox.min.x)||isNaN(this.boundingBox.min.y)||isNaN(this.boundingBox.min.z))&&console.error('THREE.BufferGeometry.computeBoundingBox(): Computed min/max have NaN values. The "position" attribute is likely to have NaN values.',this)}computeBoundingSphere(){this.boundingSphere===null&&(this.boundingSphere=new er);const t=this.attributes.position,e=this.morphAttributes.position;if(t&&t.isGLBufferAttribute){console.error('THREE.BufferGeometry.computeBoundingSphere(): GLBufferAttribute requires a manual bounding sphere. Alternatively set "mesh.frustumCulled" to "false".',this),this.boundingSphere.set(new D,1/0);return}if(t){const n=this.boundingSphere.center;if(Ge.setFromBufferAttribute(t),e)for(let s=0,l=e.length;s<l;s++){const h=e[s];Tr.setFromBufferAttribute(h),this.morphTargetsRelative?(xe.addVectors(Ge.min,Tr.min),Ge.expandByPoint(xe),xe.addVectors(Ge.max,Tr.max),Ge.expandByPoint(xe)):(Ge.expandByPoint(Tr.min),Ge.expandByPoint(Tr.max))}Ge.getCenter(n);let r=0;for(let s=0,l=t.count;s<l;s++)xe.fromBufferAttribute(t,s),r=Math.max(r,n.distanceToSquared(xe));if(e)for(let s=0,l=e.length;s<l;s++){const h=e[s],d=this.morphTargetsRelative;for(let p=0,f=h.count;p<f;p++)xe.fromBufferAttribute(h,p),d&&(Ri.fromBufferAttribute(t,p),xe.add(Ri)),r=Math.max(r,n.distanceToSquared(xe))}this.boundingSphere.radius=Math.sqrt(r),isNaN(this.boundingSphere.radius)&&console.error('THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.',this)}}computeTangents(){const t=this.index,e=this.attributes;if(t===null||e.position===void 0||e.normal===void 0||e.uv===void 0){console.error("THREE.BufferGeometry: .computeTangents() failed. Missing required attributes (index, position, normal or uv)");return}const n=t.array,r=e.position.array,s=e.normal.array,l=e.uv.array,h=r.length/3;e.tangent===void 0&&this.setAttribute("tangent",new _e(new Float32Array(4*h),4));const d=e.tangent.array,p=[],f=[];for(let Y=0;Y<h;Y++)p[Y]=new D,f[Y]=new D;const m=new D,g=new D,_=new D,y=new st,w=new st,S=new st,x=new D,v=new D;function N(Y,V,C){m.fromArray(r,Y*3),g.fromArray(r,V*3),_.fromArray(r,C*3),y.fromArray(l,Y*2),w.fromArray(l,V*2),S.fromArray(l,C*2),g.sub(m),_.sub(m),w.sub(y),S.sub(y);const A=1/(w.x*S.y-S.x*w.y);!isFinite(A)||(x.copy(g).multiplyScalar(S.y).addScaledVector(_,-w.y).multiplyScalar(A),v.copy(_).multiplyScalar(w.x).addScaledVector(g,-S.x).multiplyScalar(A),p[Y].add(x),p[V].add(x),p[C].add(x),f[Y].add(v),f[V].add(v),f[C].add(v))}let M=this.groups;M.length===0&&(M=[{start:0,count:n.length}]);for(let Y=0,V=M.length;Y<V;++Y){const C=M[Y],A=C.start,H=C.count;for(let q=A,O=A+H;q<O;q+=3)N(n[q+0],n[q+1],n[q+2])}const R=new D,F=new D,k=new D,j=new D;function ot(Y){k.fromArray(s,Y*3),j.copy(k);const V=p[Y];R.copy(V),R.sub(k.multiplyScalar(k.dot(V))).normalize(),F.crossVectors(j,V);const A=F.dot(f[Y])<0?-1:1;d[Y*4]=R.x,d[Y*4+1]=R.y,d[Y*4+2]=R.z,d[Y*4+3]=A}for(let Y=0,V=M.length;Y<V;++Y){const C=M[Y],A=C.start,H=C.count;for(let q=A,O=A+H;q<O;q+=3)ot(n[q+0]),ot(n[q+1]),ot(n[q+2])}}computeVertexNormals(){const t=this.index,e=this.getAttribute("position");if(e!==void 0){let n=this.getAttribute("normal");if(n===void 0)n=new _e(new Float32Array(e.count*3),3),this.setAttribute("normal",n);else for(let g=0,_=n.count;g<_;g++)n.setXYZ(g,0,0,0);const r=new D,s=new D,l=new D,h=new D,d=new D,p=new D,f=new D,m=new D;if(t)for(let g=0,_=t.count;g<_;g+=3){const y=t.getX(g+0),w=t.getX(g+1),S=t.getX(g+2);r.fromBufferAttribute(e,y),s.fromBufferAttribute(e,w),l.fromBufferAttribute(e,S),f.subVectors(l,s),m.subVectors(r,s),f.cross(m),h.fromBufferAttribute(n,y),d.fromBufferAttribute(n,w),p.fromBufferAttribute(n,S),h.add(f),d.add(f),p.add(f),n.setXYZ(y,h.x,h.y,h.z),n.setXYZ(w,d.x,d.y,d.z),n.setXYZ(S,p.x,p.y,p.z)}else for(let g=0,_=e.count;g<_;g+=3)r.fromBufferAttribute(e,g+0),s.fromBufferAttribute(e,g+1),l.fromBufferAttribute(e,g+2),f.subVectors(l,s),m.subVectors(r,s),f.cross(m),n.setXYZ(g+0,f.x,f.y,f.z),n.setXYZ(g+1,f.x,f.y,f.z),n.setXYZ(g+2,f.x,f.y,f.z);this.normalizeNormals(),n.needsUpdate=!0}}merge(t,e){if(!(t&&t.isBufferGeometry)){console.error("THREE.BufferGeometry.merge(): geometry not an instance of THREE.BufferGeometry.",t);return}e===void 0&&(e=0,console.warn("THREE.BufferGeometry.merge(): Overwriting original geometry, starting at offset=0. Use BufferGeometryUtils.mergeBufferGeometries() for lossless merge."));const n=this.attributes;for(const r in n){if(t.attributes[r]===void 0)continue;const l=n[r].array,h=t.attributes[r],d=h.array,p=h.itemSize*e,f=Math.min(d.length,l.length-p);for(let m=0,g=p;m<f;m++,g++)l[g]=d[m]}return this}normalizeNormals(){const t=this.attributes.normal;for(let e=0,n=t.count;e<n;e++)xe.fromBufferAttribute(t,e),xe.normalize(),t.setXYZ(e,xe.x,xe.y,xe.z)}toNonIndexed(){function t(h,d){const p=h.array,f=h.itemSize,m=h.normalized,g=new p.constructor(d.length*f);let _=0,y=0;for(let w=0,S=d.length;w<S;w++){h.isInterleavedBufferAttribute?_=d[w]*h.data.stride+h.offset:_=d[w]*f;for(let x=0;x<f;x++)g[y++]=p[_++]}return new _e(g,f,m)}if(this.index===null)return console.warn("THREE.BufferGeometry.toNonIndexed(): BufferGeometry is already non-indexed."),this;const e=new ce,n=this.index.array,r=this.attributes;for(const h in r){const d=r[h],p=t(d,n);e.setAttribute(h,p)}const s=this.morphAttributes;for(const h in s){const d=[],p=s[h];for(let f=0,m=p.length;f<m;f++){const g=p[f],_=t(g,n);d.push(_)}e.morphAttributes[h]=d}e.morphTargetsRelative=this.morphTargetsRelative;const l=this.groups;for(let h=0,d=l.length;h<d;h++){const p=l[h];e.addGroup(p.start,p.count,p.materialIndex)}return e}toJSON(){const t={metadata:{version:4.5,type:"BufferGeometry",generator:"BufferGeometry.toJSON"}};if(t.uuid=this.uuid,t.type=this.type,this.name!==""&&(t.name=this.name),Object.keys(this.userData).length>0&&(t.userData=this.userData),this.parameters!==void 0){const d=this.parameters;for(const p in d)d[p]!==void 0&&(t[p]=d[p]);return t}t.data={attributes:{}};const e=this.index;e!==null&&(t.data.index={type:e.array.constructor.name,array:Array.prototype.slice.call(e.array)});const n=this.attributes;for(const d in n){const p=n[d];t.data.attributes[d]=p.toJSON(t.data)}const r={};let s=!1;for(const d in this.morphAttributes){const p=this.morphAttributes[d],f=[];for(let m=0,g=p.length;m<g;m++){const _=p[m];f.push(_.toJSON(t.data))}f.length>0&&(r[d]=f,s=!0)}s&&(t.data.morphAttributes=r,t.data.morphTargetsRelative=this.morphTargetsRelative);const l=this.groups;l.length>0&&(t.data.groups=JSON.parse(JSON.stringify(l)));const h=this.boundingSphere;return h!==null&&(t.data.boundingSphere={center:h.center.toArray(),radius:h.radius}),t}clone(){return new this.constructor().copy(this)}copy(t){this.index=null,this.attributes={},this.morphAttributes={},this.groups=[],this.boundingBox=null,this.boundingSphere=null;const e={};this.name=t.name;const n=t.index;n!==null&&this.setIndex(n.clone(e));const r=t.attributes;for(const p in r){const f=r[p];this.setAttribute(p,f.clone(e))}const s=t.morphAttributes;for(const p in s){const f=[],m=s[p];for(let g=0,_=m.length;g<_;g++)f.push(m[g].clone(e));this.morphAttributes[p]=f}this.morphTargetsRelative=t.morphTargetsRelative;const l=t.groups;for(let p=0,f=l.length;p<f;p++){const m=l[p];this.addGroup(m.start,m.count,m.materialIndex)}const h=t.boundingBox;h!==null&&(this.boundingBox=h.clone());const d=t.boundingSphere;return d!==null&&(this.boundingSphere=d.clone()),this.drawRange.start=t.drawRange.start,this.drawRange.count=t.drawRange.count,this.userData=t.userData,t.parameters!==void 0&&(this.parameters=Object.assign({},t.parameters)),this}dispose(){this.dispatchEvent({type:"dispose"})}}ce.prototype.isBufferGeometry=!0;const Wc=new At,Di=new nr,na=new er,zn=new D,On=new D,Un=new D,ia=new D,ra=new D,sa=new D,xs=new D,bs=new D,ys=new D,ws=new st,Ms=new st,Ss=new st,oa=new D,Es=new D;class Ve extends te{constructor(t=new ce,e=new ka){super(),this.type="Mesh",this.geometry=t,this.material=e,this.updateMorphTargets()}copy(t){return super.copy(t),t.morphTargetInfluences!==void 0&&(this.morphTargetInfluences=t.morphTargetInfluences.slice()),t.morphTargetDictionary!==void 0&&(this.morphTargetDictionary=Object.assign({},t.morphTargetDictionary)),this.material=t.material,this.geometry=t.geometry,this}updateMorphTargets(){const t=this.geometry;if(t.isBufferGeometry){const e=t.morphAttributes,n=Object.keys(e);if(n.length>0){const r=e[n[0]];if(r!==void 0){this.morphTargetInfluences=[],this.morphTargetDictionary={};for(let s=0,l=r.length;s<l;s++){const h=r[s].name||String(s);this.morphTargetInfluences.push(0),this.morphTargetDictionary[h]=s}}}}else{const e=t.morphTargets;e!==void 0&&e.length>0&&console.error("THREE.Mesh.updateMorphTargets() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.")}}raycast(t,e){const n=this.geometry,r=this.material,s=this.matrixWorld;if(r===void 0||(n.boundingSphere===null&&n.computeBoundingSphere(),na.copy(n.boundingSphere),na.applyMatrix4(s),t.ray.intersectsSphere(na)===!1)||(Wc.copy(s).invert(),Di.copy(t.ray).applyMatrix4(Wc),n.boundingBox!==null&&Di.intersectsBox(n.boundingBox)===!1))return;let l;if(n.isBufferGeometry){const h=n.index,d=n.attributes.position,p=n.morphAttributes.position,f=n.morphTargetsRelative,m=n.attributes.uv,g=n.attributes.uv2,_=n.groups,y=n.drawRange;if(h!==null)if(Array.isArray(r))for(let w=0,S=_.length;w<S;w++){const x=_[w],v=r[x.materialIndex],N=Math.max(x.start,y.start),M=Math.min(h.count,Math.min(x.start+x.count,y.start+y.count));for(let R=N,F=M;R<F;R+=3){const k=h.getX(R),j=h.getX(R+1),ot=h.getX(R+2);l=Ts(this,v,t,Di,d,p,f,m,g,k,j,ot),l&&(l.faceIndex=Math.floor(R/3),l.face.materialIndex=x.materialIndex,e.push(l))}}else{const w=Math.max(0,y.start),S=Math.min(h.count,y.start+y.count);for(let x=w,v=S;x<v;x+=3){const N=h.getX(x),M=h.getX(x+1),R=h.getX(x+2);l=Ts(this,r,t,Di,d,p,f,m,g,N,M,R),l&&(l.faceIndex=Math.floor(x/3),e.push(l))}}else if(d!==void 0)if(Array.isArray(r))for(let w=0,S=_.length;w<S;w++){const x=_[w],v=r[x.materialIndex],N=Math.max(x.start,y.start),M=Math.min(d.count,Math.min(x.start+x.count,y.start+y.count));for(let R=N,F=M;R<F;R+=3){const k=R,j=R+1,ot=R+2;l=Ts(this,v,t,Di,d,p,f,m,g,k,j,ot),l&&(l.faceIndex=Math.floor(R/3),l.face.materialIndex=x.materialIndex,e.push(l))}}else{const w=Math.max(0,y.start),S=Math.min(d.count,y.start+y.count);for(let x=w,v=S;x<v;x+=3){const N=x,M=x+1,R=x+2;l=Ts(this,r,t,Di,d,p,f,m,g,N,M,R),l&&(l.faceIndex=Math.floor(x/3),e.push(l))}}}else n.isGeometry&&console.error("THREE.Mesh.raycast() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.")}}Ve.prototype.isMesh=!0;function Ng(o,t,e,n,r,s,l,h){let d;if(t.side===ge?d=n.intersectTriangle(l,s,r,!0,h):d=n.intersectTriangle(r,s,l,t.side!==$i,h),d===null)return null;Es.copy(h),Es.applyMatrix4(o.matrixWorld);const p=e.ray.origin.distanceTo(Es);return p<e.near||p>e.far?null:{distance:p,point:Es.clone(),object:o}}function Ts(o,t,e,n,r,s,l,h,d,p,f,m){zn.fromBufferAttribute(r,p),On.fromBufferAttribute(r,f),Un.fromBufferAttribute(r,m);const g=o.morphTargetInfluences;if(s&&g){xs.set(0,0,0),bs.set(0,0,0),ys.set(0,0,0);for(let y=0,w=s.length;y<w;y++){const S=g[y],x=s[y];S!==0&&(ia.fromBufferAttribute(x,p),ra.fromBufferAttribute(x,f),sa.fromBufferAttribute(x,m),l?(xs.addScaledVector(ia,S),bs.addScaledVector(ra,S),ys.addScaledVector(sa,S)):(xs.addScaledVector(ia.sub(zn),S),bs.addScaledVector(ra.sub(On),S),ys.addScaledVector(sa.sub(Un),S)))}zn.add(xs),On.add(bs),Un.add(ys)}o.isSkinnedMesh&&(o.boneTransform(p,zn),o.boneTransform(f,On),o.boneTransform(m,Un));const _=Ng(o,t,e,n,zn,On,Un,oa);if(_){h&&(ws.fromBufferAttribute(h,p),Ms.fromBufferAttribute(h,f),Ss.fromBufferAttribute(h,m),_.uv=fe.getUV(oa,zn,On,Un,ws,Ms,Ss,new st)),d&&(ws.fromBufferAttribute(d,p),Ms.fromBufferAttribute(d,f),Ss.fromBufferAttribute(d,m),_.uv2=fe.getUV(oa,zn,On,Un,ws,Ms,Ss,new st));const y={a:p,b:f,c:m,normal:new D,materialIndex:0};fe.getNormal(zn,On,Un,y.normal),_.face=y}return _}class $r extends ce{constructor(t=1,e=1,n=1,r=1,s=1,l=1){super(),this.type="BoxGeometry",this.parameters={width:t,height:e,depth:n,widthSegments:r,heightSegments:s,depthSegments:l};const h=this;r=Math.floor(r),s=Math.floor(s),l=Math.floor(l);const d=[],p=[],f=[],m=[];let g=0,_=0;y("z","y","x",-1,-1,n,e,t,l,s,0),y("z","y","x",1,-1,n,e,-t,l,s,1),y("x","z","y",1,1,t,n,e,r,l,2),y("x","z","y",1,-1,t,n,-e,r,l,3),y("x","y","z",1,-1,t,e,n,r,s,4),y("x","y","z",-1,-1,t,e,-n,r,s,5),this.setIndex(d),this.setAttribute("position",new ye(p,3)),this.setAttribute("normal",new ye(f,3)),this.setAttribute("uv",new ye(m,2));function y(w,S,x,v,N,M,R,F,k,j,ot){const Y=M/k,V=R/j,C=M/2,A=R/2,H=F/2,q=k+1,O=j+1;let U=0,X=0;const _t=new D;for(let J=0;J<O;J++){const Z=J*V-A;for(let pt=0;pt<q;pt++){const vt=pt*Y-C;_t[w]=vt*v,_t[S]=Z*N,_t[x]=H,p.push(_t.x,_t.y,_t.z),_t[w]=0,_t[S]=0,_t[x]=F>0?1:-1,f.push(_t.x,_t.y,_t.z),m.push(pt/k),m.push(1-J/j),U+=1}}for(let J=0;J<j;J++)for(let Z=0;Z<k;Z++){const pt=g+Z+q*J,vt=g+Z+q*(J+1),at=g+(Z+1)+q*(J+1),Tt=g+(Z+1)+q*J;d.push(pt,vt,Tt),d.push(vt,at,Tt),X+=6}h.addGroup(_,X,ot),_+=X,g+=U}}static fromJSON(t){return new $r(t.width,t.height,t.depth,t.widthSegments,t.heightSegments,t.depthSegments)}}function Ji(o){const t={};for(const e in o){t[e]={};for(const n in o[e]){const r=o[e][n];r&&(r.isColor||r.isMatrix3||r.isMatrix4||r.isVector2||r.isVector3||r.isVector4||r.isTexture||r.isQuaternion)?t[e][n]=r.clone():Array.isArray(r)?t[e][n]=r.slice():t[e][n]=r}}return t}function Ce(o){const t={};for(let e=0;e<o.length;e++){const n=Ji(o[e]);for(const r in n)t[r]=n[r]}return t}const Fg={clone:Ji,merge:Ce};var kg=`void main() {
	gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );
}`,Vg=`void main() {
	gl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );
}`;class di extends Pe{constructor(t){super(),this.type="ShaderMaterial",this.defines={},this.uniforms={},this.vertexShader=kg,this.fragmentShader=Vg,this.linewidth=1,this.wireframe=!1,this.wireframeLinewidth=1,this.fog=!1,this.lights=!1,this.clipping=!1,this.extensions={derivatives:!1,fragDepth:!1,drawBuffers:!1,shaderTextureLOD:!1},this.defaultAttributeValues={color:[1,1,1],uv:[0,0],uv2:[0,0]},this.index0AttributeName=void 0,this.uniformsNeedUpdate=!1,this.glslVersion=null,t!==void 0&&(t.attributes!==void 0&&console.error("THREE.ShaderMaterial: attributes should now be defined in THREE.BufferGeometry instead."),this.setValues(t))}copy(t){return super.copy(t),this.fragmentShader=t.fragmentShader,this.vertexShader=t.vertexShader,this.uniforms=Ji(t.uniforms),this.defines=Object.assign({},t.defines),this.wireframe=t.wireframe,this.wireframeLinewidth=t.wireframeLinewidth,this.lights=t.lights,this.clipping=t.clipping,this.extensions=Object.assign({},t.extensions),this.glslVersion=t.glslVersion,this}toJSON(t){const e=super.toJSON(t);e.glslVersion=this.glslVersion,e.uniforms={};for(const r in this.uniforms){const l=this.uniforms[r].value;l&&l.isTexture?e.uniforms[r]={type:"t",value:l.toJSON(t).uuid}:l&&l.isColor?e.uniforms[r]={type:"c",value:l.getHex()}:l&&l.isVector2?e.uniforms[r]={type:"v2",value:l.toArray()}:l&&l.isVector3?e.uniforms[r]={type:"v3",value:l.toArray()}:l&&l.isVector4?e.uniforms[r]={type:"v4",value:l.toArray()}:l&&l.isMatrix3?e.uniforms[r]={type:"m3",value:l.toArray()}:l&&l.isMatrix4?e.uniforms[r]={type:"m4",value:l.toArray()}:e.uniforms[r]={value:l}}Object.keys(this.defines).length>0&&(e.defines=this.defines),e.vertexShader=this.vertexShader,e.fragmentShader=this.fragmentShader;const n={};for(const r in this.extensions)this.extensions[r]===!0&&(n[r]=!0);return Object.keys(n).length>0&&(e.extensions=n),e}}di.prototype.isShaderMaterial=!0;class Va extends te{constructor(){super(),this.type="Camera",this.matrixWorldInverse=new At,this.projectionMatrix=new At,this.projectionMatrixInverse=new At}copy(t,e){return super.copy(t,e),this.matrixWorldInverse.copy(t.matrixWorldInverse),this.projectionMatrix.copy(t.projectionMatrix),this.projectionMatrixInverse.copy(t.projectionMatrixInverse),this}getWorldDirection(t){this.updateWorldMatrix(!0,!1);const e=this.matrixWorld.elements;return t.set(-e[8],-e[9],-e[10]).normalize()}updateMatrixWorld(t){super.updateMatrixWorld(t),this.matrixWorldInverse.copy(this.matrixWorld).invert()}updateWorldMatrix(t,e){super.updateWorldMatrix(t,e),this.matrixWorldInverse.copy(this.matrixWorld).invert()}clone(){return new this.constructor().copy(this)}}Va.prototype.isCamera=!0;class ke extends Va{constructor(t=50,e=1,n=.1,r=2e3){super(),this.type="PerspectiveCamera",this.fov=t,this.zoom=1,this.near=n,this.far=r,this.focus=10,this.aspect=e,this.view=null,this.filmGauge=35,this.filmOffset=0,this.updateProjectionMatrix()}copy(t,e){return super.copy(t,e),this.fov=t.fov,this.zoom=t.zoom,this.near=t.near,this.far=t.far,this.focus=t.focus,this.aspect=t.aspect,this.view=t.view===null?null:Object.assign({},t.view),this.filmGauge=t.filmGauge,this.filmOffset=t.filmOffset,this}setFocalLength(t){const e=.5*this.getFilmHeight()/t;this.fov=Ea*2*Math.atan(e),this.updateProjectionMatrix()}getFocalLength(){const t=Math.tan(Bo*.5*this.fov);return .5*this.getFilmHeight()/t}getEffectiveFOV(){return Ea*2*Math.atan(Math.tan(Bo*.5*this.fov)/this.zoom)}getFilmWidth(){return this.filmGauge*Math.min(this.aspect,1)}getFilmHeight(){return this.filmGauge/Math.max(this.aspect,1)}setViewOffset(t,e,n,r,s,l){this.aspect=t/e,this.view===null&&(this.view={enabled:!0,fullWidth:1,fullHeight:1,offsetX:0,offsetY:0,width:1,height:1}),this.view.enabled=!0,this.view.fullWidth=t,this.view.fullHeight=e,this.view.offsetX=n,this.view.offsetY=r,this.view.width=s,this.view.height=l,this.updateProjectionMatrix()}clearViewOffset(){this.view!==null&&(this.view.enabled=!1),this.updateProjectionMatrix()}updateProjectionMatrix(){const t=this.near;let e=t*Math.tan(Bo*.5*this.fov)/this.zoom,n=2*e,r=this.aspect*n,s=-.5*r;const l=this.view;if(this.view!==null&&this.view.enabled){const d=l.fullWidth,p=l.fullHeight;s+=l.offsetX*r/d,e-=l.offsetY*n/p,r*=l.width/d,n*=l.height/p}const h=this.filmOffset;h!==0&&(s+=t*h/this.getFilmWidth()),this.projectionMatrix.makePerspective(s,s+r,e,e-n,t,this.far),this.projectionMatrixInverse.copy(this.projectionMatrix).invert()}toJSON(t){const e=super.toJSON(t);return e.object.fov=this.fov,e.object.zoom=this.zoom,e.object.near=this.near,e.object.far=this.far,e.object.focus=this.focus,e.object.aspect=this.aspect,this.view!==null&&(e.object.view=Object.assign({},this.view)),e.object.filmGauge=this.filmGauge,e.object.filmOffset=this.filmOffset,e}}ke.prototype.isPerspectiveCamera=!0;const Ii=90,Ni=1;class Ba extends te{constructor(t,e,n){if(super(),this.type="CubeCamera",n.isWebGLCubeRenderTarget!==!0){console.error("THREE.CubeCamera: The constructor now expects an instance of WebGLCubeRenderTarget as third parameter.");return}this.renderTarget=n;const r=new ke(Ii,Ni,t,e);r.layers=this.layers,r.up.set(0,-1,0),r.lookAt(new D(1,0,0)),this.add(r);const s=new ke(Ii,Ni,t,e);s.layers=this.layers,s.up.set(0,-1,0),s.lookAt(new D(-1,0,0)),this.add(s);const l=new ke(Ii,Ni,t,e);l.layers=this.layers,l.up.set(0,0,1),l.lookAt(new D(0,1,0)),this.add(l);const h=new ke(Ii,Ni,t,e);h.layers=this.layers,h.up.set(0,0,-1),h.lookAt(new D(0,-1,0)),this.add(h);const d=new ke(Ii,Ni,t,e);d.layers=this.layers,d.up.set(0,-1,0),d.lookAt(new D(0,0,1)),this.add(d);const p=new ke(Ii,Ni,t,e);p.layers=this.layers,p.up.set(0,-1,0),p.lookAt(new D(0,0,-1)),this.add(p)}update(t,e){this.parent===null&&this.updateMatrixWorld();const n=this.renderTarget,[r,s,l,h,d,p]=this.children,f=t.xr.enabled,m=t.getRenderTarget();t.xr.enabled=!1;const g=n.texture.generateMipmaps;n.texture.generateMipmaps=!1,t.setRenderTarget(n,0),t.render(e,r),t.setRenderTarget(n,1),t.render(e,s),t.setRenderTarget(n,2),t.render(e,l),t.setRenderTarget(n,3),t.render(e,h),t.setRenderTarget(n,4),t.render(e,d),n.texture.generateMipmaps=g,t.setRenderTarget(n,5),t.render(e,p),t.setRenderTarget(m),t.xr.enabled=f}}class eo extends we{constructor(t,e,n,r,s,l,h,d,p,f){t=t!==void 0?t:[],e=e!==void 0?e:jr,super(t,e,n,r,s,l,h,d,p,f),this.flipY=!1}get images(){return this.image}set images(t){this.image=t}}eo.prototype.isCubeTexture=!0;class Jh extends Ye{constructor(t,e,n){Number.isInteger(e)&&(console.warn("THREE.WebGLCubeRenderTarget: constructor signature is now WebGLCubeRenderTarget( size, options )"),e=n),super(t,t,e),e=e||{},this.texture=new eo(void 0,e.mapping,e.wrapS,e.wrapT,e.magFilter,e.minFilter,e.format,e.type,e.anisotropy,e.encoding),this.texture.isRenderTargetTexture=!0,this.texture.generateMipmaps=e.generateMipmaps!==void 0?e.generateMipmaps:!1,this.texture.minFilter=e.minFilter!==void 0?e.minFilter:Le,this.texture._needsFlipEnvMap=!1}fromEquirectangularTexture(t,e){this.texture.type=e.type,this.texture.format=be,this.texture.encoding=e.encoding,this.texture.generateMipmaps=e.generateMipmaps,this.texture.minFilter=e.minFilter,this.texture.magFilter=e.magFilter;const n={uniforms:{tEquirect:{value:null}},vertexShader:`

				varying vec3 vWorldDirection;

				vec3 transformDirection( in vec3 dir, in mat4 matrix ) {

					return normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );

				}

				void main() {

					vWorldDirection = transformDirection( position, modelMatrix );

					#include <begin_vertex>
					#include <project_vertex>

				}
			`,fragmentShader:`

				uniform sampler2D tEquirect;

				varying vec3 vWorldDirection;

				#include <common>

				void main() {

					vec3 direction = normalize( vWorldDirection );

					vec2 sampleUV = equirectUv( direction );

					gl_FragColor = texture2D( tEquirect, sampleUV );

				}
			`},r=new $r(5,5,5),s=new di({name:"CubemapFromEquirect",uniforms:Ji(n.uniforms),vertexShader:n.vertexShader,fragmentShader:n.fragmentShader,side:ge,blending:Wn});s.uniforms.tEquirect.value=e;const l=new Ve(r,s),h=e.minFilter;return e.minFilter===Qs&&(e.minFilter=Le),new Ba(1,10,this).update(t,l),e.minFilter=h,l.geometry.dispose(),l.material.dispose(),this}clear(t,e,n,r){const s=t.getRenderTarget();for(let l=0;l<6;l++)t.setRenderTarget(this,l),t.clear(e,n,r);t.setRenderTarget(s)}}Jh.prototype.isWebGLCubeRenderTarget=!0;const aa=new D,Bg=new D,zg=new Te;class Sn{constructor(t=new D(1,0,0),e=0){this.normal=t,this.constant=e}set(t,e){return this.normal.copy(t),this.constant=e,this}setComponents(t,e,n,r){return this.normal.set(t,e,n),this.constant=r,this}setFromNormalAndCoplanarPoint(t,e){return this.normal.copy(t),this.constant=-e.dot(this.normal),this}setFromCoplanarPoints(t,e,n){const r=aa.subVectors(n,e).cross(Bg.subVectors(t,e)).normalize();return this.setFromNormalAndCoplanarPoint(r,t),this}copy(t){return this.normal.copy(t.normal),this.constant=t.constant,this}normalize(){const t=1/this.normal.length();return this.normal.multiplyScalar(t),this.constant*=t,this}negate(){return this.constant*=-1,this.normal.negate(),this}distanceToPoint(t){return this.normal.dot(t)+this.constant}distanceToSphere(t){return this.distanceToPoint(t.center)-t.radius}projectPoint(t,e){return e.copy(this.normal).multiplyScalar(-this.distanceToPoint(t)).add(t)}intersectLine(t,e){const n=t.delta(aa),r=this.normal.dot(n);if(r===0)return this.distanceToPoint(t.start)===0?e.copy(t.start):null;const s=-(t.start.dot(this.normal)+this.constant)/r;return s<0||s>1?null:e.copy(n).multiplyScalar(s).add(t.start)}intersectsLine(t){const e=this.distanceToPoint(t.start),n=this.distanceToPoint(t.end);return e<0&&n>0||n<0&&e>0}intersectsBox(t){return t.intersectsPlane(this)}intersectsSphere(t){return t.intersectsPlane(this)}coplanarPoint(t){return t.copy(this.normal).multiplyScalar(-this.constant)}applyMatrix4(t,e){const n=e||zg.getNormalMatrix(t),r=this.coplanarPoint(aa).applyMatrix4(t),s=this.normal.applyMatrix3(n).normalize();return this.constant=-r.dot(s),this}translate(t){return this.constant-=t.dot(this.normal),this}equals(t){return t.normal.equals(this.normal)&&t.constant===this.constant}clone(){return new this.constructor().copy(this)}}Sn.prototype.isPlane=!0;const Fi=new er,Cs=new D;class no{constructor(t=new Sn,e=new Sn,n=new Sn,r=new Sn,s=new Sn,l=new Sn){this.planes=[t,e,n,r,s,l]}set(t,e,n,r,s,l){const h=this.planes;return h[0].copy(t),h[1].copy(e),h[2].copy(n),h[3].copy(r),h[4].copy(s),h[5].copy(l),this}copy(t){const e=this.planes;for(let n=0;n<6;n++)e[n].copy(t.planes[n]);return this}setFromProjectionMatrix(t){const e=this.planes,n=t.elements,r=n[0],s=n[1],l=n[2],h=n[3],d=n[4],p=n[5],f=n[6],m=n[7],g=n[8],_=n[9],y=n[10],w=n[11],S=n[12],x=n[13],v=n[14],N=n[15];return e[0].setComponents(h-r,m-d,w-g,N-S).normalize(),e[1].setComponents(h+r,m+d,w+g,N+S).normalize(),e[2].setComponents(h+s,m+p,w+_,N+x).normalize(),e[3].setComponents(h-s,m-p,w-_,N-x).normalize(),e[4].setComponents(h-l,m-f,w-y,N-v).normalize(),e[5].setComponents(h+l,m+f,w+y,N+v).normalize(),this}intersectsObject(t){const e=t.geometry;return e.boundingSphere===null&&e.computeBoundingSphere(),Fi.copy(e.boundingSphere).applyMatrix4(t.matrixWorld),this.intersectsSphere(Fi)}intersectsSprite(t){return Fi.center.set(0,0,0),Fi.radius=.7071067811865476,Fi.applyMatrix4(t.matrixWorld),this.intersectsSphere(Fi)}intersectsSphere(t){const e=this.planes,n=t.center,r=-t.radius;for(let s=0;s<6;s++)if(e[s].distanceToPoint(n)<r)return!1;return!0}intersectsBox(t){const e=this.planes;for(let n=0;n<6;n++){const r=e[n];if(Cs.x=r.normal.x>0?t.max.x:t.min.x,Cs.y=r.normal.y>0?t.max.y:t.min.y,Cs.z=r.normal.z>0?t.max.z:t.min.z,r.distanceToPoint(Cs)<0)return!1}return!0}containsPoint(t){const e=this.planes;for(let n=0;n<6;n++)if(e[n].distanceToPoint(t)<0)return!1;return!0}clone(){return new this.constructor().copy(this)}}function Zh(){let o=null,t=!1,e=null,n=null;function r(s,l){e(s,l),n=o.requestAnimationFrame(r)}return{start:function(){t!==!0&&e!==null&&(n=o.requestAnimationFrame(r),t=!0)},stop:function(){o.cancelAnimationFrame(n),t=!1},setAnimationLoop:function(s){e=s},setContext:function(s){o=s}}}function Og(o,t){const e=t.isWebGL2,n=new WeakMap;function r(p,f){const m=p.array,g=p.usage,_=o.createBuffer();o.bindBuffer(f,_),o.bufferData(f,m,g),p.onUploadCallback();let y=5126;return m instanceof Float32Array?y=5126:m instanceof Float64Array?console.warn("THREE.WebGLAttributes: Unsupported data buffer format: Float64Array."):m instanceof Uint16Array?p.isFloat16BufferAttribute?e?y=5131:console.warn("THREE.WebGLAttributes: Usage of Float16BufferAttribute requires WebGL2."):y=5123:m instanceof Int16Array?y=5122:m instanceof Uint32Array?y=5125:m instanceof Int32Array?y=5124:m instanceof Int8Array?y=5120:(m instanceof Uint8Array||m instanceof Uint8ClampedArray)&&(y=5121),{buffer:_,type:y,bytesPerElement:m.BYTES_PER_ELEMENT,version:p.version}}function s(p,f,m){const g=f.array,_=f.updateRange;o.bindBuffer(m,p),_.count===-1?o.bufferSubData(m,0,g):(e?o.bufferSubData(m,_.offset*g.BYTES_PER_ELEMENT,g,_.offset,_.count):o.bufferSubData(m,_.offset*g.BYTES_PER_ELEMENT,g.subarray(_.offset,_.offset+_.count)),_.count=-1)}function l(p){return p.isInterleavedBufferAttribute&&(p=p.data),n.get(p)}function h(p){p.isInterleavedBufferAttribute&&(p=p.data);const f=n.get(p);f&&(o.deleteBuffer(f.buffer),n.delete(p))}function d(p,f){if(p.isGLBufferAttribute){const g=n.get(p);(!g||g.version<p.version)&&n.set(p,{buffer:p.buffer,type:p.type,bytesPerElement:p.elementSize,version:p.version});return}p.isInterleavedBufferAttribute&&(p=p.data);const m=n.get(p);m===void 0?n.set(p,r(p,f)):m.version<p.version&&(s(m.buffer,p,f),m.version=p.version)}return{get:l,remove:h,update:d}}class za extends ce{constructor(t=1,e=1,n=1,r=1){super(),this.type="PlaneGeometry",this.parameters={width:t,height:e,widthSegments:n,heightSegments:r};const s=t/2,l=e/2,h=Math.floor(n),d=Math.floor(r),p=h+1,f=d+1,m=t/h,g=e/d,_=[],y=[],w=[],S=[];for(let x=0;x<f;x++){const v=x*g-l;for(let N=0;N<p;N++){const M=N*m-s;y.push(M,-v,0),w.push(0,0,1),S.push(N/h),S.push(1-x/d)}}for(let x=0;x<d;x++)for(let v=0;v<h;v++){const N=v+p*x,M=v+p*(x+1),R=v+1+p*(x+1),F=v+1+p*x;_.push(N,M,F),_.push(M,R,F)}this.setIndex(_),this.setAttribute("position",new ye(y,3)),this.setAttribute("normal",new ye(w,3)),this.setAttribute("uv",new ye(S,2))}static fromJSON(t){return new za(t.width,t.height,t.widthSegments,t.heightSegments)}}var Ug=`#ifdef USE_ALPHAMAP
	diffuseColor.a *= texture2D( alphaMap, vUv ).g;
#endif`,Hg=`#ifdef USE_ALPHAMAP
	uniform sampler2D alphaMap;
#endif`,Gg=`#ifdef USE_ALPHATEST
	if ( diffuseColor.a < alphaTest ) discard;
#endif`,Wg=`#ifdef USE_ALPHATEST
	uniform float alphaTest;
#endif`,qg=`#ifdef USE_AOMAP
	float ambientOcclusion = ( texture2D( aoMap, vUv2 ).r - 1.0 ) * aoMapIntensity + 1.0;
	reflectedLight.indirectDiffuse *= ambientOcclusion;
	#if defined( USE_ENVMAP ) && defined( STANDARD )
		float dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );
		reflectedLight.indirectSpecular *= computeSpecularOcclusion( dotNV, ambientOcclusion, material.roughness );
	#endif
#endif`,jg=`#ifdef USE_AOMAP
	uniform sampler2D aoMap;
	uniform float aoMapIntensity;
#endif`,Xg="vec3 transformed = vec3( position );",$g=`vec3 objectNormal = vec3( normal );
#ifdef USE_TANGENT
	vec3 objectTangent = vec3( tangent.xyz );
#endif`,Yg=`vec3 BRDF_Lambert( const in vec3 diffuseColor ) {
	return RECIPROCAL_PI * diffuseColor;
}
vec3 F_Schlick( const in vec3 f0, const in float f90, const in float dotVH ) {
	float fresnel = exp2( ( - 5.55473 * dotVH - 6.98316 ) * dotVH );
	return f0 * ( 1.0 - fresnel ) + ( f90 * fresnel );
}
float V_GGX_SmithCorrelated( const in float alpha, const in float dotNL, const in float dotNV ) {
	float a2 = pow2( alpha );
	float gv = dotNL * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );
	float gl = dotNV * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );
	return 0.5 / max( gv + gl, EPSILON );
}
float D_GGX( const in float alpha, const in float dotNH ) {
	float a2 = pow2( alpha );
	float denom = pow2( dotNH ) * ( a2 - 1.0 ) + 1.0;
	return RECIPROCAL_PI * a2 / pow2( denom );
}
vec3 BRDF_GGX( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in vec3 f0, const in float f90, const in float roughness ) {
	float alpha = pow2( roughness );
	vec3 halfDir = normalize( lightDir + viewDir );
	float dotNL = saturate( dot( normal, lightDir ) );
	float dotNV = saturate( dot( normal, viewDir ) );
	float dotNH = saturate( dot( normal, halfDir ) );
	float dotVH = saturate( dot( viewDir, halfDir ) );
	vec3 F = F_Schlick( f0, f90, dotVH );
	float V = V_GGX_SmithCorrelated( alpha, dotNL, dotNV );
	float D = D_GGX( alpha, dotNH );
	return F * ( V * D );
}
vec2 LTC_Uv( const in vec3 N, const in vec3 V, const in float roughness ) {
	const float LUT_SIZE = 64.0;
	const float LUT_SCALE = ( LUT_SIZE - 1.0 ) / LUT_SIZE;
	const float LUT_BIAS = 0.5 / LUT_SIZE;
	float dotNV = saturate( dot( N, V ) );
	vec2 uv = vec2( roughness, sqrt( 1.0 - dotNV ) );
	uv = uv * LUT_SCALE + LUT_BIAS;
	return uv;
}
float LTC_ClippedSphereFormFactor( const in vec3 f ) {
	float l = length( f );
	return max( ( l * l + f.z ) / ( l + 1.0 ), 0.0 );
}
vec3 LTC_EdgeVectorFormFactor( const in vec3 v1, const in vec3 v2 ) {
	float x = dot( v1, v2 );
	float y = abs( x );
	float a = 0.8543985 + ( 0.4965155 + 0.0145206 * y ) * y;
	float b = 3.4175940 + ( 4.1616724 + y ) * y;
	float v = a / b;
	float theta_sintheta = ( x > 0.0 ) ? v : 0.5 * inversesqrt( max( 1.0 - x * x, 1e-7 ) ) - v;
	return cross( v1, v2 ) * theta_sintheta;
}
vec3 LTC_Evaluate( const in vec3 N, const in vec3 V, const in vec3 P, const in mat3 mInv, const in vec3 rectCoords[ 4 ] ) {
	vec3 v1 = rectCoords[ 1 ] - rectCoords[ 0 ];
	vec3 v2 = rectCoords[ 3 ] - rectCoords[ 0 ];
	vec3 lightNormal = cross( v1, v2 );
	if( dot( lightNormal, P - rectCoords[ 0 ] ) < 0.0 ) return vec3( 0.0 );
	vec3 T1, T2;
	T1 = normalize( V - N * dot( V, N ) );
	T2 = - cross( N, T1 );
	mat3 mat = mInv * transposeMat3( mat3( T1, T2, N ) );
	vec3 coords[ 4 ];
	coords[ 0 ] = mat * ( rectCoords[ 0 ] - P );
	coords[ 1 ] = mat * ( rectCoords[ 1 ] - P );
	coords[ 2 ] = mat * ( rectCoords[ 2 ] - P );
	coords[ 3 ] = mat * ( rectCoords[ 3 ] - P );
	coords[ 0 ] = normalize( coords[ 0 ] );
	coords[ 1 ] = normalize( coords[ 1 ] );
	coords[ 2 ] = normalize( coords[ 2 ] );
	coords[ 3 ] = normalize( coords[ 3 ] );
	vec3 vectorFormFactor = vec3( 0.0 );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 0 ], coords[ 1 ] );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 1 ], coords[ 2 ] );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 2 ], coords[ 3 ] );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 3 ], coords[ 0 ] );
	float result = LTC_ClippedSphereFormFactor( vectorFormFactor );
	return vec3( result );
}
float G_BlinnPhong_Implicit( ) {
	return 0.25;
}
float D_BlinnPhong( const in float shininess, const in float dotNH ) {
	return RECIPROCAL_PI * ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );
}
vec3 BRDF_BlinnPhong( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in vec3 specularColor, const in float shininess ) {
	vec3 halfDir = normalize( lightDir + viewDir );
	float dotNH = saturate( dot( normal, halfDir ) );
	float dotVH = saturate( dot( viewDir, halfDir ) );
	vec3 F = F_Schlick( specularColor, 1.0, dotVH );
	float G = G_BlinnPhong_Implicit( );
	float D = D_BlinnPhong( shininess, dotNH );
	return F * ( G * D );
}
#if defined( USE_SHEEN )
float D_Charlie( float roughness, float dotNH ) {
	float alpha = pow2( roughness );
	float invAlpha = 1.0 / alpha;
	float cos2h = dotNH * dotNH;
	float sin2h = max( 1.0 - cos2h, 0.0078125 );
	return ( 2.0 + invAlpha ) * pow( sin2h, invAlpha * 0.5 ) / ( 2.0 * PI );
}
float V_Neubelt( float dotNV, float dotNL ) {
	return saturate( 1.0 / ( 4.0 * ( dotNL + dotNV - dotNL * dotNV ) ) );
}
vec3 BRDF_Sheen( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, vec3 sheenColor, const in float sheenRoughness ) {
	vec3 halfDir = normalize( lightDir + viewDir );
	float dotNL = saturate( dot( normal, lightDir ) );
	float dotNV = saturate( dot( normal, viewDir ) );
	float dotNH = saturate( dot( normal, halfDir ) );
	float D = D_Charlie( sheenRoughness, dotNH );
	float V = V_Neubelt( dotNV, dotNL );
	return sheenColor * ( D * V );
}
#endif`,Jg=`#ifdef USE_BUMPMAP
	uniform sampler2D bumpMap;
	uniform float bumpScale;
	vec2 dHdxy_fwd() {
		vec2 dSTdx = dFdx( vUv );
		vec2 dSTdy = dFdy( vUv );
		float Hll = bumpScale * texture2D( bumpMap, vUv ).x;
		float dBx = bumpScale * texture2D( bumpMap, vUv + dSTdx ).x - Hll;
		float dBy = bumpScale * texture2D( bumpMap, vUv + dSTdy ).x - Hll;
		return vec2( dBx, dBy );
	}
	vec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy, float faceDirection ) {
		vec3 vSigmaX = vec3( dFdx( surf_pos.x ), dFdx( surf_pos.y ), dFdx( surf_pos.z ) );
		vec3 vSigmaY = vec3( dFdy( surf_pos.x ), dFdy( surf_pos.y ), dFdy( surf_pos.z ) );
		vec3 vN = surf_norm;
		vec3 R1 = cross( vSigmaY, vN );
		vec3 R2 = cross( vN, vSigmaX );
		float fDet = dot( vSigmaX, R1 ) * faceDirection;
		vec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );
		return normalize( abs( fDet ) * surf_norm - vGrad );
	}
#endif`,Zg=`#if NUM_CLIPPING_PLANES > 0
	vec4 plane;
	#pragma unroll_loop_start
	for ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {
		plane = clippingPlanes[ i ];
		if ( dot( vClipPosition, plane.xyz ) > plane.w ) discard;
	}
	#pragma unroll_loop_end
	#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES
		bool clipped = true;
		#pragma unroll_loop_start
		for ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {
			plane = clippingPlanes[ i ];
			clipped = ( dot( vClipPosition, plane.xyz ) > plane.w ) && clipped;
		}
		#pragma unroll_loop_end
		if ( clipped ) discard;
	#endif
#endif`,Kg=`#if NUM_CLIPPING_PLANES > 0
	varying vec3 vClipPosition;
	uniform vec4 clippingPlanes[ NUM_CLIPPING_PLANES ];
#endif`,Qg=`#if NUM_CLIPPING_PLANES > 0
	varying vec3 vClipPosition;
#endif`,tv=`#if NUM_CLIPPING_PLANES > 0
	vClipPosition = - mvPosition.xyz;
#endif`,ev=`#if defined( USE_COLOR_ALPHA )
	diffuseColor *= vColor;
#elif defined( USE_COLOR )
	diffuseColor.rgb *= vColor;
#endif`,nv=`#if defined( USE_COLOR_ALPHA )
	varying vec4 vColor;
#elif defined( USE_COLOR )
	varying vec3 vColor;
#endif`,iv=`#if defined( USE_COLOR_ALPHA )
	varying vec4 vColor;
#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )
	varying vec3 vColor;
#endif`,rv=`#if defined( USE_COLOR_ALPHA )
	vColor = vec4( 1.0 );
#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )
	vColor = vec3( 1.0 );
#endif
#ifdef USE_COLOR
	vColor *= color;
#endif
#ifdef USE_INSTANCING_COLOR
	vColor.xyz *= instanceColor.xyz;
#endif`,sv=`#define PI 3.141592653589793
#define PI2 6.283185307179586
#define PI_HALF 1.5707963267948966
#define RECIPROCAL_PI 0.3183098861837907
#define RECIPROCAL_PI2 0.15915494309189535
#define EPSILON 1e-6
#ifndef saturate
#define saturate( a ) clamp( a, 0.0, 1.0 )
#endif
#define whiteComplement( a ) ( 1.0 - saturate( a ) )
float pow2( const in float x ) { return x*x; }
float pow3( const in float x ) { return x*x*x; }
float pow4( const in float x ) { float x2 = x*x; return x2*x2; }
float max3( const in vec3 v ) { return max( max( v.x, v.y ), v.z ); }
float average( const in vec3 color ) { return dot( color, vec3( 0.3333 ) ); }
highp float rand( const in vec2 uv ) {
	const highp float a = 12.9898, b = 78.233, c = 43758.5453;
	highp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );
	return fract( sin( sn ) * c );
}
#ifdef HIGH_PRECISION
	float precisionSafeLength( vec3 v ) { return length( v ); }
#else
	float precisionSafeLength( vec3 v ) {
		float maxComponent = max3( abs( v ) );
		return length( v / maxComponent ) * maxComponent;
	}
#endif
struct IncidentLight {
	vec3 color;
	vec3 direction;
	bool visible;
};
struct ReflectedLight {
	vec3 directDiffuse;
	vec3 directSpecular;
	vec3 indirectDiffuse;
	vec3 indirectSpecular;
};
struct GeometricContext {
	vec3 position;
	vec3 normal;
	vec3 viewDir;
#ifdef USE_CLEARCOAT
	vec3 clearcoatNormal;
#endif
};
vec3 transformDirection( in vec3 dir, in mat4 matrix ) {
	return normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );
}
vec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {
	return normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );
}
mat3 transposeMat3( const in mat3 m ) {
	mat3 tmp;
	tmp[ 0 ] = vec3( m[ 0 ].x, m[ 1 ].x, m[ 2 ].x );
	tmp[ 1 ] = vec3( m[ 0 ].y, m[ 1 ].y, m[ 2 ].y );
	tmp[ 2 ] = vec3( m[ 0 ].z, m[ 1 ].z, m[ 2 ].z );
	return tmp;
}
float linearToRelativeLuminance( const in vec3 color ) {
	vec3 weights = vec3( 0.2126, 0.7152, 0.0722 );
	return dot( weights, color.rgb );
}
bool isPerspectiveMatrix( mat4 m ) {
	return m[ 2 ][ 3 ] == - 1.0;
}
vec2 equirectUv( in vec3 dir ) {
	float u = atan( dir.z, dir.x ) * RECIPROCAL_PI2 + 0.5;
	float v = asin( clamp( dir.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;
	return vec2( u, v );
}`,ov=`#ifdef ENVMAP_TYPE_CUBE_UV
	#define cubeUV_maxMipLevel 8.0
	#define cubeUV_minMipLevel 4.0
	#define cubeUV_maxTileSize 256.0
	#define cubeUV_minTileSize 16.0
	float getFace( vec3 direction ) {
		vec3 absDirection = abs( direction );
		float face = - 1.0;
		if ( absDirection.x > absDirection.z ) {
			if ( absDirection.x > absDirection.y )
				face = direction.x > 0.0 ? 0.0 : 3.0;
			else
				face = direction.y > 0.0 ? 1.0 : 4.0;
		} else {
			if ( absDirection.z > absDirection.y )
				face = direction.z > 0.0 ? 2.0 : 5.0;
			else
				face = direction.y > 0.0 ? 1.0 : 4.0;
		}
		return face;
	}
	vec2 getUV( vec3 direction, float face ) {
		vec2 uv;
		if ( face == 0.0 ) {
			uv = vec2( direction.z, direction.y ) / abs( direction.x );
		} else if ( face == 1.0 ) {
			uv = vec2( - direction.x, - direction.z ) / abs( direction.y );
		} else if ( face == 2.0 ) {
			uv = vec2( - direction.x, direction.y ) / abs( direction.z );
		} else if ( face == 3.0 ) {
			uv = vec2( - direction.z, direction.y ) / abs( direction.x );
		} else if ( face == 4.0 ) {
			uv = vec2( - direction.x, direction.z ) / abs( direction.y );
		} else {
			uv = vec2( direction.x, direction.y ) / abs( direction.z );
		}
		return 0.5 * ( uv + 1.0 );
	}
	vec3 bilinearCubeUV( sampler2D envMap, vec3 direction, float mipInt ) {
		float face = getFace( direction );
		float filterInt = max( cubeUV_minMipLevel - mipInt, 0.0 );
		mipInt = max( mipInt, cubeUV_minMipLevel );
		float faceSize = exp2( mipInt );
		float texelSize = 1.0 / ( 3.0 * cubeUV_maxTileSize );
		vec2 uv = getUV( direction, face ) * ( faceSize - 1.0 ) + 0.5;
		if ( face > 2.0 ) {
			uv.y += faceSize;
			face -= 3.0;
		}
		uv.x += face * faceSize;
		if ( mipInt < cubeUV_maxMipLevel ) {
			uv.y += 2.0 * cubeUV_maxTileSize;
		}
		uv.y += filterInt * 2.0 * cubeUV_minTileSize;
		uv.x += 3.0 * max( 0.0, cubeUV_maxTileSize - 2.0 * faceSize );
		uv *= texelSize;
		return texture2D( envMap, uv ).rgb;
	}
	#define r0 1.0
	#define v0 0.339
	#define m0 - 2.0
	#define r1 0.8
	#define v1 0.276
	#define m1 - 1.0
	#define r4 0.4
	#define v4 0.046
	#define m4 2.0
	#define r5 0.305
	#define v5 0.016
	#define m5 3.0
	#define r6 0.21
	#define v6 0.0038
	#define m6 4.0
	float roughnessToMip( float roughness ) {
		float mip = 0.0;
		if ( roughness >= r1 ) {
			mip = ( r0 - roughness ) * ( m1 - m0 ) / ( r0 - r1 ) + m0;
		} else if ( roughness >= r4 ) {
			mip = ( r1 - roughness ) * ( m4 - m1 ) / ( r1 - r4 ) + m1;
		} else if ( roughness >= r5 ) {
			mip = ( r4 - roughness ) * ( m5 - m4 ) / ( r4 - r5 ) + m4;
		} else if ( roughness >= r6 ) {
			mip = ( r5 - roughness ) * ( m6 - m5 ) / ( r5 - r6 ) + m5;
		} else {
			mip = - 2.0 * log2( 1.16 * roughness );		}
		return mip;
	}
	vec4 textureCubeUV( sampler2D envMap, vec3 sampleDir, float roughness ) {
		float mip = clamp( roughnessToMip( roughness ), m0, cubeUV_maxMipLevel );
		float mipF = fract( mip );
		float mipInt = floor( mip );
		vec3 color0 = bilinearCubeUV( envMap, sampleDir, mipInt );
		if ( mipF == 0.0 ) {
			return vec4( color0, 1.0 );
		} else {
			vec3 color1 = bilinearCubeUV( envMap, sampleDir, mipInt + 1.0 );
			return vec4( mix( color0, color1, mipF ), 1.0 );
		}
	}
#endif`,av=`vec3 transformedNormal = objectNormal;
#ifdef USE_INSTANCING
	mat3 m = mat3( instanceMatrix );
	transformedNormal /= vec3( dot( m[ 0 ], m[ 0 ] ), dot( m[ 1 ], m[ 1 ] ), dot( m[ 2 ], m[ 2 ] ) );
	transformedNormal = m * transformedNormal;
#endif
transformedNormal = normalMatrix * transformedNormal;
#ifdef FLIP_SIDED
	transformedNormal = - transformedNormal;
#endif
#ifdef USE_TANGENT
	vec3 transformedTangent = ( modelViewMatrix * vec4( objectTangent, 0.0 ) ).xyz;
	#ifdef FLIP_SIDED
		transformedTangent = - transformedTangent;
	#endif
#endif`,lv=`#ifdef USE_DISPLACEMENTMAP
	uniform sampler2D displacementMap;
	uniform float displacementScale;
	uniform float displacementBias;
#endif`,cv=`#ifdef USE_DISPLACEMENTMAP
	transformed += normalize( objectNormal ) * ( texture2D( displacementMap, vUv ).x * displacementScale + displacementBias );
#endif`,hv=`#ifdef USE_EMISSIVEMAP
	vec4 emissiveColor = texture2D( emissiveMap, vUv );
	emissiveColor.rgb = emissiveMapTexelToLinear( emissiveColor ).rgb;
	totalEmissiveRadiance *= emissiveColor.rgb;
#endif`,uv=`#ifdef USE_EMISSIVEMAP
	uniform sampler2D emissiveMap;
#endif`,dv="gl_FragColor = linearToOutputTexel( gl_FragColor );",pv=`vec4 LinearToLinear( in vec4 value ) {
	return value;
}
vec4 sRGBToLinear( in vec4 value ) {
	return vec4( mix( pow( value.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), value.rgb * 0.0773993808, vec3( lessThanEqual( value.rgb, vec3( 0.04045 ) ) ) ), value.a );
}
vec4 LinearTosRGB( in vec4 value ) {
	return vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.a );
}`,fv=`#ifdef USE_ENVMAP
	#ifdef ENV_WORLDPOS
		vec3 cameraToFrag;
		if ( isOrthographic ) {
			cameraToFrag = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );
		} else {
			cameraToFrag = normalize( vWorldPosition - cameraPosition );
		}
		vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );
		#ifdef ENVMAP_MODE_REFLECTION
			vec3 reflectVec = reflect( cameraToFrag, worldNormal );
		#else
			vec3 reflectVec = refract( cameraToFrag, worldNormal, refractionRatio );
		#endif
	#else
		vec3 reflectVec = vReflect;
	#endif
	#ifdef ENVMAP_TYPE_CUBE
		vec4 envColor = textureCube( envMap, vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );
		envColor = envMapTexelToLinear( envColor );
	#elif defined( ENVMAP_TYPE_CUBE_UV )
		vec4 envColor = textureCubeUV( envMap, reflectVec, 0.0 );
	#else
		vec4 envColor = vec4( 0.0 );
	#endif
	#ifdef ENVMAP_BLENDING_MULTIPLY
		outgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );
	#elif defined( ENVMAP_BLENDING_MIX )
		outgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );
	#elif defined( ENVMAP_BLENDING_ADD )
		outgoingLight += envColor.xyz * specularStrength * reflectivity;
	#endif
#endif`,mv=`#ifdef USE_ENVMAP
	uniform float envMapIntensity;
	uniform float flipEnvMap;
	#ifdef ENVMAP_TYPE_CUBE
		uniform samplerCube envMap;
	#else
		uniform sampler2D envMap;
	#endif
	
#endif`,gv=`#ifdef USE_ENVMAP
	uniform float reflectivity;
	#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )
		#define ENV_WORLDPOS
	#endif
	#ifdef ENV_WORLDPOS
		varying vec3 vWorldPosition;
		uniform float refractionRatio;
	#else
		varying vec3 vReflect;
	#endif
#endif`,vv=`#ifdef USE_ENVMAP
	#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) ||defined( PHONG )
		#define ENV_WORLDPOS
	#endif
	#ifdef ENV_WORLDPOS
		
		varying vec3 vWorldPosition;
	#else
		varying vec3 vReflect;
		uniform float refractionRatio;
	#endif
#endif`,_v=`#ifdef USE_ENVMAP
	#ifdef ENV_WORLDPOS
		vWorldPosition = worldPosition.xyz;
	#else
		vec3 cameraToVertex;
		if ( isOrthographic ) {
			cameraToVertex = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );
		} else {
			cameraToVertex = normalize( worldPosition.xyz - cameraPosition );
		}
		vec3 worldNormal = inverseTransformDirection( transformedNormal, viewMatrix );
		#ifdef ENVMAP_MODE_REFLECTION
			vReflect = reflect( cameraToVertex, worldNormal );
		#else
			vReflect = refract( cameraToVertex, worldNormal, refractionRatio );
		#endif
	#endif
#endif`,xv=`#ifdef USE_FOG
	vFogDepth = - mvPosition.z;
#endif`,bv=`#ifdef USE_FOG
	varying float vFogDepth;
#endif`,yv=`#ifdef USE_FOG
	#ifdef FOG_EXP2
		float fogFactor = 1.0 - exp( - fogDensity * fogDensity * vFogDepth * vFogDepth );
	#else
		float fogFactor = smoothstep( fogNear, fogFar, vFogDepth );
	#endif
	gl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );
#endif`,wv=`#ifdef USE_FOG
	uniform vec3 fogColor;
	varying float vFogDepth;
	#ifdef FOG_EXP2
		uniform float fogDensity;
	#else
		uniform float fogNear;
		uniform float fogFar;
	#endif
#endif`,Mv=`#ifdef USE_GRADIENTMAP
	uniform sampler2D gradientMap;
#endif
vec3 getGradientIrradiance( vec3 normal, vec3 lightDirection ) {
	float dotNL = dot( normal, lightDirection );
	vec2 coord = vec2( dotNL * 0.5 + 0.5, 0.0 );
	#ifdef USE_GRADIENTMAP
		return vec3( texture2D( gradientMap, coord ).r );
	#else
		return ( coord.x < 0.7 ) ? vec3( 0.7 ) : vec3( 1.0 );
	#endif
}`,Sv=`#ifdef USE_LIGHTMAP
	vec4 lightMapTexel = texture2D( lightMap, vUv2 );
	vec3 lightMapIrradiance = lightMapTexelToLinear( lightMapTexel ).rgb * lightMapIntensity;
	#ifndef PHYSICALLY_CORRECT_LIGHTS
		lightMapIrradiance *= PI;
	#endif
	reflectedLight.indirectDiffuse += lightMapIrradiance;
#endif`,Ev=`#ifdef USE_LIGHTMAP
	uniform sampler2D lightMap;
	uniform float lightMapIntensity;
#endif`,Tv=`vec3 diffuse = vec3( 1.0 );
GeometricContext geometry;
geometry.position = mvPosition.xyz;
geometry.normal = normalize( transformedNormal );
geometry.viewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( -mvPosition.xyz );
GeometricContext backGeometry;
backGeometry.position = geometry.position;
backGeometry.normal = -geometry.normal;
backGeometry.viewDir = geometry.viewDir;
vLightFront = vec3( 0.0 );
vIndirectFront = vec3( 0.0 );
#ifdef DOUBLE_SIDED
	vLightBack = vec3( 0.0 );
	vIndirectBack = vec3( 0.0 );
#endif
IncidentLight directLight;
float dotNL;
vec3 directLightColor_Diffuse;
vIndirectFront += getAmbientLightIrradiance( ambientLightColor );
vIndirectFront += getLightProbeIrradiance( lightProbe, geometry.normal );
#ifdef DOUBLE_SIDED
	vIndirectBack += getAmbientLightIrradiance( ambientLightColor );
	vIndirectBack += getLightProbeIrradiance( lightProbe, backGeometry.normal );
#endif
#if NUM_POINT_LIGHTS > 0
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {
		getPointLightInfo( pointLights[ i ], geometry, directLight );
		dotNL = dot( geometry.normal, directLight.direction );
		directLightColor_Diffuse = directLight.color;
		vLightFront += saturate( dotNL ) * directLightColor_Diffuse;
		#ifdef DOUBLE_SIDED
			vLightBack += saturate( - dotNL ) * directLightColor_Diffuse;
		#endif
	}
	#pragma unroll_loop_end
#endif
#if NUM_SPOT_LIGHTS > 0
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {
		getSpotLightInfo( spotLights[ i ], geometry, directLight );
		dotNL = dot( geometry.normal, directLight.direction );
		directLightColor_Diffuse = directLight.color;
		vLightFront += saturate( dotNL ) * directLightColor_Diffuse;
		#ifdef DOUBLE_SIDED
			vLightBack += saturate( - dotNL ) * directLightColor_Diffuse;
		#endif
	}
	#pragma unroll_loop_end
#endif
#if NUM_DIR_LIGHTS > 0
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {
		getDirectionalLightInfo( directionalLights[ i ], geometry, directLight );
		dotNL = dot( geometry.normal, directLight.direction );
		directLightColor_Diffuse = directLight.color;
		vLightFront += saturate( dotNL ) * directLightColor_Diffuse;
		#ifdef DOUBLE_SIDED
			vLightBack += saturate( - dotNL ) * directLightColor_Diffuse;
		#endif
	}
	#pragma unroll_loop_end
#endif
#if NUM_HEMI_LIGHTS > 0
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {
		vIndirectFront += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry.normal );
		#ifdef DOUBLE_SIDED
			vIndirectBack += getHemisphereLightIrradiance( hemisphereLights[ i ], backGeometry.normal );
		#endif
	}
	#pragma unroll_loop_end
#endif`,Cv=`uniform bool receiveShadow;
uniform vec3 ambientLightColor;
uniform vec3 lightProbe[ 9 ];
vec3 shGetIrradianceAt( in vec3 normal, in vec3 shCoefficients[ 9 ] ) {
	float x = normal.x, y = normal.y, z = normal.z;
	vec3 result = shCoefficients[ 0 ] * 0.886227;
	result += shCoefficients[ 1 ] * 2.0 * 0.511664 * y;
	result += shCoefficients[ 2 ] * 2.0 * 0.511664 * z;
	result += shCoefficients[ 3 ] * 2.0 * 0.511664 * x;
	result += shCoefficients[ 4 ] * 2.0 * 0.429043 * x * y;
	result += shCoefficients[ 5 ] * 2.0 * 0.429043 * y * z;
	result += shCoefficients[ 6 ] * ( 0.743125 * z * z - 0.247708 );
	result += shCoefficients[ 7 ] * 2.0 * 0.429043 * x * z;
	result += shCoefficients[ 8 ] * 0.429043 * ( x * x - y * y );
	return result;
}
vec3 getLightProbeIrradiance( const in vec3 lightProbe[ 9 ], const in vec3 normal ) {
	vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );
	vec3 irradiance = shGetIrradianceAt( worldNormal, lightProbe );
	return irradiance;
}
vec3 getAmbientLightIrradiance( const in vec3 ambientLightColor ) {
	vec3 irradiance = ambientLightColor;
	return irradiance;
}
float getDistanceAttenuation( const in float lightDistance, const in float cutoffDistance, const in float decayExponent ) {
	#if defined ( PHYSICALLY_CORRECT_LIGHTS )
		float distanceFalloff = 1.0 / max( pow( lightDistance, decayExponent ), 0.01 );
		if ( cutoffDistance > 0.0 ) {
			distanceFalloff *= pow2( saturate( 1.0 - pow4( lightDistance / cutoffDistance ) ) );
		}
		return distanceFalloff;
	#else
		if ( cutoffDistance > 0.0 && decayExponent > 0.0 ) {
			return pow( saturate( - lightDistance / cutoffDistance + 1.0 ), decayExponent );
		}
		return 1.0;
	#endif
}
float getSpotAttenuation( const in float coneCosine, const in float penumbraCosine, const in float angleCosine ) {
	return smoothstep( coneCosine, penumbraCosine, angleCosine );
}
#if NUM_DIR_LIGHTS > 0
	struct DirectionalLight {
		vec3 direction;
		vec3 color;
	};
	uniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];
	void getDirectionalLightInfo( const in DirectionalLight directionalLight, const in GeometricContext geometry, out IncidentLight light ) {
		light.color = directionalLight.color;
		light.direction = directionalLight.direction;
		light.visible = true;
	}
#endif
#if NUM_POINT_LIGHTS > 0
	struct PointLight {
		vec3 position;
		vec3 color;
		float distance;
		float decay;
	};
	uniform PointLight pointLights[ NUM_POINT_LIGHTS ];
	void getPointLightInfo( const in PointLight pointLight, const in GeometricContext geometry, out IncidentLight light ) {
		vec3 lVector = pointLight.position - geometry.position;
		light.direction = normalize( lVector );
		float lightDistance = length( lVector );
		light.color = pointLight.color;
		light.color *= getDistanceAttenuation( lightDistance, pointLight.distance, pointLight.decay );
		light.visible = ( light.color != vec3( 0.0 ) );
	}
#endif
#if NUM_SPOT_LIGHTS > 0
	struct SpotLight {
		vec3 position;
		vec3 direction;
		vec3 color;
		float distance;
		float decay;
		float coneCos;
		float penumbraCos;
	};
	uniform SpotLight spotLights[ NUM_SPOT_LIGHTS ];
	void getSpotLightInfo( const in SpotLight spotLight, const in GeometricContext geometry, out IncidentLight light ) {
		vec3 lVector = spotLight.position - geometry.position;
		light.direction = normalize( lVector );
		float angleCos = dot( light.direction, spotLight.direction );
		float spotAttenuation = getSpotAttenuation( spotLight.coneCos, spotLight.penumbraCos, angleCos );
		if ( spotAttenuation > 0.0 ) {
			float lightDistance = length( lVector );
			light.color = spotLight.color * spotAttenuation;
			light.color *= getDistanceAttenuation( lightDistance, spotLight.distance, spotLight.decay );
			light.visible = ( light.color != vec3( 0.0 ) );
		} else {
			light.color = vec3( 0.0 );
			light.visible = false;
		}
	}
#endif
#if NUM_RECT_AREA_LIGHTS > 0
	struct RectAreaLight {
		vec3 color;
		vec3 position;
		vec3 halfWidth;
		vec3 halfHeight;
	};
	uniform sampler2D ltc_1;	uniform sampler2D ltc_2;
	uniform RectAreaLight rectAreaLights[ NUM_RECT_AREA_LIGHTS ];
#endif
#if NUM_HEMI_LIGHTS > 0
	struct HemisphereLight {
		vec3 direction;
		vec3 skyColor;
		vec3 groundColor;
	};
	uniform HemisphereLight hemisphereLights[ NUM_HEMI_LIGHTS ];
	vec3 getHemisphereLightIrradiance( const in HemisphereLight hemiLight, const in vec3 normal ) {
		float dotNL = dot( normal, hemiLight.direction );
		float hemiDiffuseWeight = 0.5 * dotNL + 0.5;
		vec3 irradiance = mix( hemiLight.groundColor, hemiLight.skyColor, hemiDiffuseWeight );
		return irradiance;
	}
#endif`,Av=`#if defined( USE_ENVMAP )
	#ifdef ENVMAP_MODE_REFRACTION
		uniform float refractionRatio;
	#endif
	vec3 getIBLIrradiance( const in vec3 normal ) {
		#if defined( ENVMAP_TYPE_CUBE_UV )
			vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );
			vec4 envMapColor = textureCubeUV( envMap, worldNormal, 1.0 );
			return PI * envMapColor.rgb * envMapIntensity;
		#else
			return vec3( 0.0 );
		#endif
	}
	vec3 getIBLRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness ) {
		#if defined( ENVMAP_TYPE_CUBE_UV )
			vec3 reflectVec;
			#ifdef ENVMAP_MODE_REFLECTION
				reflectVec = reflect( - viewDir, normal );
				reflectVec = normalize( mix( reflectVec, normal, roughness * roughness) );
			#else
				reflectVec = refract( - viewDir, normal, refractionRatio );
			#endif
			reflectVec = inverseTransformDirection( reflectVec, viewMatrix );
			vec4 envMapColor = textureCubeUV( envMap, reflectVec, roughness );
			return envMapColor.rgb * envMapIntensity;
		#else
			return vec3( 0.0 );
		#endif
	}
#endif`,Pv=`ToonMaterial material;
material.diffuseColor = diffuseColor.rgb;`,Lv=`varying vec3 vViewPosition;
struct ToonMaterial {
	vec3 diffuseColor;
};
void RE_Direct_Toon( const in IncidentLight directLight, const in GeometricContext geometry, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {
	vec3 irradiance = getGradientIrradiance( geometry.normal, directLight.direction ) * directLight.color;
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectDiffuse_Toon( const in vec3 irradiance, const in GeometricContext geometry, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
#define RE_Direct				RE_Direct_Toon
#define RE_IndirectDiffuse		RE_IndirectDiffuse_Toon
#define Material_LightProbeLOD( material )	(0)`,Rv=`BlinnPhongMaterial material;
material.diffuseColor = diffuseColor.rgb;
material.specularColor = specular;
material.specularShininess = shininess;
material.specularStrength = specularStrength;`,Dv=`varying vec3 vViewPosition;
struct BlinnPhongMaterial {
	vec3 diffuseColor;
	vec3 specularColor;
	float specularShininess;
	float specularStrength;
};
void RE_Direct_BlinnPhong( const in IncidentLight directLight, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {
	float dotNL = saturate( dot( geometry.normal, directLight.direction ) );
	vec3 irradiance = dotNL * directLight.color;
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
	reflectedLight.directSpecular += irradiance * BRDF_BlinnPhong( directLight.direction, geometry.viewDir, geometry.normal, material.specularColor, material.specularShininess ) * material.specularStrength;
}
void RE_IndirectDiffuse_BlinnPhong( const in vec3 irradiance, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
#define RE_Direct				RE_Direct_BlinnPhong
#define RE_IndirectDiffuse		RE_IndirectDiffuse_BlinnPhong
#define Material_LightProbeLOD( material )	(0)`,Iv=`PhysicalMaterial material;
material.diffuseColor = diffuseColor.rgb * ( 1.0 - metalnessFactor );
vec3 dxy = max( abs( dFdx( geometryNormal ) ), abs( dFdy( geometryNormal ) ) );
float geometryRoughness = max( max( dxy.x, dxy.y ), dxy.z );
material.roughness = max( roughnessFactor, 0.0525 );material.roughness += geometryRoughness;
material.roughness = min( material.roughness, 1.0 );
#ifdef IOR
	#ifdef SPECULAR
		float specularIntensityFactor = specularIntensity;
		vec3 specularColorFactor = specularColor;
		#ifdef USE_SPECULARINTENSITYMAP
			specularIntensityFactor *= texture2D( specularIntensityMap, vUv ).a;
		#endif
		#ifdef USE_SPECULARCOLORMAP
			specularColorFactor *= specularColorMapTexelToLinear( texture2D( specularColorMap, vUv ) ).rgb;
		#endif
		material.specularF90 = mix( specularIntensityFactor, 1.0, metalnessFactor );
	#else
		float specularIntensityFactor = 1.0;
		vec3 specularColorFactor = vec3( 1.0 );
		material.specularF90 = 1.0;
	#endif
	material.specularColor = mix( min( pow2( ( ior - 1.0 ) / ( ior + 1.0 ) ) * specularColorFactor, vec3( 1.0 ) ) * specularIntensityFactor, diffuseColor.rgb, metalnessFactor );
#else
	material.specularColor = mix( vec3( 0.04 ), diffuseColor.rgb, metalnessFactor );
	material.specularF90 = 1.0;
#endif
#ifdef USE_CLEARCOAT
	material.clearcoat = clearcoat;
	material.clearcoatRoughness = clearcoatRoughness;
	material.clearcoatF0 = vec3( 0.04 );
	material.clearcoatF90 = 1.0;
	#ifdef USE_CLEARCOATMAP
		material.clearcoat *= texture2D( clearcoatMap, vUv ).x;
	#endif
	#ifdef USE_CLEARCOAT_ROUGHNESSMAP
		material.clearcoatRoughness *= texture2D( clearcoatRoughnessMap, vUv ).y;
	#endif
	material.clearcoat = saturate( material.clearcoat );	material.clearcoatRoughness = max( material.clearcoatRoughness, 0.0525 );
	material.clearcoatRoughness += geometryRoughness;
	material.clearcoatRoughness = min( material.clearcoatRoughness, 1.0 );
#endif
#ifdef USE_SHEEN
	material.sheenColor = sheenColor;
	#ifdef USE_SHEENCOLORMAP
		material.sheenColor *= sheenColorMapTexelToLinear( texture2D( sheenColorMap, vUv ) ).rgb;
	#endif
	material.sheenRoughness = clamp( sheenRoughness, 0.07, 1.0 );
	#ifdef USE_SHEENROUGHNESSMAP
		material.sheenRoughness *= texture2D( sheenRoughnessMap, vUv ).a;
	#endif
#endif`,Nv=`struct PhysicalMaterial {
	vec3 diffuseColor;
	float roughness;
	vec3 specularColor;
	float specularF90;
	#ifdef USE_CLEARCOAT
		float clearcoat;
		float clearcoatRoughness;
		vec3 clearcoatF0;
		float clearcoatF90;
	#endif
	#ifdef USE_SHEEN
		vec3 sheenColor;
		float sheenRoughness;
	#endif
};
vec3 clearcoatSpecular = vec3( 0.0 );
vec3 sheenSpecular = vec3( 0.0 );
float IBLSheenBRDF( const in vec3 normal, const in vec3 viewDir, const in float roughness) {
	float dotNV = saturate( dot( normal, viewDir ) );
	float r2 = roughness * roughness;
	float a = roughness < 0.25 ? -339.2 * r2 + 161.4 * roughness - 25.9 : -8.48 * r2 + 14.3 * roughness - 9.95;
	float b = roughness < 0.25 ? 44.0 * r2 - 23.7 * roughness + 3.26 : 1.97 * r2 - 3.27 * roughness + 0.72;
	float DG = exp( a * dotNV + b ) + ( roughness < 0.25 ? 0.0 : 0.1 * ( roughness - 0.25 ) );
	return saturate( DG * RECIPROCAL_PI );
}
vec2 DFGApprox( const in vec3 normal, const in vec3 viewDir, const in float roughness ) {
	float dotNV = saturate( dot( normal, viewDir ) );
	const vec4 c0 = vec4( - 1, - 0.0275, - 0.572, 0.022 );
	const vec4 c1 = vec4( 1, 0.0425, 1.04, - 0.04 );
	vec4 r = roughness * c0 + c1;
	float a004 = min( r.x * r.x, exp2( - 9.28 * dotNV ) ) * r.x + r.y;
	vec2 fab = vec2( - 1.04, 1.04 ) * a004 + r.zw;
	return fab;
}
vec3 EnvironmentBRDF( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness ) {
	vec2 fab = DFGApprox( normal, viewDir, roughness );
	return specularColor * fab.x + specularF90 * fab.y;
}
void computeMultiscattering( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {
	vec2 fab = DFGApprox( normal, viewDir, roughness );
	vec3 FssEss = specularColor * fab.x + specularF90 * fab.y;
	float Ess = fab.x + fab.y;
	float Ems = 1.0 - Ess;
	vec3 Favg = specularColor + ( 1.0 - specularColor ) * 0.047619;	vec3 Fms = FssEss * Favg / ( 1.0 - Ems * Favg );
	singleScatter += FssEss;
	multiScatter += Fms * Ems;
}
#if NUM_RECT_AREA_LIGHTS > 0
	void RE_Direct_RectArea_Physical( const in RectAreaLight rectAreaLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {
		vec3 normal = geometry.normal;
		vec3 viewDir = geometry.viewDir;
		vec3 position = geometry.position;
		vec3 lightPos = rectAreaLight.position;
		vec3 halfWidth = rectAreaLight.halfWidth;
		vec3 halfHeight = rectAreaLight.halfHeight;
		vec3 lightColor = rectAreaLight.color;
		float roughness = material.roughness;
		vec3 rectCoords[ 4 ];
		rectCoords[ 0 ] = lightPos + halfWidth - halfHeight;		rectCoords[ 1 ] = lightPos - halfWidth - halfHeight;
		rectCoords[ 2 ] = lightPos - halfWidth + halfHeight;
		rectCoords[ 3 ] = lightPos + halfWidth + halfHeight;
		vec2 uv = LTC_Uv( normal, viewDir, roughness );
		vec4 t1 = texture2D( ltc_1, uv );
		vec4 t2 = texture2D( ltc_2, uv );
		mat3 mInv = mat3(
			vec3( t1.x, 0, t1.y ),
			vec3(    0, 1,    0 ),
			vec3( t1.z, 0, t1.w )
		);
		vec3 fresnel = ( material.specularColor * t2.x + ( vec3( 1.0 ) - material.specularColor ) * t2.y );
		reflectedLight.directSpecular += lightColor * fresnel * LTC_Evaluate( normal, viewDir, position, mInv, rectCoords );
		reflectedLight.directDiffuse += lightColor * material.diffuseColor * LTC_Evaluate( normal, viewDir, position, mat3( 1.0 ), rectCoords );
	}
#endif
void RE_Direct_Physical( const in IncidentLight directLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {
	float dotNL = saturate( dot( geometry.normal, directLight.direction ) );
	vec3 irradiance = dotNL * directLight.color;
	#ifdef USE_CLEARCOAT
		float dotNLcc = saturate( dot( geometry.clearcoatNormal, directLight.direction ) );
		vec3 ccIrradiance = dotNLcc * directLight.color;
		clearcoatSpecular += ccIrradiance * BRDF_GGX( directLight.direction, geometry.viewDir, geometry.clearcoatNormal, material.clearcoatF0, material.clearcoatF90, material.clearcoatRoughness );
	#endif
	#ifdef USE_SHEEN
		sheenSpecular += irradiance * BRDF_Sheen( directLight.direction, geometry.viewDir, geometry.normal, material.sheenColor, material.sheenRoughness );
	#endif
	reflectedLight.directSpecular += irradiance * BRDF_GGX( directLight.direction, geometry.viewDir, geometry.normal, material.specularColor, material.specularF90, material.roughness );
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectDiffuse_Physical( const in vec3 irradiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectSpecular_Physical( const in vec3 radiance, const in vec3 irradiance, const in vec3 clearcoatRadiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight) {
	#ifdef USE_CLEARCOAT
		clearcoatSpecular += clearcoatRadiance * EnvironmentBRDF( geometry.clearcoatNormal, geometry.viewDir, material.clearcoatF0, material.clearcoatF90, material.clearcoatRoughness );
	#endif
	#ifdef USE_SHEEN
		sheenSpecular += irradiance * material.sheenColor * IBLSheenBRDF( geometry.normal, geometry.viewDir, material.sheenRoughness );
	#endif
	vec3 singleScattering = vec3( 0.0 );
	vec3 multiScattering = vec3( 0.0 );
	vec3 cosineWeightedIrradiance = irradiance * RECIPROCAL_PI;
	computeMultiscattering( geometry.normal, geometry.viewDir, material.specularColor, material.specularF90, material.roughness, singleScattering, multiScattering );
	vec3 diffuse = material.diffuseColor * ( 1.0 - ( singleScattering + multiScattering ) );
	reflectedLight.indirectSpecular += radiance * singleScattering;
	reflectedLight.indirectSpecular += multiScattering * cosineWeightedIrradiance;
	reflectedLight.indirectDiffuse += diffuse * cosineWeightedIrradiance;
}
#define RE_Direct				RE_Direct_Physical
#define RE_Direct_RectArea		RE_Direct_RectArea_Physical
#define RE_IndirectDiffuse		RE_IndirectDiffuse_Physical
#define RE_IndirectSpecular		RE_IndirectSpecular_Physical
float computeSpecularOcclusion( const in float dotNV, const in float ambientOcclusion, const in float roughness ) {
	return saturate( pow( dotNV + ambientOcclusion, exp2( - 16.0 * roughness - 1.0 ) ) - 1.0 + ambientOcclusion );
}`,Fv=`
GeometricContext geometry;
geometry.position = - vViewPosition;
geometry.normal = normal;
geometry.viewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( vViewPosition );
#ifdef USE_CLEARCOAT
	geometry.clearcoatNormal = clearcoatNormal;
#endif
IncidentLight directLight;
#if ( NUM_POINT_LIGHTS > 0 ) && defined( RE_Direct )
	PointLight pointLight;
	#if defined( USE_SHADOWMAP ) && NUM_POINT_LIGHT_SHADOWS > 0
	PointLightShadow pointLightShadow;
	#endif
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {
		pointLight = pointLights[ i ];
		getPointLightInfo( pointLight, geometry, directLight );
		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_POINT_LIGHT_SHADOWS )
		pointLightShadow = pointLightShadows[ i ];
		directLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getPointShadow( pointShadowMap[ i ], pointLightShadow.shadowMapSize, pointLightShadow.shadowBias, pointLightShadow.shadowRadius, vPointShadowCoord[ i ], pointLightShadow.shadowCameraNear, pointLightShadow.shadowCameraFar ) : 1.0;
		#endif
		RE_Direct( directLight, geometry, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if ( NUM_SPOT_LIGHTS > 0 ) && defined( RE_Direct )
	SpotLight spotLight;
	#if defined( USE_SHADOWMAP ) && NUM_SPOT_LIGHT_SHADOWS > 0
	SpotLightShadow spotLightShadow;
	#endif
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {
		spotLight = spotLights[ i ];
		getSpotLightInfo( spotLight, geometry, directLight );
		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )
		spotLightShadow = spotLightShadows[ i ];
		directLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getShadow( spotShadowMap[ i ], spotLightShadow.shadowMapSize, spotLightShadow.shadowBias, spotLightShadow.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;
		#endif
		RE_Direct( directLight, geometry, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct )
	DirectionalLight directionalLight;
	#if defined( USE_SHADOWMAP ) && NUM_DIR_LIGHT_SHADOWS > 0
	DirectionalLightShadow directionalLightShadow;
	#endif
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {
		directionalLight = directionalLights[ i ];
		getDirectionalLightInfo( directionalLight, geometry, directLight );
		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_DIR_LIGHT_SHADOWS )
		directionalLightShadow = directionalLightShadows[ i ];
		directLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getShadow( directionalShadowMap[ i ], directionalLightShadow.shadowMapSize, directionalLightShadow.shadowBias, directionalLightShadow.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;
		#endif
		RE_Direct( directLight, geometry, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if ( NUM_RECT_AREA_LIGHTS > 0 ) && defined( RE_Direct_RectArea )
	RectAreaLight rectAreaLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_RECT_AREA_LIGHTS; i ++ ) {
		rectAreaLight = rectAreaLights[ i ];
		RE_Direct_RectArea( rectAreaLight, geometry, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if defined( RE_IndirectDiffuse )
	vec3 iblIrradiance = vec3( 0.0 );
	vec3 irradiance = getAmbientLightIrradiance( ambientLightColor );
	irradiance += getLightProbeIrradiance( lightProbe, geometry.normal );
	#if ( NUM_HEMI_LIGHTS > 0 )
		#pragma unroll_loop_start
		for ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {
			irradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry.normal );
		}
		#pragma unroll_loop_end
	#endif
#endif
#if defined( RE_IndirectSpecular )
	vec3 radiance = vec3( 0.0 );
	vec3 clearcoatRadiance = vec3( 0.0 );
#endif`,kv=`#if defined( RE_IndirectDiffuse )
	#ifdef USE_LIGHTMAP
		vec4 lightMapTexel = texture2D( lightMap, vUv2 );
		vec3 lightMapIrradiance = lightMapTexelToLinear( lightMapTexel ).rgb * lightMapIntensity;
		#ifndef PHYSICALLY_CORRECT_LIGHTS
			lightMapIrradiance *= PI;
		#endif
		irradiance += lightMapIrradiance;
	#endif
	#if defined( USE_ENVMAP ) && defined( STANDARD ) && defined( ENVMAP_TYPE_CUBE_UV )
		iblIrradiance += getIBLIrradiance( geometry.normal );
	#endif
#endif
#if defined( USE_ENVMAP ) && defined( RE_IndirectSpecular )
	radiance += getIBLRadiance( geometry.viewDir, geometry.normal, material.roughness );
	#ifdef USE_CLEARCOAT
		clearcoatRadiance += getIBLRadiance( geometry.viewDir, geometry.clearcoatNormal, material.clearcoatRoughness );
	#endif
#endif`,Vv=`#if defined( RE_IndirectDiffuse )
	RE_IndirectDiffuse( irradiance, geometry, material, reflectedLight );
#endif
#if defined( RE_IndirectSpecular )
	RE_IndirectSpecular( radiance, iblIrradiance, clearcoatRadiance, geometry, material, reflectedLight );
#endif`,Bv=`#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )
	gl_FragDepthEXT = vIsPerspective == 0.0 ? gl_FragCoord.z : log2( vFragDepth ) * logDepthBufFC * 0.5;
#endif`,zv=`#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )
	uniform float logDepthBufFC;
	varying float vFragDepth;
	varying float vIsPerspective;
#endif`,Ov=`#ifdef USE_LOGDEPTHBUF
	#ifdef USE_LOGDEPTHBUF_EXT
		varying float vFragDepth;
		varying float vIsPerspective;
	#else
		uniform float logDepthBufFC;
	#endif
#endif`,Uv=`#ifdef USE_LOGDEPTHBUF
	#ifdef USE_LOGDEPTHBUF_EXT
		vFragDepth = 1.0 + gl_Position.w;
		vIsPerspective = float( isPerspectiveMatrix( projectionMatrix ) );
	#else
		if ( isPerspectiveMatrix( projectionMatrix ) ) {
			gl_Position.z = log2( max( EPSILON, gl_Position.w + 1.0 ) ) * logDepthBufFC - 1.0;
			gl_Position.z *= gl_Position.w;
		}
	#endif
#endif`,Hv=`#ifdef USE_MAP
	vec4 texelColor = texture2D( map, vUv );
	texelColor = mapTexelToLinear( texelColor );
	diffuseColor *= texelColor;
#endif`,Gv=`#ifdef USE_MAP
	uniform sampler2D map;
#endif`,Wv=`#if defined( USE_MAP ) || defined( USE_ALPHAMAP )
	vec2 uv = ( uvTransform * vec3( gl_PointCoord.x, 1.0 - gl_PointCoord.y, 1 ) ).xy;
#endif
#ifdef USE_MAP
	vec4 mapTexel = texture2D( map, uv );
	diffuseColor *= mapTexelToLinear( mapTexel );
#endif
#ifdef USE_ALPHAMAP
	diffuseColor.a *= texture2D( alphaMap, uv ).g;
#endif`,qv=`#if defined( USE_MAP ) || defined( USE_ALPHAMAP )
	uniform mat3 uvTransform;
#endif
#ifdef USE_MAP
	uniform sampler2D map;
#endif
#ifdef USE_ALPHAMAP
	uniform sampler2D alphaMap;
#endif`,jv=`float metalnessFactor = metalness;
#ifdef USE_METALNESSMAP
	vec4 texelMetalness = texture2D( metalnessMap, vUv );
	metalnessFactor *= texelMetalness.b;
#endif`,Xv=`#ifdef USE_METALNESSMAP
	uniform sampler2D metalnessMap;
#endif`,$v=`#ifdef USE_MORPHNORMALS
	objectNormal *= morphTargetBaseInfluence;
	#ifdef MORPHTARGETS_TEXTURE
		for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {
			if ( morphTargetInfluences[ i ] > 0.0 ) objectNormal += getMorph( gl_VertexID, i, 1, 2 ) * morphTargetInfluences[ i ];
		}
	#else
		objectNormal += morphNormal0 * morphTargetInfluences[ 0 ];
		objectNormal += morphNormal1 * morphTargetInfluences[ 1 ];
		objectNormal += morphNormal2 * morphTargetInfluences[ 2 ];
		objectNormal += morphNormal3 * morphTargetInfluences[ 3 ];
	#endif
#endif`,Yv=`#ifdef USE_MORPHTARGETS
	uniform float morphTargetBaseInfluence;
	#ifdef MORPHTARGETS_TEXTURE
		uniform float morphTargetInfluences[ MORPHTARGETS_COUNT ];
		uniform sampler2DArray morphTargetsTexture;
		uniform vec2 morphTargetsTextureSize;
		vec3 getMorph( const in int vertexIndex, const in int morphTargetIndex, const in int offset, const in int stride ) {
			float texelIndex = float( vertexIndex * stride + offset );
			float y = floor( texelIndex / morphTargetsTextureSize.x );
			float x = texelIndex - y * morphTargetsTextureSize.x;
			vec3 morphUV = vec3( ( x + 0.5 ) / morphTargetsTextureSize.x, y / morphTargetsTextureSize.y, morphTargetIndex );
			return texture( morphTargetsTexture, morphUV ).xyz;
		}
	#else
		#ifndef USE_MORPHNORMALS
			uniform float morphTargetInfluences[ 8 ];
		#else
			uniform float morphTargetInfluences[ 4 ];
		#endif
	#endif
#endif`,Jv=`#ifdef USE_MORPHTARGETS
	transformed *= morphTargetBaseInfluence;
	#ifdef MORPHTARGETS_TEXTURE
		for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {
			#ifndef USE_MORPHNORMALS
				if ( morphTargetInfluences[ i ] > 0.0 ) transformed += getMorph( gl_VertexID, i, 0, 1 ) * morphTargetInfluences[ i ];
			#else
				if ( morphTargetInfluences[ i ] > 0.0 ) transformed += getMorph( gl_VertexID, i, 0, 2 ) * morphTargetInfluences[ i ];
			#endif
		}
	#else
		transformed += morphTarget0 * morphTargetInfluences[ 0 ];
		transformed += morphTarget1 * morphTargetInfluences[ 1 ];
		transformed += morphTarget2 * morphTargetInfluences[ 2 ];
		transformed += morphTarget3 * morphTargetInfluences[ 3 ];
		#ifndef USE_MORPHNORMALS
			transformed += morphTarget4 * morphTargetInfluences[ 4 ];
			transformed += morphTarget5 * morphTargetInfluences[ 5 ];
			transformed += morphTarget6 * morphTargetInfluences[ 6 ];
			transformed += morphTarget7 * morphTargetInfluences[ 7 ];
		#endif
	#endif
#endif`,Zv=`float faceDirection = gl_FrontFacing ? 1.0 : - 1.0;
#ifdef FLAT_SHADED
	vec3 fdx = vec3( dFdx( vViewPosition.x ), dFdx( vViewPosition.y ), dFdx( vViewPosition.z ) );
	vec3 fdy = vec3( dFdy( vViewPosition.x ), dFdy( vViewPosition.y ), dFdy( vViewPosition.z ) );
	vec3 normal = normalize( cross( fdx, fdy ) );
#else
	vec3 normal = normalize( vNormal );
	#ifdef DOUBLE_SIDED
		normal = normal * faceDirection;
	#endif
	#ifdef USE_TANGENT
		vec3 tangent = normalize( vTangent );
		vec3 bitangent = normalize( vBitangent );
		#ifdef DOUBLE_SIDED
			tangent = tangent * faceDirection;
			bitangent = bitangent * faceDirection;
		#endif
		#if defined( TANGENTSPACE_NORMALMAP ) || defined( USE_CLEARCOAT_NORMALMAP )
			mat3 vTBN = mat3( tangent, bitangent, normal );
		#endif
	#endif
#endif
vec3 geometryNormal = normal;`,Kv=`#ifdef OBJECTSPACE_NORMALMAP
	normal = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;
	#ifdef FLIP_SIDED
		normal = - normal;
	#endif
	#ifdef DOUBLE_SIDED
		normal = normal * faceDirection;
	#endif
	normal = normalize( normalMatrix * normal );
#elif defined( TANGENTSPACE_NORMALMAP )
	vec3 mapN = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;
	mapN.xy *= normalScale;
	#ifdef USE_TANGENT
		normal = normalize( vTBN * mapN );
	#else
		normal = perturbNormal2Arb( - vViewPosition, normal, mapN, faceDirection );
	#endif
#elif defined( USE_BUMPMAP )
	normal = perturbNormalArb( - vViewPosition, normal, dHdxy_fwd(), faceDirection );
#endif`,Qv=`#ifndef FLAT_SHADED
	varying vec3 vNormal;
	#ifdef USE_TANGENT
		varying vec3 vTangent;
		varying vec3 vBitangent;
	#endif
#endif`,t_=`#ifndef FLAT_SHADED
	varying vec3 vNormal;
	#ifdef USE_TANGENT
		varying vec3 vTangent;
		varying vec3 vBitangent;
	#endif
#endif`,e_=`#ifndef FLAT_SHADED
	vNormal = normalize( transformedNormal );
	#ifdef USE_TANGENT
		vTangent = normalize( transformedTangent );
		vBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );
	#endif
#endif`,n_=`#ifdef USE_NORMALMAP
	uniform sampler2D normalMap;
	uniform vec2 normalScale;
#endif
#ifdef OBJECTSPACE_NORMALMAP
	uniform mat3 normalMatrix;
#endif
#if ! defined ( USE_TANGENT ) && ( defined ( TANGENTSPACE_NORMALMAP ) || defined ( USE_CLEARCOAT_NORMALMAP ) )
	vec3 perturbNormal2Arb( vec3 eye_pos, vec3 surf_norm, vec3 mapN, float faceDirection ) {
		vec3 q0 = vec3( dFdx( eye_pos.x ), dFdx( eye_pos.y ), dFdx( eye_pos.z ) );
		vec3 q1 = vec3( dFdy( eye_pos.x ), dFdy( eye_pos.y ), dFdy( eye_pos.z ) );
		vec2 st0 = dFdx( vUv.st );
		vec2 st1 = dFdy( vUv.st );
		vec3 N = surf_norm;
		vec3 q1perp = cross( q1, N );
		vec3 q0perp = cross( N, q0 );
		vec3 T = q1perp * st0.x + q0perp * st1.x;
		vec3 B = q1perp * st0.y + q0perp * st1.y;
		float det = max( dot( T, T ), dot( B, B ) );
		float scale = ( det == 0.0 ) ? 0.0 : faceDirection * inversesqrt( det );
		return normalize( T * ( mapN.x * scale ) + B * ( mapN.y * scale ) + N * mapN.z );
	}
#endif`,i_=`#ifdef USE_CLEARCOAT
	vec3 clearcoatNormal = geometryNormal;
#endif`,r_=`#ifdef USE_CLEARCOAT_NORMALMAP
	vec3 clearcoatMapN = texture2D( clearcoatNormalMap, vUv ).xyz * 2.0 - 1.0;
	clearcoatMapN.xy *= clearcoatNormalScale;
	#ifdef USE_TANGENT
		clearcoatNormal = normalize( vTBN * clearcoatMapN );
	#else
		clearcoatNormal = perturbNormal2Arb( - vViewPosition, clearcoatNormal, clearcoatMapN, faceDirection );
	#endif
#endif`,s_=`#ifdef USE_CLEARCOATMAP
	uniform sampler2D clearcoatMap;
#endif
#ifdef USE_CLEARCOAT_ROUGHNESSMAP
	uniform sampler2D clearcoatRoughnessMap;
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	uniform sampler2D clearcoatNormalMap;
	uniform vec2 clearcoatNormalScale;
#endif`,o_=`#ifdef OPAQUE
diffuseColor.a = 1.0;
#endif
#ifdef USE_TRANSMISSION
diffuseColor.a *= transmissionAlpha + 0.1;
#endif
gl_FragColor = vec4( outgoingLight, diffuseColor.a );`,a_=`vec3 packNormalToRGB( const in vec3 normal ) {
	return normalize( normal ) * 0.5 + 0.5;
}
vec3 unpackRGBToNormal( const in vec3 rgb ) {
	return 2.0 * rgb.xyz - 1.0;
}
const float PackUpscale = 256. / 255.;const float UnpackDownscale = 255. / 256.;
const vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256., 256. );
const vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );
const float ShiftRight8 = 1. / 256.;
vec4 packDepthToRGBA( const in float v ) {
	vec4 r = vec4( fract( v * PackFactors ), v );
	r.yzw -= r.xyz * ShiftRight8;	return r * PackUpscale;
}
float unpackRGBAToDepth( const in vec4 v ) {
	return dot( v, UnpackFactors );
}
vec4 pack2HalfToRGBA( vec2 v ) {
	vec4 r = vec4( v.x, fract( v.x * 255.0 ), v.y, fract( v.y * 255.0 ) );
	return vec4( r.x - r.y / 255.0, r.y, r.z - r.w / 255.0, r.w );
}
vec2 unpackRGBATo2Half( vec4 v ) {
	return vec2( v.x + ( v.y / 255.0 ), v.z + ( v.w / 255.0 ) );
}
float viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {
	return ( viewZ + near ) / ( near - far );
}
float orthographicDepthToViewZ( const in float linearClipZ, const in float near, const in float far ) {
	return linearClipZ * ( near - far ) - near;
}
float viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {
	return ( ( near + viewZ ) * far ) / ( ( far - near ) * viewZ );
}
float perspectiveDepthToViewZ( const in float invClipZ, const in float near, const in float far ) {
	return ( near * far ) / ( ( far - near ) * invClipZ - far );
}`,l_=`#ifdef PREMULTIPLIED_ALPHA
	gl_FragColor.rgb *= gl_FragColor.a;
#endif`,c_=`vec4 mvPosition = vec4( transformed, 1.0 );
#ifdef USE_INSTANCING
	mvPosition = instanceMatrix * mvPosition;
#endif
mvPosition = modelViewMatrix * mvPosition;
gl_Position = projectionMatrix * mvPosition;`,h_=`#ifdef DITHERING
	gl_FragColor.rgb = dithering( gl_FragColor.rgb );
#endif`,u_=`#ifdef DITHERING
	vec3 dithering( vec3 color ) {
		float grid_position = rand( gl_FragCoord.xy );
		vec3 dither_shift_RGB = vec3( 0.25 / 255.0, -0.25 / 255.0, 0.25 / 255.0 );
		dither_shift_RGB = mix( 2.0 * dither_shift_RGB, -2.0 * dither_shift_RGB, grid_position );
		return color + dither_shift_RGB;
	}
#endif`,d_=`float roughnessFactor = roughness;
#ifdef USE_ROUGHNESSMAP
	vec4 texelRoughness = texture2D( roughnessMap, vUv );
	roughnessFactor *= texelRoughness.g;
#endif`,p_=`#ifdef USE_ROUGHNESSMAP
	uniform sampler2D roughnessMap;
#endif`,f_=`#ifdef USE_SHADOWMAP
	#if NUM_DIR_LIGHT_SHADOWS > 0
		uniform sampler2D directionalShadowMap[ NUM_DIR_LIGHT_SHADOWS ];
		varying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];
		struct DirectionalLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];
	#endif
	#if NUM_SPOT_LIGHT_SHADOWS > 0
		uniform sampler2D spotShadowMap[ NUM_SPOT_LIGHT_SHADOWS ];
		varying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHT_SHADOWS ];
		struct SpotLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
		uniform sampler2D pointShadowMap[ NUM_POINT_LIGHT_SHADOWS ];
		varying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];
		struct PointLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
			float shadowCameraNear;
			float shadowCameraFar;
		};
		uniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];
	#endif
	float texture2DCompare( sampler2D depths, vec2 uv, float compare ) {
		return step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );
	}
	vec2 texture2DDistribution( sampler2D shadow, vec2 uv ) {
		return unpackRGBATo2Half( texture2D( shadow, uv ) );
	}
	float VSMShadow (sampler2D shadow, vec2 uv, float compare ){
		float occlusion = 1.0;
		vec2 distribution = texture2DDistribution( shadow, uv );
		float hard_shadow = step( compare , distribution.x );
		if (hard_shadow != 1.0 ) {
			float distance = compare - distribution.x ;
			float variance = max( 0.00000, distribution.y * distribution.y );
			float softness_probability = variance / (variance + distance * distance );			softness_probability = clamp( ( softness_probability - 0.3 ) / ( 0.95 - 0.3 ), 0.0, 1.0 );			occlusion = clamp( max( hard_shadow, softness_probability ), 0.0, 1.0 );
		}
		return occlusion;
	}
	float getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {
		float shadow = 1.0;
		shadowCoord.xyz /= shadowCoord.w;
		shadowCoord.z += shadowBias;
		bvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );
		bool inFrustum = all( inFrustumVec );
		bvec2 frustumTestVec = bvec2( inFrustum, shadowCoord.z <= 1.0 );
		bool frustumTest = all( frustumTestVec );
		if ( frustumTest ) {
		#if defined( SHADOWMAP_TYPE_PCF )
			vec2 texelSize = vec2( 1.0 ) / shadowMapSize;
			float dx0 = - texelSize.x * shadowRadius;
			float dy0 = - texelSize.y * shadowRadius;
			float dx1 = + texelSize.x * shadowRadius;
			float dy1 = + texelSize.y * shadowRadius;
			float dx2 = dx0 / 2.0;
			float dy2 = dy0 / 2.0;
			float dx3 = dx1 / 2.0;
			float dy3 = dy1 / 2.0;
			shadow = (
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy2 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy2 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy2 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy3 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy3 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy3 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )
			) * ( 1.0 / 17.0 );
		#elif defined( SHADOWMAP_TYPE_PCF_SOFT )
			vec2 texelSize = vec2( 1.0 ) / shadowMapSize;
			float dx = texelSize.x;
			float dy = texelSize.y;
			vec2 uv = shadowCoord.xy;
			vec2 f = fract( uv * shadowMapSize + 0.5 );
			uv -= f * texelSize;
			shadow = (
				texture2DCompare( shadowMap, uv, shadowCoord.z ) +
				texture2DCompare( shadowMap, uv + vec2( dx, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, uv + vec2( 0.0, dy ), shadowCoord.z ) +
				texture2DCompare( shadowMap, uv + texelSize, shadowCoord.z ) +
				mix( texture2DCompare( shadowMap, uv + vec2( -dx, 0.0 ), shadowCoord.z ), 
					 texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 0.0 ), shadowCoord.z ),
					 f.x ) +
				mix( texture2DCompare( shadowMap, uv + vec2( -dx, dy ), shadowCoord.z ), 
					 texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, dy ), shadowCoord.z ),
					 f.x ) +
				mix( texture2DCompare( shadowMap, uv + vec2( 0.0, -dy ), shadowCoord.z ), 
					 texture2DCompare( shadowMap, uv + vec2( 0.0, 2.0 * dy ), shadowCoord.z ),
					 f.y ) +
				mix( texture2DCompare( shadowMap, uv + vec2( dx, -dy ), shadowCoord.z ), 
					 texture2DCompare( shadowMap, uv + vec2( dx, 2.0 * dy ), shadowCoord.z ),
					 f.y ) +
				mix( mix( texture2DCompare( shadowMap, uv + vec2( -dx, -dy ), shadowCoord.z ), 
						  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, -dy ), shadowCoord.z ),
						  f.x ),
					 mix( texture2DCompare( shadowMap, uv + vec2( -dx, 2.0 * dy ), shadowCoord.z ), 
						  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 2.0 * dy ), shadowCoord.z ),
						  f.x ),
					 f.y )
			) * ( 1.0 / 9.0 );
		#elif defined( SHADOWMAP_TYPE_VSM )
			shadow = VSMShadow( shadowMap, shadowCoord.xy, shadowCoord.z );
		#else
			shadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );
		#endif
		}
		return shadow;
	}
	vec2 cubeToUV( vec3 v, float texelSizeY ) {
		vec3 absV = abs( v );
		float scaleToCube = 1.0 / max( absV.x, max( absV.y, absV.z ) );
		absV *= scaleToCube;
		v *= scaleToCube * ( 1.0 - 2.0 * texelSizeY );
		vec2 planar = v.xy;
		float almostATexel = 1.5 * texelSizeY;
		float almostOne = 1.0 - almostATexel;
		if ( absV.z >= almostOne ) {
			if ( v.z > 0.0 )
				planar.x = 4.0 - v.x;
		} else if ( absV.x >= almostOne ) {
			float signX = sign( v.x );
			planar.x = v.z * signX + 2.0 * signX;
		} else if ( absV.y >= almostOne ) {
			float signY = sign( v.y );
			planar.x = v.x + 2.0 * signY + 2.0;
			planar.y = v.z * signY - 2.0;
		}
		return vec2( 0.125, 0.25 ) * planar + vec2( 0.375, 0.75 );
	}
	float getPointShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord, float shadowCameraNear, float shadowCameraFar ) {
		vec2 texelSize = vec2( 1.0 ) / ( shadowMapSize * vec2( 4.0, 2.0 ) );
		vec3 lightToPosition = shadowCoord.xyz;
		float dp = ( length( lightToPosition ) - shadowCameraNear ) / ( shadowCameraFar - shadowCameraNear );		dp += shadowBias;
		vec3 bd3D = normalize( lightToPosition );
		#if defined( SHADOWMAP_TYPE_PCF ) || defined( SHADOWMAP_TYPE_PCF_SOFT ) || defined( SHADOWMAP_TYPE_VSM )
			vec2 offset = vec2( - 1, 1 ) * shadowRadius * texelSize.y;
			return (
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyy, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyy, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyx, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyx, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxy, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxy, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxx, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxx, texelSize.y ), dp )
			) * ( 1.0 / 9.0 );
		#else
			return texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp );
		#endif
	}
#endif`,m_=`#ifdef USE_SHADOWMAP
	#if NUM_DIR_LIGHT_SHADOWS > 0
		uniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHT_SHADOWS ];
		varying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];
		struct DirectionalLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];
	#endif
	#if NUM_SPOT_LIGHT_SHADOWS > 0
		uniform mat4 spotShadowMatrix[ NUM_SPOT_LIGHT_SHADOWS ];
		varying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHT_SHADOWS ];
		struct SpotLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
		uniform mat4 pointShadowMatrix[ NUM_POINT_LIGHT_SHADOWS ];
		varying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];
		struct PointLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
			float shadowCameraNear;
			float shadowCameraFar;
		};
		uniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];
	#endif
#endif`,g_=`#ifdef USE_SHADOWMAP
	#if NUM_DIR_LIGHT_SHADOWS > 0 || NUM_SPOT_LIGHT_SHADOWS > 0 || NUM_POINT_LIGHT_SHADOWS > 0
		vec3 shadowWorldNormal = inverseTransformDirection( transformedNormal, viewMatrix );
		vec4 shadowWorldPosition;
	#endif
	#if NUM_DIR_LIGHT_SHADOWS > 0
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {
		shadowWorldPosition = worldPosition + vec4( shadowWorldNormal * directionalLightShadows[ i ].shadowNormalBias, 0 );
		vDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * shadowWorldPosition;
	}
	#pragma unroll_loop_end
	#endif
	#if NUM_SPOT_LIGHT_SHADOWS > 0
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {
		shadowWorldPosition = worldPosition + vec4( shadowWorldNormal * spotLightShadows[ i ].shadowNormalBias, 0 );
		vSpotShadowCoord[ i ] = spotShadowMatrix[ i ] * shadowWorldPosition;
	}
	#pragma unroll_loop_end
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {
		shadowWorldPosition = worldPosition + vec4( shadowWorldNormal * pointLightShadows[ i ].shadowNormalBias, 0 );
		vPointShadowCoord[ i ] = pointShadowMatrix[ i ] * shadowWorldPosition;
	}
	#pragma unroll_loop_end
	#endif
#endif`,v_=`float getShadowMask() {
	float shadow = 1.0;
	#ifdef USE_SHADOWMAP
	#if NUM_DIR_LIGHT_SHADOWS > 0
	DirectionalLightShadow directionalLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {
		directionalLight = directionalLightShadows[ i ];
		shadow *= receiveShadow ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;
	}
	#pragma unroll_loop_end
	#endif
	#if NUM_SPOT_LIGHT_SHADOWS > 0
	SpotLightShadow spotLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {
		spotLight = spotLightShadows[ i ];
		shadow *= receiveShadow ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;
	}
	#pragma unroll_loop_end
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
	PointLightShadow pointLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {
		pointLight = pointLightShadows[ i ];
		shadow *= receiveShadow ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ], pointLight.shadowCameraNear, pointLight.shadowCameraFar ) : 1.0;
	}
	#pragma unroll_loop_end
	#endif
	#endif
	return shadow;
}`,__=`#ifdef USE_SKINNING
	mat4 boneMatX = getBoneMatrix( skinIndex.x );
	mat4 boneMatY = getBoneMatrix( skinIndex.y );
	mat4 boneMatZ = getBoneMatrix( skinIndex.z );
	mat4 boneMatW = getBoneMatrix( skinIndex.w );
#endif`,x_=`#ifdef USE_SKINNING
	uniform mat4 bindMatrix;
	uniform mat4 bindMatrixInverse;
	#ifdef BONE_TEXTURE
		uniform highp sampler2D boneTexture;
		uniform int boneTextureSize;
		mat4 getBoneMatrix( const in float i ) {
			float j = i * 4.0;
			float x = mod( j, float( boneTextureSize ) );
			float y = floor( j / float( boneTextureSize ) );
			float dx = 1.0 / float( boneTextureSize );
			float dy = 1.0 / float( boneTextureSize );
			y = dy * ( y + 0.5 );
			vec4 v1 = texture2D( boneTexture, vec2( dx * ( x + 0.5 ), y ) );
			vec4 v2 = texture2D( boneTexture, vec2( dx * ( x + 1.5 ), y ) );
			vec4 v3 = texture2D( boneTexture, vec2( dx * ( x + 2.5 ), y ) );
			vec4 v4 = texture2D( boneTexture, vec2( dx * ( x + 3.5 ), y ) );
			mat4 bone = mat4( v1, v2, v3, v4 );
			return bone;
		}
	#else
		uniform mat4 boneMatrices[ MAX_BONES ];
		mat4 getBoneMatrix( const in float i ) {
			mat4 bone = boneMatrices[ int(i) ];
			return bone;
		}
	#endif
#endif`,b_=`#ifdef USE_SKINNING
	vec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );
	vec4 skinned = vec4( 0.0 );
	skinned += boneMatX * skinVertex * skinWeight.x;
	skinned += boneMatY * skinVertex * skinWeight.y;
	skinned += boneMatZ * skinVertex * skinWeight.z;
	skinned += boneMatW * skinVertex * skinWeight.w;
	transformed = ( bindMatrixInverse * skinned ).xyz;
#endif`,y_=`#ifdef USE_SKINNING
	mat4 skinMatrix = mat4( 0.0 );
	skinMatrix += skinWeight.x * boneMatX;
	skinMatrix += skinWeight.y * boneMatY;
	skinMatrix += skinWeight.z * boneMatZ;
	skinMatrix += skinWeight.w * boneMatW;
	skinMatrix = bindMatrixInverse * skinMatrix * bindMatrix;
	objectNormal = vec4( skinMatrix * vec4( objectNormal, 0.0 ) ).xyz;
	#ifdef USE_TANGENT
		objectTangent = vec4( skinMatrix * vec4( objectTangent, 0.0 ) ).xyz;
	#endif
#endif`,w_=`float specularStrength;
#ifdef USE_SPECULARMAP
	vec4 texelSpecular = texture2D( specularMap, vUv );
	specularStrength = texelSpecular.r;
#else
	specularStrength = 1.0;
#endif`,M_=`#ifdef USE_SPECULARMAP
	uniform sampler2D specularMap;
#endif`,S_=`#if defined( TONE_MAPPING )
	gl_FragColor.rgb = toneMapping( gl_FragColor.rgb );
#endif`,E_=`#ifndef saturate
#define saturate( a ) clamp( a, 0.0, 1.0 )
#endif
uniform float toneMappingExposure;
vec3 LinearToneMapping( vec3 color ) {
	return toneMappingExposure * color;
}
vec3 ReinhardToneMapping( vec3 color ) {
	color *= toneMappingExposure;
	return saturate( color / ( vec3( 1.0 ) + color ) );
}
vec3 OptimizedCineonToneMapping( vec3 color ) {
	color *= toneMappingExposure;
	color = max( vec3( 0.0 ), color - 0.004 );
	return pow( ( color * ( 6.2 * color + 0.5 ) ) / ( color * ( 6.2 * color + 1.7 ) + 0.06 ), vec3( 2.2 ) );
}
vec3 RRTAndODTFit( vec3 v ) {
	vec3 a = v * ( v + 0.0245786 ) - 0.000090537;
	vec3 b = v * ( 0.983729 * v + 0.4329510 ) + 0.238081;
	return a / b;
}
vec3 ACESFilmicToneMapping( vec3 color ) {
	const mat3 ACESInputMat = mat3(
		vec3( 0.59719, 0.07600, 0.02840 ),		vec3( 0.35458, 0.90834, 0.13383 ),
		vec3( 0.04823, 0.01566, 0.83777 )
	);
	const mat3 ACESOutputMat = mat3(
		vec3(  1.60475, -0.10208, -0.00327 ),		vec3( -0.53108,  1.10813, -0.07276 ),
		vec3( -0.07367, -0.00605,  1.07602 )
	);
	color *= toneMappingExposure / 0.6;
	color = ACESInputMat * color;
	color = RRTAndODTFit( color );
	color = ACESOutputMat * color;
	return saturate( color );
}
vec3 CustomToneMapping( vec3 color ) { return color; }`,T_=`#ifdef USE_TRANSMISSION
	float transmissionAlpha = 1.0;
	float transmissionFactor = transmission;
	float thicknessFactor = thickness;
	#ifdef USE_TRANSMISSIONMAP
		transmissionFactor *= texture2D( transmissionMap, vUv ).r;
	#endif
	#ifdef USE_THICKNESSMAP
		thicknessFactor *= texture2D( thicknessMap, vUv ).g;
	#endif
	vec3 pos = vWorldPosition;
	vec3 v = normalize( cameraPosition - pos );
	vec3 n = inverseTransformDirection( normal, viewMatrix );
	vec4 transmission = getIBLVolumeRefraction(
		n, v, roughnessFactor, material.diffuseColor, material.specularColor, material.specularF90,
		pos, modelMatrix, viewMatrix, projectionMatrix, ior, thicknessFactor,
		attenuationColor, attenuationDistance );
	totalDiffuse = mix( totalDiffuse, transmission.rgb, transmissionFactor );
	transmissionAlpha = mix( transmissionAlpha, transmission.a, transmissionFactor );
#endif`,C_=`#ifdef USE_TRANSMISSION
	uniform float transmission;
	uniform float thickness;
	uniform float attenuationDistance;
	uniform vec3 attenuationColor;
	#ifdef USE_TRANSMISSIONMAP
		uniform sampler2D transmissionMap;
	#endif
	#ifdef USE_THICKNESSMAP
		uniform sampler2D thicknessMap;
	#endif
	uniform vec2 transmissionSamplerSize;
	uniform sampler2D transmissionSamplerMap;
	uniform mat4 modelMatrix;
	uniform mat4 projectionMatrix;
	varying vec3 vWorldPosition;
	vec3 getVolumeTransmissionRay( vec3 n, vec3 v, float thickness, float ior, mat4 modelMatrix ) {
		vec3 refractionVector = refract( - v, normalize( n ), 1.0 / ior );
		vec3 modelScale;
		modelScale.x = length( vec3( modelMatrix[ 0 ].xyz ) );
		modelScale.y = length( vec3( modelMatrix[ 1 ].xyz ) );
		modelScale.z = length( vec3( modelMatrix[ 2 ].xyz ) );
		return normalize( refractionVector ) * thickness * modelScale;
	}
	float applyIorToRoughness( float roughness, float ior ) {
		return roughness * clamp( ior * 2.0 - 2.0, 0.0, 1.0 );
	}
	vec4 getTransmissionSample( vec2 fragCoord, float roughness, float ior ) {
		float framebufferLod = log2( transmissionSamplerSize.x ) * applyIorToRoughness( roughness, ior );
		#ifdef TEXTURE_LOD_EXT
			return texture2DLodEXT( transmissionSamplerMap, fragCoord.xy, framebufferLod );
		#else
			return texture2D( transmissionSamplerMap, fragCoord.xy, framebufferLod );
		#endif
	}
	vec3 applyVolumeAttenuation( vec3 radiance, float transmissionDistance, vec3 attenuationColor, float attenuationDistance ) {
		if ( attenuationDistance == 0.0 ) {
			return radiance;
		} else {
			vec3 attenuationCoefficient = -log( attenuationColor ) / attenuationDistance;
			vec3 transmittance = exp( - attenuationCoefficient * transmissionDistance );			return transmittance * radiance;
		}
	}
	vec4 getIBLVolumeRefraction( vec3 n, vec3 v, float roughness, vec3 diffuseColor, vec3 specularColor, float specularF90,
		vec3 position, mat4 modelMatrix, mat4 viewMatrix, mat4 projMatrix, float ior, float thickness,
		vec3 attenuationColor, float attenuationDistance ) {
		vec3 transmissionRay = getVolumeTransmissionRay( n, v, thickness, ior, modelMatrix );
		vec3 refractedRayExit = position + transmissionRay;
		vec4 ndcPos = projMatrix * viewMatrix * vec4( refractedRayExit, 1.0 );
		vec2 refractionCoords = ndcPos.xy / ndcPos.w;
		refractionCoords += 1.0;
		refractionCoords /= 2.0;
		vec4 transmittedLight = getTransmissionSample( refractionCoords, roughness, ior );
		vec3 attenuatedColor = applyVolumeAttenuation( transmittedLight.rgb, length( transmissionRay ), attenuationColor, attenuationDistance );
		vec3 F = EnvironmentBRDF( n, v, specularColor, specularF90, roughness );
		return vec4( ( 1.0 - F ) * attenuatedColor * diffuseColor, transmittedLight.a );
	}
#endif`,A_=`#if ( defined( USE_UV ) && ! defined( UVS_VERTEX_ONLY ) )
	varying vec2 vUv;
#endif`,P_=`#ifdef USE_UV
	#ifdef UVS_VERTEX_ONLY
		vec2 vUv;
	#else
		varying vec2 vUv;
	#endif
	uniform mat3 uvTransform;
#endif`,L_=`#ifdef USE_UV
	vUv = ( uvTransform * vec3( uv, 1 ) ).xy;
#endif`,R_=`#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )
	varying vec2 vUv2;
#endif`,D_=`#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )
	attribute vec2 uv2;
	varying vec2 vUv2;
	uniform mat3 uv2Transform;
#endif`,I_=`#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )
	vUv2 = ( uv2Transform * vec3( uv2, 1 ) ).xy;
#endif`,N_=`#if defined( USE_ENVMAP ) || defined( DISTANCE ) || defined ( USE_SHADOWMAP ) || defined ( USE_TRANSMISSION )
	vec4 worldPosition = vec4( transformed, 1.0 );
	#ifdef USE_INSTANCING
		worldPosition = instanceMatrix * worldPosition;
	#endif
	worldPosition = modelMatrix * worldPosition;
#endif`;const F_=`varying vec2 vUv;
uniform mat3 uvTransform;
void main() {
	vUv = ( uvTransform * vec3( uv, 1 ) ).xy;
	gl_Position = vec4( position.xy, 1.0, 1.0 );
}`,k_=`uniform sampler2D t2D;
varying vec2 vUv;
void main() {
	vec4 texColor = texture2D( t2D, vUv );
	gl_FragColor = mapTexelToLinear( texColor );
	#include <tonemapping_fragment>
	#include <encodings_fragment>
}`,V_=`varying vec3 vWorldDirection;
#include <common>
void main() {
	vWorldDirection = transformDirection( position, modelMatrix );
	#include <begin_vertex>
	#include <project_vertex>
	gl_Position.z = gl_Position.w;
}`,B_=`#include <envmap_common_pars_fragment>
uniform float opacity;
varying vec3 vWorldDirection;
#include <cube_uv_reflection_fragment>
void main() {
	vec3 vReflect = vWorldDirection;
	#include <envmap_fragment>
	gl_FragColor = envColor;
	gl_FragColor.a *= opacity;
	#include <tonemapping_fragment>
	#include <encodings_fragment>
}`,z_=`#include <common>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
varying vec2 vHighPrecisionZW;
void main() {
	#include <uv_vertex>
	#include <skinbase_vertex>
	#ifdef USE_DISPLACEMENTMAP
		#include <beginnormal_vertex>
		#include <morphnormal_vertex>
		#include <skinnormal_vertex>
	#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vHighPrecisionZW = gl_Position.zw;
}`,O_=`#if DEPTH_PACKING == 3200
	uniform float opacity;
#endif
#include <common>
#include <packing>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
varying vec2 vHighPrecisionZW;
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( 1.0 );
	#if DEPTH_PACKING == 3200
		diffuseColor.a = opacity;
	#endif
	#include <map_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <logdepthbuf_fragment>
	float fragCoordZ = 0.5 * vHighPrecisionZW[0] / vHighPrecisionZW[1] + 0.5;
	#if DEPTH_PACKING == 3200
		gl_FragColor = vec4( vec3( 1.0 - fragCoordZ ), opacity );
	#elif DEPTH_PACKING == 3201
		gl_FragColor = packDepthToRGBA( fragCoordZ );
	#endif
}`,U_=`#define DISTANCE
varying vec3 vWorldPosition;
#include <common>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <skinbase_vertex>
	#ifdef USE_DISPLACEMENTMAP
		#include <beginnormal_vertex>
		#include <morphnormal_vertex>
		#include <skinnormal_vertex>
	#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <worldpos_vertex>
	#include <clipping_planes_vertex>
	vWorldPosition = worldPosition.xyz;
}`,H_=`#define DISTANCE
uniform vec3 referencePosition;
uniform float nearDistance;
uniform float farDistance;
varying vec3 vWorldPosition;
#include <common>
#include <packing>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <clipping_planes_pars_fragment>
void main () {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( 1.0 );
	#include <map_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	float dist = length( vWorldPosition - referencePosition );
	dist = ( dist - nearDistance ) / ( farDistance - nearDistance );
	dist = saturate( dist );
	gl_FragColor = packDepthToRGBA( dist );
}`,G_=`varying vec3 vWorldDirection;
#include <common>
void main() {
	vWorldDirection = transformDirection( position, modelMatrix );
	#include <begin_vertex>
	#include <project_vertex>
}`,W_=`uniform sampler2D tEquirect;
varying vec3 vWorldDirection;
#include <common>
void main() {
	vec3 direction = normalize( vWorldDirection );
	vec2 sampleUV = equirectUv( direction );
	vec4 texColor = texture2D( tEquirect, sampleUV );
	gl_FragColor = mapTexelToLinear( texColor );
	#include <tonemapping_fragment>
	#include <encodings_fragment>
}`,q_=`uniform float scale;
attribute float lineDistance;
varying float vLineDistance;
#include <common>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	vLineDistance = scale * lineDistance;
	#include <color_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <fog_vertex>
}`,j_=`uniform vec3 diffuse;
uniform float opacity;
uniform float dashSize;
uniform float totalSize;
varying float vLineDistance;
#include <common>
#include <color_pars_fragment>
#include <fog_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	if ( mod( vLineDistance, totalSize ) > dashSize ) {
		discard;
	}
	vec3 outgoingLight = vec3( 0.0 );
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <logdepthbuf_fragment>
	#include <color_fragment>
	outgoingLight = diffuseColor.rgb;
	#include <output_fragment>
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
}`,X_=`#include <common>
#include <uv_pars_vertex>
#include <uv2_pars_vertex>
#include <envmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <uv2_vertex>
	#include <color_vertex>
	#if defined ( USE_ENVMAP ) || defined ( USE_SKINNING )
		#include <beginnormal_vertex>
		#include <morphnormal_vertex>
		#include <skinbase_vertex>
		#include <skinnormal_vertex>
		#include <defaultnormal_vertex>
	#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <worldpos_vertex>
	#include <envmap_vertex>
	#include <fog_vertex>
}`,$_=`uniform vec3 diffuse;
uniform float opacity;
#ifndef FLAT_SHADED
	varying vec3 vNormal;
#endif
#include <common>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <uv2_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_pars_fragment>
#include <cube_uv_reflection_fragment>
#include <fog_pars_fragment>
#include <specularmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <specularmap_fragment>
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	#ifdef USE_LIGHTMAP
		vec4 lightMapTexel= texture2D( lightMap, vUv2 );
		reflectedLight.indirectDiffuse += lightMapTexelToLinear( lightMapTexel ).rgb * lightMapIntensity;
	#else
		reflectedLight.indirectDiffuse += vec3( 1.0 );
	#endif
	#include <aomap_fragment>
	reflectedLight.indirectDiffuse *= diffuseColor.rgb;
	vec3 outgoingLight = reflectedLight.indirectDiffuse;
	#include <envmap_fragment>
	#include <output_fragment>
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,Y_=`#define LAMBERT
varying vec3 vLightFront;
varying vec3 vIndirectFront;
#ifdef DOUBLE_SIDED
	varying vec3 vLightBack;
	varying vec3 vIndirectBack;
#endif
#include <common>
#include <uv_pars_vertex>
#include <uv2_pars_vertex>
#include <envmap_pars_vertex>
#include <bsdfs>
#include <lights_pars_begin>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <uv2_vertex>
	#include <color_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <worldpos_vertex>
	#include <envmap_vertex>
	#include <lights_lambert_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`,J_=`uniform vec3 diffuse;
uniform vec3 emissive;
uniform float opacity;
varying vec3 vLightFront;
varying vec3 vIndirectFront;
#ifdef DOUBLE_SIDED
	varying vec3 vLightBack;
	varying vec3 vIndirectBack;
#endif
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <uv2_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_pars_fragment>
#include <cube_uv_reflection_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <fog_pars_fragment>
#include <shadowmap_pars_fragment>
#include <shadowmask_pars_fragment>
#include <specularmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( diffuse, opacity );
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <specularmap_fragment>
	#include <emissivemap_fragment>
	#ifdef DOUBLE_SIDED
		reflectedLight.indirectDiffuse += ( gl_FrontFacing ) ? vIndirectFront : vIndirectBack;
	#else
		reflectedLight.indirectDiffuse += vIndirectFront;
	#endif
	#include <lightmap_fragment>
	reflectedLight.indirectDiffuse *= BRDF_Lambert( diffuseColor.rgb );
	#ifdef DOUBLE_SIDED
		reflectedLight.directDiffuse = ( gl_FrontFacing ) ? vLightFront : vLightBack;
	#else
		reflectedLight.directDiffuse = vLightFront;
	#endif
	reflectedLight.directDiffuse *= BRDF_Lambert( diffuseColor.rgb ) * getShadowMask();
	#include <aomap_fragment>
	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;
	#include <envmap_fragment>
	#include <output_fragment>
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,Z_=`#define MATCAP
varying vec3 vViewPosition;
#include <common>
#include <uv_pars_vertex>
#include <color_pars_vertex>
#include <displacementmap_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <fog_vertex>
	vViewPosition = - mvPosition.xyz;
}`,K_=`#define MATCAP
uniform vec3 diffuse;
uniform float opacity;
uniform sampler2D matcap;
varying vec3 vViewPosition;
#include <common>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <fog_pars_fragment>
#include <normal_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	vec3 viewDir = normalize( vViewPosition );
	vec3 x = normalize( vec3( viewDir.z, 0.0, - viewDir.x ) );
	vec3 y = cross( viewDir, x );
	vec2 uv = vec2( dot( x, normal ), dot( y, normal ) ) * 0.495 + 0.5;
	#ifdef USE_MATCAP
		vec4 matcapColor = texture2D( matcap, uv );
		matcapColor = matcapTexelToLinear( matcapColor );
	#else
		vec4 matcapColor = vec4( 1.0 );
	#endif
	vec3 outgoingLight = diffuseColor.rgb * matcapColor.rgb;
	#include <output_fragment>
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,Q_=`#define NORMAL
#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )
	varying vec3 vViewPosition;
#endif
#include <common>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )
	vViewPosition = - mvPosition.xyz;
#endif
}`,tx=`#define NORMAL
uniform float opacity;
#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )
	varying vec3 vViewPosition;
#endif
#include <packing>
#include <uv_pars_fragment>
#include <normal_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	#include <logdepthbuf_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	gl_FragColor = vec4( packNormalToRGB( normal ), opacity );
}`,ex=`#define PHONG
varying vec3 vViewPosition;
#include <common>
#include <uv_pars_vertex>
#include <uv2_pars_vertex>
#include <displacementmap_pars_vertex>
#include <envmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <uv2_vertex>
	#include <color_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <envmap_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`,nx=`#define PHONG
uniform vec3 diffuse;
uniform vec3 emissive;
uniform vec3 specular;
uniform float shininess;
uniform float opacity;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <uv2_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_pars_fragment>
#include <cube_uv_reflection_fragment>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_phong_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <specularmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( diffuse, opacity );
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <specularmap_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_phong_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;
	#include <envmap_fragment>
	#include <output_fragment>
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,ix=`#define STANDARD
varying vec3 vViewPosition;
#ifdef USE_TRANSMISSION
	varying vec3 vWorldPosition;
#endif
#include <common>
#include <uv_pars_vertex>
#include <uv2_pars_vertex>
#include <displacementmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <uv2_vertex>
	#include <color_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
#ifdef USE_TRANSMISSION
	vWorldPosition = worldPosition.xyz;
#endif
}`,rx=`#define STANDARD
#ifdef PHYSICAL
	#define IOR
	#define SPECULAR
#endif
uniform vec3 diffuse;
uniform vec3 emissive;
uniform float roughness;
uniform float metalness;
uniform float opacity;
#ifdef IOR
	uniform float ior;
#endif
#ifdef SPECULAR
	uniform float specularIntensity;
	uniform vec3 specularColor;
	#ifdef USE_SPECULARINTENSITYMAP
		uniform sampler2D specularIntensityMap;
	#endif
	#ifdef USE_SPECULARCOLORMAP
		uniform sampler2D specularColorMap;
	#endif
#endif
#ifdef USE_CLEARCOAT
	uniform float clearcoat;
	uniform float clearcoatRoughness;
#endif
#ifdef USE_SHEEN
	uniform vec3 sheenColor;
	uniform float sheenRoughness;
	#ifdef USE_SHEENCOLORMAP
		uniform sampler2D sheenColorMap;
	#endif
	#ifdef USE_SHEENROUGHNESSMAP
		uniform sampler2D sheenRoughnessMap;
	#endif
#endif
varying vec3 vViewPosition;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <uv2_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <bsdfs>
#include <cube_uv_reflection_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_physical_pars_fragment>
#include <fog_pars_fragment>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_physical_pars_fragment>
#include <transmission_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <clearcoat_pars_fragment>
#include <roughnessmap_pars_fragment>
#include <metalnessmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( diffuse, opacity );
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <roughnessmap_fragment>
	#include <metalnessmap_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <clearcoat_normal_fragment_begin>
	#include <clearcoat_normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_physical_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 totalDiffuse = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse;
	vec3 totalSpecular = reflectedLight.directSpecular + reflectedLight.indirectSpecular;
	#include <transmission_fragment>
	vec3 outgoingLight = totalDiffuse + totalSpecular + totalEmissiveRadiance;
	#ifdef USE_SHEEN
		float sheenEnergyComp = 1.0 - 0.157 * max3( material.sheenColor );
		outgoingLight = outgoingLight * sheenEnergyComp + sheenSpecular;
	#endif
	#ifdef USE_CLEARCOAT
		float dotNVcc = saturate( dot( geometry.clearcoatNormal, geometry.viewDir ) );
		vec3 Fcc = F_Schlick( material.clearcoatF0, material.clearcoatF90, dotNVcc );
		outgoingLight = outgoingLight * ( 1.0 - material.clearcoat * Fcc ) + clearcoatSpecular * material.clearcoat;
	#endif
	#include <output_fragment>
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,sx=`#define TOON
varying vec3 vViewPosition;
#include <common>
#include <uv_pars_vertex>
#include <uv2_pars_vertex>
#include <displacementmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <uv2_vertex>
	#include <color_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`,ox=`#define TOON
uniform vec3 diffuse;
uniform vec3 emissive;
uniform float opacity;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <uv2_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <gradientmap_pars_fragment>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_toon_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( diffuse, opacity );
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_toon_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;
	#include <output_fragment>
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,ax=`uniform float size;
uniform float scale;
#include <common>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <color_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <project_vertex>
	gl_PointSize = size;
	#ifdef USE_SIZEATTENUATION
		bool isPerspective = isPerspectiveMatrix( projectionMatrix );
		if ( isPerspective ) gl_PointSize *= ( scale / - mvPosition.z );
	#endif
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <worldpos_vertex>
	#include <fog_vertex>
}`,lx=`uniform vec3 diffuse;
uniform float opacity;
#include <common>
#include <color_pars_fragment>
#include <map_particle_pars_fragment>
#include <alphatest_pars_fragment>
#include <fog_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec3 outgoingLight = vec3( 0.0 );
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <logdepthbuf_fragment>
	#include <map_particle_fragment>
	#include <color_fragment>
	#include <alphatest_fragment>
	outgoingLight = diffuseColor.rgb;
	#include <output_fragment>
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
}`,cx=`#include <common>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
void main() {
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <project_vertex>
	#include <worldpos_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`,hx=`uniform vec3 color;
uniform float opacity;
#include <common>
#include <packing>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <shadowmap_pars_fragment>
#include <shadowmask_pars_fragment>
void main() {
	gl_FragColor = vec4( color, opacity * ( 1.0 - getShadowMask() ) );
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
}`,ux=`uniform float rotation;
uniform vec2 center;
#include <common>
#include <uv_pars_vertex>
#include <fog_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	vec4 mvPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );
	vec2 scale;
	scale.x = length( vec3( modelMatrix[ 0 ].x, modelMatrix[ 0 ].y, modelMatrix[ 0 ].z ) );
	scale.y = length( vec3( modelMatrix[ 1 ].x, modelMatrix[ 1 ].y, modelMatrix[ 1 ].z ) );
	#ifndef USE_SIZEATTENUATION
		bool isPerspective = isPerspectiveMatrix( projectionMatrix );
		if ( isPerspective ) scale *= - mvPosition.z;
	#endif
	vec2 alignedPosition = ( position.xy - ( center - vec2( 0.5 ) ) ) * scale;
	vec2 rotatedPosition;
	rotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;
	rotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;
	mvPosition.xy += rotatedPosition;
	gl_Position = projectionMatrix * mvPosition;
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <fog_vertex>
}`,dx=`uniform vec3 diffuse;
uniform float opacity;
#include <common>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <fog_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec3 outgoingLight = vec3( 0.0 );
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	outgoingLight = diffuseColor.rgb;
	#include <output_fragment>
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
}`,jt={alphamap_fragment:Ug,alphamap_pars_fragment:Hg,alphatest_fragment:Gg,alphatest_pars_fragment:Wg,aomap_fragment:qg,aomap_pars_fragment:jg,begin_vertex:Xg,beginnormal_vertex:$g,bsdfs:Yg,bumpmap_pars_fragment:Jg,clipping_planes_fragment:Zg,clipping_planes_pars_fragment:Kg,clipping_planes_pars_vertex:Qg,clipping_planes_vertex:tv,color_fragment:ev,color_pars_fragment:nv,color_pars_vertex:iv,color_vertex:rv,common:sv,cube_uv_reflection_fragment:ov,defaultnormal_vertex:av,displacementmap_pars_vertex:lv,displacementmap_vertex:cv,emissivemap_fragment:hv,emissivemap_pars_fragment:uv,encodings_fragment:dv,encodings_pars_fragment:pv,envmap_fragment:fv,envmap_common_pars_fragment:mv,envmap_pars_fragment:gv,envmap_pars_vertex:vv,envmap_physical_pars_fragment:Av,envmap_vertex:_v,fog_vertex:xv,fog_pars_vertex:bv,fog_fragment:yv,fog_pars_fragment:wv,gradientmap_pars_fragment:Mv,lightmap_fragment:Sv,lightmap_pars_fragment:Ev,lights_lambert_vertex:Tv,lights_pars_begin:Cv,lights_toon_fragment:Pv,lights_toon_pars_fragment:Lv,lights_phong_fragment:Rv,lights_phong_pars_fragment:Dv,lights_physical_fragment:Iv,lights_physical_pars_fragment:Nv,lights_fragment_begin:Fv,lights_fragment_maps:kv,lights_fragment_end:Vv,logdepthbuf_fragment:Bv,logdepthbuf_pars_fragment:zv,logdepthbuf_pars_vertex:Ov,logdepthbuf_vertex:Uv,map_fragment:Hv,map_pars_fragment:Gv,map_particle_fragment:Wv,map_particle_pars_fragment:qv,metalnessmap_fragment:jv,metalnessmap_pars_fragment:Xv,morphnormal_vertex:$v,morphtarget_pars_vertex:Yv,morphtarget_vertex:Jv,normal_fragment_begin:Zv,normal_fragment_maps:Kv,normal_pars_fragment:Qv,normal_pars_vertex:t_,normal_vertex:e_,normalmap_pars_fragment:n_,clearcoat_normal_fragment_begin:i_,clearcoat_normal_fragment_maps:r_,clearcoat_pars_fragment:s_,output_fragment:o_,packing:a_,premultiplied_alpha_fragment:l_,project_vertex:c_,dithering_fragment:h_,dithering_pars_fragment:u_,roughnessmap_fragment:d_,roughnessmap_pars_fragment:p_,shadowmap_pars_fragment:f_,shadowmap_pars_vertex:m_,shadowmap_vertex:g_,shadowmask_pars_fragment:v_,skinbase_vertex:__,skinning_pars_vertex:x_,skinning_vertex:b_,skinnormal_vertex:y_,specularmap_fragment:w_,specularmap_pars_fragment:M_,tonemapping_fragment:S_,tonemapping_pars_fragment:E_,transmission_fragment:T_,transmission_pars_fragment:C_,uv_pars_fragment:A_,uv_pars_vertex:P_,uv_vertex:L_,uv2_pars_fragment:R_,uv2_pars_vertex:D_,uv2_vertex:I_,worldpos_vertex:N_,background_vert:F_,background_frag:k_,cube_vert:V_,cube_frag:B_,depth_vert:z_,depth_frag:O_,distanceRGBA_vert:U_,distanceRGBA_frag:H_,equirect_vert:G_,equirect_frag:W_,linedashed_vert:q_,linedashed_frag:j_,meshbasic_vert:X_,meshbasic_frag:$_,meshlambert_vert:Y_,meshlambert_frag:J_,meshmatcap_vert:Z_,meshmatcap_frag:K_,meshnormal_vert:Q_,meshnormal_frag:tx,meshphong_vert:ex,meshphong_frag:nx,meshphysical_vert:ix,meshphysical_frag:rx,meshtoon_vert:sx,meshtoon_frag:ox,points_vert:ax,points_frag:lx,shadow_vert:cx,shadow_frag:hx,sprite_vert:ux,sprite_frag:dx},gt={common:{diffuse:{value:new Et(16777215)},opacity:{value:1},map:{value:null},uvTransform:{value:new Te},uv2Transform:{value:new Te},alphaMap:{value:null},alphaTest:{value:0}},specularmap:{specularMap:{value:null}},envmap:{envMap:{value:null},flipEnvMap:{value:-1},reflectivity:{value:1},ior:{value:1.5},refractionRatio:{value:.98}},aomap:{aoMap:{value:null},aoMapIntensity:{value:1}},lightmap:{lightMap:{value:null},lightMapIntensity:{value:1}},emissivemap:{emissiveMap:{value:null}},bumpmap:{bumpMap:{value:null},bumpScale:{value:1}},normalmap:{normalMap:{value:null},normalScale:{value:new st(1,1)}},displacementmap:{displacementMap:{value:null},displacementScale:{value:1},displacementBias:{value:0}},roughnessmap:{roughnessMap:{value:null}},metalnessmap:{metalnessMap:{value:null}},gradientmap:{gradientMap:{value:null}},fog:{fogDensity:{value:25e-5},fogNear:{value:1},fogFar:{value:2e3},fogColor:{value:new Et(16777215)}},lights:{ambientLightColor:{value:[]},lightProbe:{value:[]},directionalLights:{value:[],properties:{direction:{},color:{}}},directionalLightShadows:{value:[],properties:{shadowBias:{},shadowNormalBias:{},shadowRadius:{},shadowMapSize:{}}},directionalShadowMap:{value:[]},directionalShadowMatrix:{value:[]},spotLights:{value:[],properties:{color:{},position:{},direction:{},distance:{},coneCos:{},penumbraCos:{},decay:{}}},spotLightShadows:{value:[],properties:{shadowBias:{},shadowNormalBias:{},shadowRadius:{},shadowMapSize:{}}},spotShadowMap:{value:[]},spotShadowMatrix:{value:[]},pointLights:{value:[],properties:{color:{},position:{},decay:{},distance:{}}},pointLightShadows:{value:[],properties:{shadowBias:{},shadowNormalBias:{},shadowRadius:{},shadowMapSize:{},shadowCameraNear:{},shadowCameraFar:{}}},pointShadowMap:{value:[]},pointShadowMatrix:{value:[]},hemisphereLights:{value:[],properties:{direction:{},skyColor:{},groundColor:{}}},rectAreaLights:{value:[],properties:{color:{},position:{},width:{},height:{}}},ltc_1:{value:null},ltc_2:{value:null}},points:{diffuse:{value:new Et(16777215)},opacity:{value:1},size:{value:1},scale:{value:1},map:{value:null},alphaMap:{value:null},alphaTest:{value:0},uvTransform:{value:new Te}},sprite:{diffuse:{value:new Et(16777215)},opacity:{value:1},center:{value:new st(.5,.5)},rotation:{value:0},map:{value:null},alphaMap:{value:null},alphaTest:{value:0},uvTransform:{value:new Te}}},ln={basic:{uniforms:Ce([gt.common,gt.specularmap,gt.envmap,gt.aomap,gt.lightmap,gt.fog]),vertexShader:jt.meshbasic_vert,fragmentShader:jt.meshbasic_frag},lambert:{uniforms:Ce([gt.common,gt.specularmap,gt.envmap,gt.aomap,gt.lightmap,gt.emissivemap,gt.fog,gt.lights,{emissive:{value:new Et(0)}}]),vertexShader:jt.meshlambert_vert,fragmentShader:jt.meshlambert_frag},phong:{uniforms:Ce([gt.common,gt.specularmap,gt.envmap,gt.aomap,gt.lightmap,gt.emissivemap,gt.bumpmap,gt.normalmap,gt.displacementmap,gt.fog,gt.lights,{emissive:{value:new Et(0)},specular:{value:new Et(1118481)},shininess:{value:30}}]),vertexShader:jt.meshphong_vert,fragmentShader:jt.meshphong_frag},standard:{uniforms:Ce([gt.common,gt.envmap,gt.aomap,gt.lightmap,gt.emissivemap,gt.bumpmap,gt.normalmap,gt.displacementmap,gt.roughnessmap,gt.metalnessmap,gt.fog,gt.lights,{emissive:{value:new Et(0)},roughness:{value:1},metalness:{value:0},envMapIntensity:{value:1}}]),vertexShader:jt.meshphysical_vert,fragmentShader:jt.meshphysical_frag},toon:{uniforms:Ce([gt.common,gt.aomap,gt.lightmap,gt.emissivemap,gt.bumpmap,gt.normalmap,gt.displacementmap,gt.gradientmap,gt.fog,gt.lights,{emissive:{value:new Et(0)}}]),vertexShader:jt.meshtoon_vert,fragmentShader:jt.meshtoon_frag},matcap:{uniforms:Ce([gt.common,gt.bumpmap,gt.normalmap,gt.displacementmap,gt.fog,{matcap:{value:null}}]),vertexShader:jt.meshmatcap_vert,fragmentShader:jt.meshmatcap_frag},points:{uniforms:Ce([gt.points,gt.fog]),vertexShader:jt.points_vert,fragmentShader:jt.points_frag},dashed:{uniforms:Ce([gt.common,gt.fog,{scale:{value:1},dashSize:{value:1},totalSize:{value:2}}]),vertexShader:jt.linedashed_vert,fragmentShader:jt.linedashed_frag},depth:{uniforms:Ce([gt.common,gt.displacementmap]),vertexShader:jt.depth_vert,fragmentShader:jt.depth_frag},normal:{uniforms:Ce([gt.common,gt.bumpmap,gt.normalmap,gt.displacementmap,{opacity:{value:1}}]),vertexShader:jt.meshnormal_vert,fragmentShader:jt.meshnormal_frag},sprite:{uniforms:Ce([gt.sprite,gt.fog]),vertexShader:jt.sprite_vert,fragmentShader:jt.sprite_frag},background:{uniforms:{uvTransform:{value:new Te},t2D:{value:null}},vertexShader:jt.background_vert,fragmentShader:jt.background_frag},cube:{uniforms:Ce([gt.envmap,{opacity:{value:1}}]),vertexShader:jt.cube_vert,fragmentShader:jt.cube_frag},equirect:{uniforms:{tEquirect:{value:null}},vertexShader:jt.equirect_vert,fragmentShader:jt.equirect_frag},distanceRGBA:{uniforms:Ce([gt.common,gt.displacementmap,{referencePosition:{value:new D},nearDistance:{value:1},farDistance:{value:1e3}}]),vertexShader:jt.distanceRGBA_vert,fragmentShader:jt.distanceRGBA_frag},shadow:{uniforms:Ce([gt.lights,gt.fog,{color:{value:new Et(0)},opacity:{value:1}}]),vertexShader:jt.shadow_vert,fragmentShader:jt.shadow_frag}};ln.physical={uniforms:Ce([ln.standard.uniforms,{clearcoat:{value:0},clearcoatMap:{value:null},clearcoatRoughness:{value:0},clearcoatRoughnessMap:{value:null},clearcoatNormalScale:{value:new st(1,1)},clearcoatNormalMap:{value:null},sheen:{value:0},sheenColor:{value:new Et(0)},sheenColorMap:{value:null},sheenRoughness:{value:0},sheenRoughnessMap:{value:null},transmission:{value:0},transmissionMap:{value:null},transmissionSamplerSize:{value:new st},transmissionSamplerMap:{value:null},thickness:{value:0},thicknessMap:{value:null},attenuationDistance:{value:0},attenuationColor:{value:new Et(0)},specularIntensity:{value:0},specularIntensityMap:{value:null},specularColor:{value:new Et(1,1,1)},specularColorMap:{value:null}}]),vertexShader:jt.meshphysical_vert,fragmentShader:jt.meshphysical_frag};function px(o,t,e,n,r){const s=new Et(0);let l=0,h,d,p=null,f=0,m=null;function g(y,w){let S=!1,x=w.isScene===!0?w.background:null;x&&x.isTexture&&(x=t.get(x));const v=o.xr,N=v.getSession&&v.getSession();N&&N.environmentBlendMode==="additive"&&(x=null),x===null?_(s,l):x&&x.isColor&&(_(x,1),S=!0),(o.autoClear||S)&&o.clear(o.autoClearColor,o.autoClearDepth,o.autoClearStencil),x&&(x.isCubeTexture||x.mapping===Ks)?(d===void 0&&(d=new Ve(new $r(1,1,1),new di({name:"BackgroundCubeMaterial",uniforms:Ji(ln.cube.uniforms),vertexShader:ln.cube.vertexShader,fragmentShader:ln.cube.fragmentShader,side:ge,depthTest:!1,depthWrite:!1,fog:!1})),d.geometry.deleteAttribute("normal"),d.geometry.deleteAttribute("uv"),d.onBeforeRender=function(M,R,F){this.matrixWorld.copyPosition(F.matrixWorld)},Object.defineProperty(d.material,"envMap",{get:function(){return this.uniforms.envMap.value}}),n.update(d)),d.material.uniforms.envMap.value=x,d.material.uniforms.flipEnvMap.value=x.isCubeTexture&&x.isRenderTargetTexture===!1?-1:1,(p!==x||f!==x.version||m!==o.toneMapping)&&(d.material.needsUpdate=!0,p=x,f=x.version,m=o.toneMapping),y.unshift(d,d.geometry,d.material,0,0,null)):x&&x.isTexture&&(h===void 0&&(h=new Ve(new za(2,2),new di({name:"BackgroundMaterial",uniforms:Ji(ln.background.uniforms),vertexShader:ln.background.vertexShader,fragmentShader:ln.background.fragmentShader,side:zr,depthTest:!1,depthWrite:!1,fog:!1})),h.geometry.deleteAttribute("normal"),Object.defineProperty(h.material,"map",{get:function(){return this.uniforms.t2D.value}}),n.update(h)),h.material.uniforms.t2D.value=x,x.matrixAutoUpdate===!0&&x.updateMatrix(),h.material.uniforms.uvTransform.value.copy(x.matrix),(p!==x||f!==x.version||m!==o.toneMapping)&&(h.material.needsUpdate=!0,p=x,f=x.version,m=o.toneMapping),y.unshift(h,h.geometry,h.material,0,0,null))}function _(y,w){e.buffers.color.setClear(y.r,y.g,y.b,w,r)}return{getClearColor:function(){return s},setClearColor:function(y,w=1){s.set(y),l=w,_(s,l)},getClearAlpha:function(){return l},setClearAlpha:function(y){l=y,_(s,l)},render:g}}function fx(o,t,e,n){const r=o.getParameter(34921),s=n.isWebGL2?null:t.get("OES_vertex_array_object"),l=n.isWebGL2||s!==null,h={},d=w(null);let p=d;function f(A,H,q,O,U){let X=!1;if(l){const _t=y(O,q,H);p!==_t&&(p=_t,g(p.object)),X=S(O,U),X&&x(O,U)}else{const _t=H.wireframe===!0;(p.geometry!==O.id||p.program!==q.id||p.wireframe!==_t)&&(p.geometry=O.id,p.program=q.id,p.wireframe=_t,X=!0)}A.isInstancedMesh===!0&&(X=!0),U!==null&&e.update(U,34963),X&&(k(A,H,q,O),U!==null&&o.bindBuffer(34963,e.get(U).buffer))}function m(){return n.isWebGL2?o.createVertexArray():s.createVertexArrayOES()}function g(A){return n.isWebGL2?o.bindVertexArray(A):s.bindVertexArrayOES(A)}function _(A){return n.isWebGL2?o.deleteVertexArray(A):s.deleteVertexArrayOES(A)}function y(A,H,q){const O=q.wireframe===!0;let U=h[A.id];U===void 0&&(U={},h[A.id]=U);let X=U[H.id];X===void 0&&(X={},U[H.id]=X);let _t=X[O];return _t===void 0&&(_t=w(m()),X[O]=_t),_t}function w(A){const H=[],q=[],O=[];for(let U=0;U<r;U++)H[U]=0,q[U]=0,O[U]=0;return{geometry:null,program:null,wireframe:!1,newAttributes:H,enabledAttributes:q,attributeDivisors:O,object:A,attributes:{},index:null}}function S(A,H){const q=p.attributes,O=A.attributes;let U=0;for(const X in O){const _t=q[X],J=O[X];if(_t===void 0||_t.attribute!==J||_t.data!==J.data)return!0;U++}return p.attributesNum!==U||p.index!==H}function x(A,H){const q={},O=A.attributes;let U=0;for(const X in O){const _t=O[X],J={};J.attribute=_t,_t.data&&(J.data=_t.data),q[X]=J,U++}p.attributes=q,p.attributesNum=U,p.index=H}function v(){const A=p.newAttributes;for(let H=0,q=A.length;H<q;H++)A[H]=0}function N(A){M(A,0)}function M(A,H){const q=p.newAttributes,O=p.enabledAttributes,U=p.attributeDivisors;q[A]=1,O[A]===0&&(o.enableVertexAttribArray(A),O[A]=1),U[A]!==H&&((n.isWebGL2?o:t.get("ANGLE_instanced_arrays"))[n.isWebGL2?"vertexAttribDivisor":"vertexAttribDivisorANGLE"](A,H),U[A]=H)}function R(){const A=p.newAttributes,H=p.enabledAttributes;for(let q=0,O=H.length;q<O;q++)H[q]!==A[q]&&(o.disableVertexAttribArray(q),H[q]=0)}function F(A,H,q,O,U,X){n.isWebGL2===!0&&(q===5124||q===5125)?o.vertexAttribIPointer(A,H,q,U,X):o.vertexAttribPointer(A,H,q,O,U,X)}function k(A,H,q,O){if(n.isWebGL2===!1&&(A.isInstancedMesh||O.isInstancedBufferGeometry)&&t.get("ANGLE_instanced_arrays")===null)return;v();const U=O.attributes,X=q.getAttributes(),_t=H.defaultAttributeValues;for(const J in X){const Z=X[J];if(Z.location>=0){let pt=U[J];if(pt===void 0&&(J==="instanceMatrix"&&A.instanceMatrix&&(pt=A.instanceMatrix),J==="instanceColor"&&A.instanceColor&&(pt=A.instanceColor)),pt!==void 0){const vt=pt.normalized,at=pt.itemSize,Tt=e.get(pt);if(Tt===void 0)continue;const Q=Tt.buffer,zt=Tt.type,wt=Tt.bytesPerElement;if(pt.isInterleavedBufferAttribute){const yt=pt.data,Mt=yt.stride,Ot=pt.offset;if(yt&&yt.isInstancedInterleavedBuffer){for(let $=0;$<Z.locationSize;$++)M(Z.location+$,yt.meshPerAttribute);A.isInstancedMesh!==!0&&O._maxInstanceCount===void 0&&(O._maxInstanceCount=yt.meshPerAttribute*yt.count)}else for(let $=0;$<Z.locationSize;$++)N(Z.location+$);o.bindBuffer(34962,Q);for(let $=0;$<Z.locationSize;$++)F(Z.location+$,at/Z.locationSize,zt,vt,Mt*wt,(Ot+at/Z.locationSize*$)*wt)}else{if(pt.isInstancedBufferAttribute){for(let yt=0;yt<Z.locationSize;yt++)M(Z.location+yt,pt.meshPerAttribute);A.isInstancedMesh!==!0&&O._maxInstanceCount===void 0&&(O._maxInstanceCount=pt.meshPerAttribute*pt.count)}else for(let yt=0;yt<Z.locationSize;yt++)N(Z.location+yt);o.bindBuffer(34962,Q);for(let yt=0;yt<Z.locationSize;yt++)F(Z.location+yt,at/Z.locationSize,zt,vt,at*wt,at/Z.locationSize*yt*wt)}}else if(_t!==void 0){const vt=_t[J];if(vt!==void 0)switch(vt.length){case 2:o.vertexAttrib2fv(Z.location,vt);break;case 3:o.vertexAttrib3fv(Z.location,vt);break;case 4:o.vertexAttrib4fv(Z.location,vt);break;default:o.vertexAttrib1fv(Z.location,vt)}}}}R()}function j(){V();for(const A in h){const H=h[A];for(const q in H){const O=H[q];for(const U in O)_(O[U].object),delete O[U];delete H[q]}delete h[A]}}function ot(A){if(h[A.id]===void 0)return;const H=h[A.id];for(const q in H){const O=H[q];for(const U in O)_(O[U].object),delete O[U];delete H[q]}delete h[A.id]}function Y(A){for(const H in h){const q=h[H];if(q[A.id]===void 0)continue;const O=q[A.id];for(const U in O)_(O[U].object),delete O[U];delete q[A.id]}}function V(){C(),p!==d&&(p=d,g(p.object))}function C(){d.geometry=null,d.program=null,d.wireframe=!1}return{setup:f,reset:V,resetDefaultState:C,dispose:j,releaseStatesOfGeometry:ot,releaseStatesOfProgram:Y,initAttributes:v,enableAttribute:N,disableUnusedAttributes:R}}function mx(o,t,e,n){const r=n.isWebGL2;let s;function l(p){s=p}function h(p,f){o.drawArrays(s,p,f),e.update(f,s,1)}function d(p,f,m){if(m===0)return;let g,_;if(r)g=o,_="drawArraysInstanced";else if(g=t.get("ANGLE_instanced_arrays"),_="drawArraysInstancedANGLE",g===null){console.error("THREE.WebGLBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.");return}g[_](s,p,f,m),e.update(f,s,m)}this.setMode=l,this.render=h,this.renderInstances=d}function gx(o,t,e){let n;function r(){if(n!==void 0)return n;if(t.has("EXT_texture_filter_anisotropic")===!0){const k=t.get("EXT_texture_filter_anisotropic");n=o.getParameter(k.MAX_TEXTURE_MAX_ANISOTROPY_EXT)}else n=0;return n}function s(k){if(k==="highp"){if(o.getShaderPrecisionFormat(35633,36338).precision>0&&o.getShaderPrecisionFormat(35632,36338).precision>0)return"highp";k="mediump"}return k==="mediump"&&o.getShaderPrecisionFormat(35633,36337).precision>0&&o.getShaderPrecisionFormat(35632,36337).precision>0?"mediump":"lowp"}const l=typeof WebGL2RenderingContext!="undefined"&&o instanceof WebGL2RenderingContext||typeof WebGL2ComputeRenderingContext!="undefined"&&o instanceof WebGL2ComputeRenderingContext;let h=e.precision!==void 0?e.precision:"highp";const d=s(h);d!==h&&(console.warn("THREE.WebGLRenderer:",h,"not supported, using",d,"instead."),h=d);const p=l||t.has("WEBGL_draw_buffers"),f=e.logarithmicDepthBuffer===!0,m=o.getParameter(34930),g=o.getParameter(35660),_=o.getParameter(3379),y=o.getParameter(34076),w=o.getParameter(34921),S=o.getParameter(36347),x=o.getParameter(36348),v=o.getParameter(36349),N=g>0,M=l||t.has("OES_texture_float"),R=N&&M,F=l?o.getParameter(36183):0;return{isWebGL2:l,drawBuffers:p,getMaxAnisotropy:r,getMaxPrecision:s,precision:h,logarithmicDepthBuffer:f,maxTextures:m,maxVertexTextures:g,maxTextureSize:_,maxCubemapSize:y,maxAttributes:w,maxVertexUniforms:S,maxVaryings:x,maxFragmentUniforms:v,vertexTextures:N,floatFragmentTextures:M,floatVertexTextures:R,maxSamples:F}}function vx(o){const t=this;let e=null,n=0,r=!1,s=!1;const l=new Sn,h=new Te,d={value:null,needsUpdate:!1};this.uniform=d,this.numPlanes=0,this.numIntersection=0,this.init=function(m,g,_){const y=m.length!==0||g||n!==0||r;return r=g,e=f(m,_,0),n=m.length,y},this.beginShadows=function(){s=!0,f(null)},this.endShadows=function(){s=!1,p()},this.setState=function(m,g,_){const y=m.clippingPlanes,w=m.clipIntersection,S=m.clipShadows,x=o.get(m);if(!r||y===null||y.length===0||s&&!S)s?f(null):p();else{const v=s?0:n,N=v*4;let M=x.clippingState||null;d.value=M,M=f(y,g,N,_);for(let R=0;R!==N;++R)M[R]=e[R];x.clippingState=M,this.numIntersection=w?this.numPlanes:0,this.numPlanes+=v}};function p(){d.value!==e&&(d.value=e,d.needsUpdate=n>0),t.numPlanes=n,t.numIntersection=0}function f(m,g,_,y){const w=m!==null?m.length:0;let S=null;if(w!==0){if(S=d.value,y!==!0||S===null){const x=_+w*4,v=g.matrixWorldInverse;h.getNormalMatrix(v),(S===null||S.length<x)&&(S=new Float32Array(x));for(let N=0,M=_;N!==w;++N,M+=4)l.copy(m[N]).applyMatrix4(v,h),l.normal.toArray(S,M),S[M+3]=l.constant}d.value=S,d.needsUpdate=!0}return t.numPlanes=w,t.numIntersection=0,S}}function _x(o){let t=new WeakMap;function e(l,h){return h===ya?l.mapping=jr:h===wa&&(l.mapping=Xr),l}function n(l){if(l&&l.isTexture&&l.isRenderTargetTexture===!1){const h=l.mapping;if(h===ya||h===wa)if(t.has(l)){const d=t.get(l).texture;return e(d,l.mapping)}else{const d=l.image;if(d&&d.height>0){const p=o.getRenderTarget(),f=new Jh(d.height/2);return f.fromEquirectangularTexture(o,l),t.set(l,f),o.setRenderTarget(p),l.addEventListener("dispose",r),e(f.texture,l.mapping)}else return null}}return l}function r(l){const h=l.target;h.removeEventListener("dispose",r);const d=t.get(h);d!==void 0&&(t.delete(h),d.dispose())}function s(){t=new WeakMap}return{get:n,dispose:s}}class Oa extends Va{constructor(t=-1,e=1,n=1,r=-1,s=.1,l=2e3){super(),this.type="OrthographicCamera",this.zoom=1,this.view=null,this.left=t,this.right=e,this.top=n,this.bottom=r,this.near=s,this.far=l,this.updateProjectionMatrix()}copy(t,e){return super.copy(t,e),this.left=t.left,this.right=t.right,this.top=t.top,this.bottom=t.bottom,this.near=t.near,this.far=t.far,this.zoom=t.zoom,this.view=t.view===null?null:Object.assign({},t.view),this}setViewOffset(t,e,n,r,s,l){this.view===null&&(this.view={enabled:!0,fullWidth:1,fullHeight:1,offsetX:0,offsetY:0,width:1,height:1}),this.view.enabled=!0,this.view.fullWidth=t,this.view.fullHeight=e,this.view.offsetX=n,this.view.offsetY=r,this.view.width=s,this.view.height=l,this.updateProjectionMatrix()}clearViewOffset(){this.view!==null&&(this.view.enabled=!1),this.updateProjectionMatrix()}updateProjectionMatrix(){const t=(this.right-this.left)/(2*this.zoom),e=(this.top-this.bottom)/(2*this.zoom),n=(this.right+this.left)/2,r=(this.top+this.bottom)/2;let s=n-t,l=n+t,h=r+e,d=r-e;if(this.view!==null&&this.view.enabled){const p=(this.right-this.left)/this.view.fullWidth/this.zoom,f=(this.top-this.bottom)/this.view.fullHeight/this.zoom;s+=p*this.view.offsetX,l=s+p*this.view.width,h-=f*this.view.offsetY,d=h-f*this.view.height}this.projectionMatrix.makeOrthographic(s,l,h,d,this.near,this.far),this.projectionMatrixInverse.copy(this.projectionMatrix).invert()}toJSON(t){const e=super.toJSON(t);return e.object.zoom=this.zoom,e.object.left=this.left,e.object.right=this.right,e.object.top=this.top,e.object.bottom=this.bottom,e.object.near=this.near,e.object.far=this.far,this.view!==null&&(e.object.view=Object.assign({},this.view)),e}}Oa.prototype.isOrthographicCamera=!0;class io extends di{constructor(t){super(t),this.type="RawShaderMaterial"}}io.prototype.isRawShaderMaterial=!0;const Xi=4,jn=8,an=Math.pow(2,jn),Kh=[.125,.215,.35,.446,.526,.582],Qh=jn-Xi+1+Kh.length,ki=20,Xs={[en]:0,[Ki]:1},la=new Oa,{_lodPlanes:Cr,_sizeLods:qc,_sigmas:As}=bx(),jc=new Et;let ca=null;const li=(1+Math.sqrt(5))/2,Vi=1/li,Xc=[new D(1,1,1),new D(-1,1,1),new D(1,1,-1),new D(-1,1,-1),new D(0,li,Vi),new D(0,li,-Vi),new D(Vi,0,li),new D(-Vi,0,li),new D(li,Vi,0),new D(-li,Vi,0)];class xx{constructor(t){this._renderer=t,this._pingPongRenderTarget=null,this._blurMaterial=yx(ki),this._equirectShader=null,this._cubemapShader=null,this._compileMaterial(this._blurMaterial)}fromScene(t,e=0,n=.1,r=100){ca=this._renderer.getRenderTarget();const s=this._allocateTargets();return this._sceneToCubeUV(t,n,r,s),e>0&&this._blur(s,0,0,e),this._applyPMREM(s),this._cleanup(s),s}fromEquirectangular(t){return this._fromTexture(t)}fromCubemap(t){return this._fromTexture(t)}compileCubemapShader(){this._cubemapShader===null&&(this._cubemapShader=Jc(),this._compileMaterial(this._cubemapShader))}compileEquirectangularShader(){this._equirectShader===null&&(this._equirectShader=Yc(),this._compileMaterial(this._equirectShader))}dispose(){this._blurMaterial.dispose(),this._cubemapShader!==null&&this._cubemapShader.dispose(),this._equirectShader!==null&&this._equirectShader.dispose();for(let t=0;t<Cr.length;t++)Cr[t].dispose()}_cleanup(t){this._pingPongRenderTarget.dispose(),this._renderer.setRenderTarget(ca),t.scissorTest=!1,Ps(t,0,0,t.width,t.height)}_fromTexture(t){ca=this._renderer.getRenderTarget();const e=this._allocateTargets(t);return this._textureToCubeUV(t,e),this._applyPMREM(e),this._cleanup(e),e}_allocateTargets(t){const e={magFilter:Le,minFilter:Le,generateMipmaps:!1,type:ci,format:be,encoding:en,depthBuffer:!1},n=$c(e);return n.depthBuffer=!t,this._pingPongRenderTarget=$c(e),n}_compileMaterial(t){const e=new Ve(Cr[0],t);this._renderer.compile(e,la)}_sceneToCubeUV(t,e,n,r){const h=new ke(90,1,e,n),d=[1,-1,1,1,1,1],p=[1,1,1,-1,-1,-1],f=this._renderer,m=f.autoClear,g=f.toneMapping;f.getClearColor(jc),f.toneMapping=qn,f.autoClear=!1;const _=new ka({name:"PMREM.Background",side:ge,depthWrite:!1,depthTest:!1}),y=new Ve(new $r,_);let w=!1;const S=t.background;S?S.isColor&&(_.color.copy(S),t.background=null,w=!0):(_.color.copy(jc),w=!0);for(let x=0;x<6;x++){const v=x%3;v==0?(h.up.set(0,d[x],0),h.lookAt(p[x],0,0)):v==1?(h.up.set(0,0,d[x]),h.lookAt(0,p[x],0)):(h.up.set(0,d[x],0),h.lookAt(0,0,p[x])),Ps(r,v*an,x>2?an:0,an,an),f.setRenderTarget(r),w&&f.render(y,h),f.render(t,h)}y.geometry.dispose(),y.material.dispose(),f.toneMapping=g,f.autoClear=m,t.background=S}_setEncoding(t,e){this._renderer.capabilities.isWebGL2===!0&&e.format===be&&e.type===En&&e.encoding===Ki?t.value=Xs[en]:t.value=Xs[e.encoding]}_textureToCubeUV(t,e){const n=this._renderer,r=t.mapping===jr||t.mapping===Xr;r?this._cubemapShader==null&&(this._cubemapShader=Jc()):this._equirectShader==null&&(this._equirectShader=Yc());const s=r?this._cubemapShader:this._equirectShader,l=new Ve(Cr[0],s),h=s.uniforms;h.envMap.value=t,r||h.texelSize.value.set(1/t.image.width,1/t.image.height),this._setEncoding(h.inputEncoding,t),Ps(e,0,0,3*an,2*an),n.setRenderTarget(e),n.render(l,la)}_applyPMREM(t){const e=this._renderer,n=e.autoClear;e.autoClear=!1;for(let r=1;r<Qh;r++){const s=Math.sqrt(As[r]*As[r]-As[r-1]*As[r-1]),l=Xc[(r-1)%Xc.length];this._blur(t,r-1,r,s,l)}e.autoClear=n}_blur(t,e,n,r,s){const l=this._pingPongRenderTarget;this._halfBlur(t,l,e,n,r,"latitudinal",s),this._halfBlur(l,t,n,n,r,"longitudinal",s)}_halfBlur(t,e,n,r,s,l,h){const d=this._renderer,p=this._blurMaterial;l!=="latitudinal"&&l!=="longitudinal"&&console.error("blur direction must be either latitudinal or longitudinal!");const f=3,m=new Ve(Cr[r],p),g=p.uniforms,_=qc[n]-1,y=isFinite(s)?Math.PI/(2*_):2*Math.PI/(2*ki-1),w=s/y,S=isFinite(s)?1+Math.floor(f*w):ki;S>ki&&console.warn(`sigmaRadians, ${s}, is too large and will clip, as it requested ${S} samples when the maximum is set to ${ki}`);const x=[];let v=0;for(let F=0;F<ki;++F){const k=F/w,j=Math.exp(-k*k/2);x.push(j),F==0?v+=j:F<S&&(v+=2*j)}for(let F=0;F<x.length;F++)x[F]=x[F]/v;g.envMap.value=t.texture,g.samples.value=S,g.weights.value=x,g.latitudinal.value=l==="latitudinal",h&&(g.poleAxis.value=h),g.dTheta.value=y,g.mipInt.value=jn-n;const N=qc[r],M=3*Math.max(0,an-2*N),R=(r===0?0:2*an)+2*N*(r>jn-Xi?r-jn+Xi:0);Ps(e,M,R,3*N,2*N),d.setRenderTarget(e),d.render(m,la)}}function bx(){const o=[],t=[],e=[];let n=jn;for(let r=0;r<Qh;r++){const s=Math.pow(2,n);t.push(s);let l=1/s;r>jn-Xi?l=Kh[r-jn+Xi-1]:r==0&&(l=0),e.push(l);const h=1/(s-1),d=-h/2,p=1+h/2,f=[d,d,p,d,p,p,d,d,p,p,d,p],m=6,g=6,_=3,y=2,w=1,S=new Float32Array(_*g*m),x=new Float32Array(y*g*m),v=new Float32Array(w*g*m);for(let M=0;M<m;M++){const R=M%3*2/3-1,F=M>2?0:-1,k=[R,F,0,R+2/3,F,0,R+2/3,F+1,0,R,F,0,R+2/3,F+1,0,R,F+1,0];S.set(k,_*g*M),x.set(f,y*g*M);const j=[M,M,M,M,M,M];v.set(j,w*g*M)}const N=new ce;N.setAttribute("position",new _e(S,_)),N.setAttribute("uv",new _e(x,y)),N.setAttribute("faceIndex",new _e(v,w)),o.push(N),n>Xi&&n--}return{_lodPlanes:o,_sizeLods:t,_sigmas:e}}function $c(o){const t=new Ye(3*an,3*an,o);return t.texture.mapping=Ks,t.texture.name="PMREM.cubeUv",t.scissorTest=!0,t}function Ps(o,t,e,n,r){o.viewport.set(t,e,n,r),o.scissor.set(t,e,n,r)}function yx(o){const t=new Float32Array(o),e=new D(0,1,0);return new io({name:"SphericalGaussianBlur",defines:{n:o},uniforms:{envMap:{value:null},samples:{value:1},weights:{value:t},latitudinal:{value:!1},dTheta:{value:0},mipInt:{value:0},poleAxis:{value:e}},vertexShader:Ua(),fragmentShader:`

			precision mediump float;
			precision mediump int;

			varying vec3 vOutputDirection;

			uniform sampler2D envMap;
			uniform int samples;
			uniform float weights[ n ];
			uniform bool latitudinal;
			uniform float dTheta;
			uniform float mipInt;
			uniform vec3 poleAxis;

			${Ha()}

			#define ENVMAP_TYPE_CUBE_UV
			#include <cube_uv_reflection_fragment>

			vec3 getSample( float theta, vec3 axis ) {

				float cosTheta = cos( theta );
				// Rodrigues' axis-angle rotation
				vec3 sampleDirection = vOutputDirection * cosTheta
					+ cross( axis, vOutputDirection ) * sin( theta )
					+ axis * dot( axis, vOutputDirection ) * ( 1.0 - cosTheta );

				return bilinearCubeUV( envMap, sampleDirection, mipInt );

			}

			void main() {

				vec3 axis = latitudinal ? poleAxis : cross( poleAxis, vOutputDirection );

				if ( all( equal( axis, vec3( 0.0 ) ) ) ) {

					axis = vec3( vOutputDirection.z, 0.0, - vOutputDirection.x );

				}

				axis = normalize( axis );

				gl_FragColor = vec4( 0.0, 0.0, 0.0, 1.0 );
				gl_FragColor.rgb += weights[ 0 ] * getSample( 0.0, axis );

				for ( int i = 1; i < n; i++ ) {

					if ( i >= samples ) {

						break;

					}

					float theta = dTheta * float( i );
					gl_FragColor.rgb += weights[ i ] * getSample( -1.0 * theta, axis );
					gl_FragColor.rgb += weights[ i ] * getSample( theta, axis );

				}

			}
		`,blending:Wn,depthTest:!1,depthWrite:!1})}function Yc(){const o=new st(1,1);return new io({name:"EquirectangularToCubeUV",uniforms:{envMap:{value:null},texelSize:{value:o},inputEncoding:{value:Xs[en]}},vertexShader:Ua(),fragmentShader:`

			precision mediump float;
			precision mediump int;

			varying vec3 vOutputDirection;

			uniform sampler2D envMap;
			uniform vec2 texelSize;

			${Ha()}

			#include <common>

			void main() {

				gl_FragColor = vec4( 0.0, 0.0, 0.0, 1.0 );

				vec3 outputDirection = normalize( vOutputDirection );
				vec2 uv = equirectUv( outputDirection );

				vec2 f = fract( uv / texelSize - 0.5 );
				uv -= f * texelSize;
				vec3 tl = envMapTexelToLinear( texture2D ( envMap, uv ) ).rgb;
				uv.x += texelSize.x;
				vec3 tr = envMapTexelToLinear( texture2D ( envMap, uv ) ).rgb;
				uv.y += texelSize.y;
				vec3 br = envMapTexelToLinear( texture2D ( envMap, uv ) ).rgb;
				uv.x -= texelSize.x;
				vec3 bl = envMapTexelToLinear( texture2D ( envMap, uv ) ).rgb;

				vec3 tm = mix( tl, tr, f.x );
				vec3 bm = mix( bl, br, f.x );
				gl_FragColor.rgb = mix( tm, bm, f.y );

			}
		`,blending:Wn,depthTest:!1,depthWrite:!1})}function Jc(){return new io({name:"CubemapToCubeUV",uniforms:{envMap:{value:null},inputEncoding:{value:Xs[en]}},vertexShader:Ua(),fragmentShader:`

			precision mediump float;
			precision mediump int;

			varying vec3 vOutputDirection;

			uniform samplerCube envMap;

			${Ha()}

			void main() {

				gl_FragColor = envMapTexelToLinear( textureCube( envMap, vec3( - vOutputDirection.x, vOutputDirection.yz ) ) );

			}
		`,blending:Wn,depthTest:!1,depthWrite:!1})}function Ua(){return`

		precision mediump float;
		precision mediump int;

		attribute vec3 position;
		attribute vec2 uv;
		attribute float faceIndex;

		varying vec3 vOutputDirection;

		// RH coordinate system; PMREM face-indexing convention
		vec3 getDirection( vec2 uv, float face ) {

			uv = 2.0 * uv - 1.0;

			vec3 direction = vec3( uv, 1.0 );

			if ( face == 0.0 ) {

				direction = direction.zyx; // ( 1, v, u ) pos x

			} else if ( face == 1.0 ) {

				direction = direction.xzy;
				direction.xz *= -1.0; // ( -u, 1, -v ) pos y

			} else if ( face == 2.0 ) {

				direction.x *= -1.0; // ( -u, v, 1 ) pos z

			} else if ( face == 3.0 ) {

				direction = direction.zyx;
				direction.xz *= -1.0; // ( -1, v, -u ) neg x

			} else if ( face == 4.0 ) {

				direction = direction.xzy;
				direction.xy *= -1.0; // ( -u, -1, v ) neg y

			} else if ( face == 5.0 ) {

				direction.z *= -1.0; // ( u, v, -1 ) neg z

			}

			return direction;

		}

		void main() {

			vOutputDirection = getDirection( uv, faceIndex );
			gl_Position = vec4( position, 1.0 );

		}
	`}function Ha(){return`

		uniform int inputEncoding;

		#include <encodings_pars_fragment>

		vec4 inputTexelToLinear( vec4 value ) {

			if ( inputEncoding == 0 ) {

				return value;

			} else {

				return sRGBToLinear( value );

			}

		}

		vec4 envMapTexelToLinear( vec4 color ) {

			return inputTexelToLinear( color );

		}
	`}function wx(o){let t=new WeakMap,e=null;function n(h){if(h&&h.isTexture&&h.isRenderTargetTexture===!1){const d=h.mapping,p=d===ya||d===wa,f=d===jr||d===Xr;if(p||f){if(t.has(h))return t.get(h).texture;{const m=h.image;if(p&&m&&m.height>0||f&&m&&r(m)){const g=o.getRenderTarget();e===null&&(e=new xx(o));const _=p?e.fromEquirectangular(h):e.fromCubemap(h);return t.set(h,_),o.setRenderTarget(g),h.addEventListener("dispose",s),_.texture}else return null}}}return h}function r(h){let d=0;const p=6;for(let f=0;f<p;f++)h[f]!==void 0&&d++;return d===p}function s(h){const d=h.target;d.removeEventListener("dispose",s);const p=t.get(d);p!==void 0&&(t.delete(d),p.dispose())}function l(){t=new WeakMap,e!==null&&(e.dispose(),e=null)}return{get:n,dispose:l}}function Mx(o){const t={};function e(n){if(t[n]!==void 0)return t[n];let r;switch(n){case"WEBGL_depth_texture":r=o.getExtension("WEBGL_depth_texture")||o.getExtension("MOZ_WEBGL_depth_texture")||o.getExtension("WEBKIT_WEBGL_depth_texture");break;case"EXT_texture_filter_anisotropic":r=o.getExtension("EXT_texture_filter_anisotropic")||o.getExtension("MOZ_EXT_texture_filter_anisotropic")||o.getExtension("WEBKIT_EXT_texture_filter_anisotropic");break;case"WEBGL_compressed_texture_s3tc":r=o.getExtension("WEBGL_compressed_texture_s3tc")||o.getExtension("MOZ_WEBGL_compressed_texture_s3tc")||o.getExtension("WEBKIT_WEBGL_compressed_texture_s3tc");break;case"WEBGL_compressed_texture_pvrtc":r=o.getExtension("WEBGL_compressed_texture_pvrtc")||o.getExtension("WEBKIT_WEBGL_compressed_texture_pvrtc");break;default:r=o.getExtension(n)}return t[n]=r,r}return{has:function(n){return e(n)!==null},init:function(n){n.isWebGL2?e("EXT_color_buffer_float"):(e("WEBGL_depth_texture"),e("OES_texture_float"),e("OES_texture_half_float"),e("OES_texture_half_float_linear"),e("OES_standard_derivatives"),e("OES_element_index_uint"),e("OES_vertex_array_object"),e("ANGLE_instanced_arrays")),e("OES_texture_float_linear"),e("EXT_color_buffer_half_float"),e("WEBGL_multisampled_render_to_texture")},get:function(n){const r=e(n);return r===null&&console.warn("THREE.WebGLRenderer: "+n+" extension not supported."),r}}}function Sx(o,t,e,n){const r={},s=new WeakMap;function l(m){const g=m.target;g.index!==null&&t.remove(g.index);for(const y in g.attributes)t.remove(g.attributes[y]);g.removeEventListener("dispose",l),delete r[g.id];const _=s.get(g);_&&(t.remove(_),s.delete(g)),n.releaseStatesOfGeometry(g),g.isInstancedBufferGeometry===!0&&delete g._maxInstanceCount,e.memory.geometries--}function h(m,g){return r[g.id]===!0||(g.addEventListener("dispose",l),r[g.id]=!0,e.memory.geometries++),g}function d(m){const g=m.attributes;for(const y in g)t.update(g[y],34962);const _=m.morphAttributes;for(const y in _){const w=_[y];for(let S=0,x=w.length;S<x;S++)t.update(w[S],34962)}}function p(m){const g=[],_=m.index,y=m.attributes.position;let w=0;if(_!==null){const v=_.array;w=_.version;for(let N=0,M=v.length;N<M;N+=3){const R=v[N+0],F=v[N+1],k=v[N+2];g.push(R,F,F,k,k,R)}}else{const v=y.array;w=y.version;for(let N=0,M=v.length/3-1;N<M;N+=3){const R=N+0,F=N+1,k=N+2;g.push(R,F,F,k,k,R)}}const S=new(qh(g)>65535?Yh:$h)(g,1);S.version=w;const x=s.get(m);x&&t.remove(x),s.set(m,S)}function f(m){const g=s.get(m);if(g){const _=m.index;_!==null&&g.version<_.version&&p(m)}else p(m);return s.get(m)}return{get:h,update:d,getWireframeAttribute:f}}function Ex(o,t,e,n){const r=n.isWebGL2;let s;function l(g){s=g}let h,d;function p(g){h=g.type,d=g.bytesPerElement}function f(g,_){o.drawElements(s,_,h,g*d),e.update(_,s,1)}function m(g,_,y){if(y===0)return;let w,S;if(r)w=o,S="drawElementsInstanced";else if(w=t.get("ANGLE_instanced_arrays"),S="drawElementsInstancedANGLE",w===null){console.error("THREE.WebGLIndexedBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.");return}w[S](s,_,h,g*d,y),e.update(_,s,y)}this.setMode=l,this.setIndex=p,this.render=f,this.renderInstances=m}function Tx(o){const t={geometries:0,textures:0},e={frame:0,calls:0,triangles:0,points:0,lines:0};function n(s,l,h){switch(e.calls++,l){case 4:e.triangles+=h*(s/3);break;case 1:e.lines+=h*(s/2);break;case 3:e.lines+=h*(s-1);break;case 2:e.lines+=h*s;break;case 0:e.points+=h*s;break;default:console.error("THREE.WebGLInfo: Unknown draw mode:",l);break}}function r(){e.frame++,e.calls=0,e.triangles=0,e.points=0,e.lines=0}return{memory:t,render:e,programs:null,autoReset:!0,reset:r,update:n}}class Ga extends we{constructor(t=null,e=1,n=1,r=1){super(null),this.image={data:t,width:e,height:n,depth:r},this.magFilter=ve,this.minFilter=ve,this.wrapR=qe,this.generateMipmaps=!1,this.flipY=!1,this.unpackAlignment=1}}Ga.prototype.isDataTexture2DArray=!0;function Cx(o,t){return o[0]-t[0]}function Ax(o,t){return Math.abs(t[1])-Math.abs(o[1])}function Zc(o,t){let e=1;const n=t.isInterleavedBufferAttribute?t.data.array:t.array;n instanceof Int8Array?e=127:n instanceof Int16Array?e=32767:n instanceof Int32Array?e=2147483647:console.error("THREE.WebGLMorphtargets: Unsupported morph attribute data type: ",n),o.divideScalar(e)}function Px(o,t,e){const n={},r=new Float32Array(8),s=new WeakMap,l=new D,h=[];for(let p=0;p<8;p++)h[p]=[p,0];function d(p,f,m,g){const _=p.morphTargetInfluences;if(t.isWebGL2===!0){const y=f.morphAttributes.position.length;let w=s.get(f);if(w===void 0||w.count!==y){w!==void 0&&w.texture.dispose();const v=f.morphAttributes.normal!==void 0,N=f.morphAttributes.position,M=f.morphAttributes.normal||[],R=f.attributes.position.count,F=v===!0?2:1;let k=R*F,j=1;k>t.maxTextureSize&&(j=Math.ceil(k/t.maxTextureSize),k=t.maxTextureSize);const ot=new Float32Array(k*j*4*y),Y=new Ga(ot,k,j,y);Y.format=be,Y.type=Gn,Y.needsUpdate=!0;const V=F*4;for(let C=0;C<y;C++){const A=N[C],H=M[C],q=k*j*4*C;for(let O=0;O<A.count;O++){l.fromBufferAttribute(A,O),A.normalized===!0&&Zc(l,A);const U=O*V;ot[q+U+0]=l.x,ot[q+U+1]=l.y,ot[q+U+2]=l.z,ot[q+U+3]=0,v===!0&&(l.fromBufferAttribute(H,O),H.normalized===!0&&Zc(l,H),ot[q+U+4]=l.x,ot[q+U+5]=l.y,ot[q+U+6]=l.z,ot[q+U+7]=0)}}w={count:y,texture:Y,size:new st(k,j)},s.set(f,w)}let S=0;for(let v=0;v<_.length;v++)S+=_[v];const x=f.morphTargetsRelative?1:1-S;g.getUniforms().setValue(o,"morphTargetBaseInfluence",x),g.getUniforms().setValue(o,"morphTargetInfluences",_),g.getUniforms().setValue(o,"morphTargetsTexture",w.texture,e),g.getUniforms().setValue(o,"morphTargetsTextureSize",w.size)}else{const y=_===void 0?0:_.length;let w=n[f.id];if(w===void 0||w.length!==y){w=[];for(let M=0;M<y;M++)w[M]=[M,0];n[f.id]=w}for(let M=0;M<y;M++){const R=w[M];R[0]=M,R[1]=_[M]}w.sort(Ax);for(let M=0;M<8;M++)M<y&&w[M][1]?(h[M][0]=w[M][0],h[M][1]=w[M][1]):(h[M][0]=Number.MAX_SAFE_INTEGER,h[M][1]=0);h.sort(Cx);const S=f.morphAttributes.position,x=f.morphAttributes.normal;let v=0;for(let M=0;M<8;M++){const R=h[M],F=R[0],k=R[1];F!==Number.MAX_SAFE_INTEGER&&k?(S&&f.getAttribute("morphTarget"+M)!==S[F]&&f.setAttribute("morphTarget"+M,S[F]),x&&f.getAttribute("morphNormal"+M)!==x[F]&&f.setAttribute("morphNormal"+M,x[F]),r[M]=k,v+=k):(S&&f.hasAttribute("morphTarget"+M)===!0&&f.deleteAttribute("morphTarget"+M),x&&f.hasAttribute("morphNormal"+M)===!0&&f.deleteAttribute("morphNormal"+M),r[M]=0)}const N=f.morphTargetsRelative?1:1-v;g.getUniforms().setValue(o,"morphTargetBaseInfluence",N),g.getUniforms().setValue(o,"morphTargetInfluences",r)}}return{update:d}}function Lx(o,t,e,n){let r=new WeakMap;function s(d){const p=n.render.frame,f=d.geometry,m=t.get(d,f);return r.get(m)!==p&&(t.update(m),r.set(m,p)),d.isInstancedMesh&&(d.hasEventListener("dispose",h)===!1&&d.addEventListener("dispose",h),e.update(d.instanceMatrix,34962),d.instanceColor!==null&&e.update(d.instanceColor,34962)),m}function l(){r=new WeakMap}function h(d){const p=d.target;p.removeEventListener("dispose",h),e.remove(p.instanceMatrix),p.instanceColor!==null&&e.remove(p.instanceColor)}return{update:s,dispose:l}}class tu extends we{constructor(t=null,e=1,n=1,r=1){super(null),this.image={data:t,width:e,height:n,depth:r},this.magFilter=ve,this.minFilter=ve,this.wrapR=qe,this.generateMipmaps=!1,this.flipY=!1,this.unpackAlignment=1}}tu.prototype.isDataTexture3D=!0;const eu=new we,nu=new Ga,iu=new tu,ru=new eo,Kc=[],Qc=[],th=new Float32Array(16),eh=new Float32Array(9),nh=new Float32Array(4);function rr(o,t,e){const n=o[0];if(n<=0||n>0)return o;const r=t*e;let s=Kc[r];if(s===void 0&&(s=new Float32Array(r),Kc[r]=s),t!==0){n.toArray(s,0);for(let l=1,h=0;l!==t;++l)h+=e,o[l].toArray(s,h)}return s}function Re(o,t){if(o.length!==t.length)return!1;for(let e=0,n=o.length;e<n;e++)if(o[e]!==t[e])return!1;return!0}function Ae(o,t){for(let e=0,n=t.length;e<n;e++)o[e]=t[e]}function ro(o,t){let e=Qc[t];e===void 0&&(e=new Int32Array(t),Qc[t]=e);for(let n=0;n!==t;++n)e[n]=o.allocateTextureUnit();return e}function Rx(o,t){const e=this.cache;e[0]!==t&&(o.uniform1f(this.addr,t),e[0]=t)}function Dx(o,t){const e=this.cache;if(t.x!==void 0)(e[0]!==t.x||e[1]!==t.y)&&(o.uniform2f(this.addr,t.x,t.y),e[0]=t.x,e[1]=t.y);else{if(Re(e,t))return;o.uniform2fv(this.addr,t),Ae(e,t)}}function Ix(o,t){const e=this.cache;if(t.x!==void 0)(e[0]!==t.x||e[1]!==t.y||e[2]!==t.z)&&(o.uniform3f(this.addr,t.x,t.y,t.z),e[0]=t.x,e[1]=t.y,e[2]=t.z);else if(t.r!==void 0)(e[0]!==t.r||e[1]!==t.g||e[2]!==t.b)&&(o.uniform3f(this.addr,t.r,t.g,t.b),e[0]=t.r,e[1]=t.g,e[2]=t.b);else{if(Re(e,t))return;o.uniform3fv(this.addr,t),Ae(e,t)}}function Nx(o,t){const e=this.cache;if(t.x!==void 0)(e[0]!==t.x||e[1]!==t.y||e[2]!==t.z||e[3]!==t.w)&&(o.uniform4f(this.addr,t.x,t.y,t.z,t.w),e[0]=t.x,e[1]=t.y,e[2]=t.z,e[3]=t.w);else{if(Re(e,t))return;o.uniform4fv(this.addr,t),Ae(e,t)}}function Fx(o,t){const e=this.cache,n=t.elements;if(n===void 0){if(Re(e,t))return;o.uniformMatrix2fv(this.addr,!1,t),Ae(e,t)}else{if(Re(e,n))return;nh.set(n),o.uniformMatrix2fv(this.addr,!1,nh),Ae(e,n)}}function kx(o,t){const e=this.cache,n=t.elements;if(n===void 0){if(Re(e,t))return;o.uniformMatrix3fv(this.addr,!1,t),Ae(e,t)}else{if(Re(e,n))return;eh.set(n),o.uniformMatrix3fv(this.addr,!1,eh),Ae(e,n)}}function Vx(o,t){const e=this.cache,n=t.elements;if(n===void 0){if(Re(e,t))return;o.uniformMatrix4fv(this.addr,!1,t),Ae(e,t)}else{if(Re(e,n))return;th.set(n),o.uniformMatrix4fv(this.addr,!1,th),Ae(e,n)}}function Bx(o,t){const e=this.cache;e[0]!==t&&(o.uniform1i(this.addr,t),e[0]=t)}function zx(o,t){const e=this.cache;Re(e,t)||(o.uniform2iv(this.addr,t),Ae(e,t))}function Ox(o,t){const e=this.cache;Re(e,t)||(o.uniform3iv(this.addr,t),Ae(e,t))}function Ux(o,t){const e=this.cache;Re(e,t)||(o.uniform4iv(this.addr,t),Ae(e,t))}function Hx(o,t){const e=this.cache;e[0]!==t&&(o.uniform1ui(this.addr,t),e[0]=t)}function Gx(o,t){const e=this.cache;Re(e,t)||(o.uniform2uiv(this.addr,t),Ae(e,t))}function Wx(o,t){const e=this.cache;Re(e,t)||(o.uniform3uiv(this.addr,t),Ae(e,t))}function qx(o,t){const e=this.cache;Re(e,t)||(o.uniform4uiv(this.addr,t),Ae(e,t))}function jx(o,t,e){const n=this.cache,r=e.allocateTextureUnit();n[0]!==r&&(o.uniform1i(this.addr,r),n[0]=r),e.safeSetTexture2D(t||eu,r)}function Xx(o,t,e){const n=this.cache,r=e.allocateTextureUnit();n[0]!==r&&(o.uniform1i(this.addr,r),n[0]=r),e.setTexture3D(t||iu,r)}function $x(o,t,e){const n=this.cache,r=e.allocateTextureUnit();n[0]!==r&&(o.uniform1i(this.addr,r),n[0]=r),e.safeSetTextureCube(t||ru,r)}function Yx(o,t,e){const n=this.cache,r=e.allocateTextureUnit();n[0]!==r&&(o.uniform1i(this.addr,r),n[0]=r),e.setTexture2DArray(t||nu,r)}function Jx(o){switch(o){case 5126:return Rx;case 35664:return Dx;case 35665:return Ix;case 35666:return Nx;case 35674:return Fx;case 35675:return kx;case 35676:return Vx;case 5124:case 35670:return Bx;case 35667:case 35671:return zx;case 35668:case 35672:return Ox;case 35669:case 35673:return Ux;case 5125:return Hx;case 36294:return Gx;case 36295:return Wx;case 36296:return qx;case 35678:case 36198:case 36298:case 36306:case 35682:return jx;case 35679:case 36299:case 36307:return Xx;case 35680:case 36300:case 36308:case 36293:return $x;case 36289:case 36303:case 36311:case 36292:return Yx}}function Zx(o,t){o.uniform1fv(this.addr,t)}function Kx(o,t){const e=rr(t,this.size,2);o.uniform2fv(this.addr,e)}function Qx(o,t){const e=rr(t,this.size,3);o.uniform3fv(this.addr,e)}function tb(o,t){const e=rr(t,this.size,4);o.uniform4fv(this.addr,e)}function eb(o,t){const e=rr(t,this.size,4);o.uniformMatrix2fv(this.addr,!1,e)}function nb(o,t){const e=rr(t,this.size,9);o.uniformMatrix3fv(this.addr,!1,e)}function ib(o,t){const e=rr(t,this.size,16);o.uniformMatrix4fv(this.addr,!1,e)}function rb(o,t){o.uniform1iv(this.addr,t)}function sb(o,t){o.uniform2iv(this.addr,t)}function ob(o,t){o.uniform3iv(this.addr,t)}function ab(o,t){o.uniform4iv(this.addr,t)}function lb(o,t){o.uniform1uiv(this.addr,t)}function cb(o,t){o.uniform2uiv(this.addr,t)}function hb(o,t){o.uniform3uiv(this.addr,t)}function ub(o,t){o.uniform4uiv(this.addr,t)}function db(o,t,e){const n=t.length,r=ro(e,n);o.uniform1iv(this.addr,r);for(let s=0;s!==n;++s)e.safeSetTexture2D(t[s]||eu,r[s])}function pb(o,t,e){const n=t.length,r=ro(e,n);o.uniform1iv(this.addr,r);for(let s=0;s!==n;++s)e.setTexture3D(t[s]||iu,r[s])}function fb(o,t,e){const n=t.length,r=ro(e,n);o.uniform1iv(this.addr,r);for(let s=0;s!==n;++s)e.safeSetTextureCube(t[s]||ru,r[s])}function mb(o,t,e){const n=t.length,r=ro(e,n);o.uniform1iv(this.addr,r);for(let s=0;s!==n;++s)e.setTexture2DArray(t[s]||nu,r[s])}function gb(o){switch(o){case 5126:return Zx;case 35664:return Kx;case 35665:return Qx;case 35666:return tb;case 35674:return eb;case 35675:return nb;case 35676:return ib;case 5124:case 35670:return rb;case 35667:case 35671:return sb;case 35668:case 35672:return ob;case 35669:case 35673:return ab;case 5125:return lb;case 36294:return cb;case 36295:return hb;case 36296:return ub;case 35678:case 36198:case 36298:case 36306:case 35682:return db;case 35679:case 36299:case 36307:return pb;case 35680:case 36300:case 36308:case 36293:return fb;case 36289:case 36303:case 36311:case 36292:return mb}}function vb(o,t,e){this.id=o,this.addr=e,this.cache=[],this.setValue=Jx(t.type)}function su(o,t,e){this.id=o,this.addr=e,this.cache=[],this.size=t.size,this.setValue=gb(t.type)}su.prototype.updateCache=function(o){const t=this.cache;o instanceof Float32Array&&t.length!==o.length&&(this.cache=new Float32Array(o.length)),Ae(t,o)};function ou(o){this.id=o,this.seq=[],this.map={}}ou.prototype.setValue=function(o,t,e){const n=this.seq;for(let r=0,s=n.length;r!==s;++r){const l=n[r];l.setValue(o,t[l.id],e)}};const ha=/(\w+)(\])?(\[|\.)?/g;function ih(o,t){o.seq.push(t),o.map[t.id]=t}function _b(o,t,e){const n=o.name,r=n.length;for(ha.lastIndex=0;;){const s=ha.exec(n),l=ha.lastIndex;let h=s[1];const d=s[2]==="]",p=s[3];if(d&&(h=h|0),p===void 0||p==="["&&l+2===r){ih(e,p===void 0?new vb(h,o,t):new su(h,o,t));break}else{let m=e.map[h];m===void 0&&(m=new ou(h),ih(e,m)),e=m}}}function Xn(o,t){this.seq=[],this.map={};const e=o.getProgramParameter(t,35718);for(let n=0;n<e;++n){const r=o.getActiveUniform(t,n),s=o.getUniformLocation(t,r.name);_b(r,s,this)}}Xn.prototype.setValue=function(o,t,e,n){const r=this.map[t];r!==void 0&&r.setValue(o,e,n)};Xn.prototype.setOptional=function(o,t,e){const n=t[e];n!==void 0&&this.setValue(o,e,n)};Xn.upload=function(o,t,e,n){for(let r=0,s=t.length;r!==s;++r){const l=t[r],h=e[l.id];h.needsUpdate!==!1&&l.setValue(o,h.value,n)}};Xn.seqWithValue=function(o,t){const e=[];for(let n=0,r=o.length;n!==r;++n){const s=o[n];s.id in t&&e.push(s)}return e};function rh(o,t,e){const n=o.createShader(t);return o.shaderSource(n,e),o.compileShader(n),n}let xb=0;function bb(o){const t=o.split(`
`);for(let e=0;e<t.length;e++)t[e]=e+1+": "+t[e];return t.join(`
`)}function au(o){switch(o){case en:return["Linear","( value )"];case Ki:return["sRGB","( value )"];default:return console.warn("THREE.WebGLProgram: Unsupported encoding:",o),["Linear","( value )"]}}function sh(o,t,e){const n=o.getShaderParameter(t,35713),r=o.getShaderInfoLog(t).trim();return n&&r===""?"":e.toUpperCase()+`

`+r+`

`+bb(o.getShaderSource(t))}function ai(o,t){const e=au(t);return"vec4 "+o+"( vec4 value ) { return "+e[0]+"ToLinear"+e[1]+"; }"}function yb(o,t){const e=au(t);return"vec4 "+o+"( vec4 value ) { return LinearTo"+e[0]+e[1]+"; }"}function wb(o,t){let e;switch(t){case mm:e="Linear";break;case gm:e="Reinhard";break;case vm:e="OptimizedCineon";break;case _m:e="ACESFilmic";break;case xm:e="Custom";break;default:console.warn("THREE.WebGLProgram: Unsupported toneMapping:",t),e="Linear"}return"vec3 "+o+"( vec3 color ) { return "+e+"ToneMapping( color ); }"}function Mb(o){return[o.extensionDerivatives||o.envMapCubeUV||o.bumpMap||o.tangentSpaceNormalMap||o.clearcoatNormalMap||o.flatShading||o.shaderID==="physical"?"#extension GL_OES_standard_derivatives : enable":"",(o.extensionFragDepth||o.logarithmicDepthBuffer)&&o.rendererExtensionFragDepth?"#extension GL_EXT_frag_depth : enable":"",o.extensionDrawBuffers&&o.rendererExtensionDrawBuffers?"#extension GL_EXT_draw_buffers : require":"",(o.extensionShaderTextureLOD||o.envMap||o.transmission)&&o.rendererExtensionShaderTextureLod?"#extension GL_EXT_shader_texture_lod : enable":""].filter(Nr).join(`
`)}function Sb(o){const t=[];for(const e in o){const n=o[e];n!==!1&&t.push("#define "+e+" "+n)}return t.join(`
`)}function Eb(o,t){const e={},n=o.getProgramParameter(t,35721);for(let r=0;r<n;r++){const s=o.getActiveAttrib(t,r),l=s.name;let h=1;s.type===35674&&(h=2),s.type===35675&&(h=3),s.type===35676&&(h=4),e[l]={type:s.type,location:o.getAttribLocation(t,l),locationSize:h}}return e}function Nr(o){return o!==""}function oh(o,t){return o.replace(/NUM_DIR_LIGHTS/g,t.numDirLights).replace(/NUM_SPOT_LIGHTS/g,t.numSpotLights).replace(/NUM_RECT_AREA_LIGHTS/g,t.numRectAreaLights).replace(/NUM_POINT_LIGHTS/g,t.numPointLights).replace(/NUM_HEMI_LIGHTS/g,t.numHemiLights).replace(/NUM_DIR_LIGHT_SHADOWS/g,t.numDirLightShadows).replace(/NUM_SPOT_LIGHT_SHADOWS/g,t.numSpotLightShadows).replace(/NUM_POINT_LIGHT_SHADOWS/g,t.numPointLightShadows)}function ah(o,t){return o.replace(/NUM_CLIPPING_PLANES/g,t.numClippingPlanes).replace(/UNION_CLIPPING_PLANES/g,t.numClippingPlanes-t.numClipIntersection)}const Tb=/^[ \t]*#include +<([\w\d./]+)>/gm;function Ta(o){return o.replace(Tb,Cb)}function Cb(o,t){const e=jt[t];if(e===void 0)throw new Error("Can not resolve #include <"+t+">");return Ta(e)}const Ab=/#pragma unroll_loop[\s]+?for \( int i \= (\d+)\; i < (\d+)\; i \+\+ \) \{([\s\S]+?)(?=\})\}/g,Pb=/#pragma unroll_loop_start\s+for\s*\(\s*int\s+i\s*=\s*(\d+)\s*;\s*i\s*<\s*(\d+)\s*;\s*i\s*\+\+\s*\)\s*{([\s\S]+?)}\s+#pragma unroll_loop_end/g;function lh(o){return o.replace(Pb,lu).replace(Ab,Lb)}function Lb(o,t,e,n){return console.warn("WebGLProgram: #pragma unroll_loop shader syntax is deprecated. Please use #pragma unroll_loop_start syntax instead."),lu(o,t,e,n)}function lu(o,t,e,n){let r="";for(let s=parseInt(t);s<parseInt(e);s++)r+=n.replace(/\[\s*i\s*\]/g,"[ "+s+" ]").replace(/UNROLLED_LOOP_INDEX/g,s);return r}function ch(o){let t="precision "+o.precision+` float;
precision `+o.precision+" int;";return o.precision==="highp"?t+=`
#define HIGH_PRECISION`:o.precision==="mediump"?t+=`
#define MEDIUM_PRECISION`:o.precision==="lowp"&&(t+=`
#define LOW_PRECISION`),t}function Rb(o){let t="SHADOWMAP_TYPE_BASIC";return o.shadowMapType===zh?t="SHADOWMAP_TYPE_PCF":o.shadowMapType===Xf?t="SHADOWMAP_TYPE_PCF_SOFT":o.shadowMapType===Ir&&(t="SHADOWMAP_TYPE_VSM"),t}function Db(o){let t="ENVMAP_TYPE_CUBE";if(o.envMap)switch(o.envMapMode){case jr:case Xr:t="ENVMAP_TYPE_CUBE";break;case Ks:case Ia:t="ENVMAP_TYPE_CUBE_UV";break}return t}function Ib(o){let t="ENVMAP_MODE_REFLECTION";if(o.envMap)switch(o.envMapMode){case Xr:case Ia:t="ENVMAP_MODE_REFRACTION";break}return t}function Nb(o){let t="ENVMAP_BLENDING_NONE";if(o.envMap)switch(o.combine){case Zs:t="ENVMAP_BLENDING_MULTIPLY";break;case pm:t="ENVMAP_BLENDING_MIX";break;case fm:t="ENVMAP_BLENDING_ADD";break}return t}function Fb(o,t,e,n){const r=o.getContext(),s=e.defines;let l=e.vertexShader,h=e.fragmentShader;const d=Rb(e),p=Db(e),f=Ib(e),m=Nb(e),g=e.isWebGL2?"":Mb(e),_=Sb(s),y=r.createProgram();let w,S,x=e.glslVersion?"#version "+e.glslVersion+`
`:"";e.isRawShaderMaterial?(w=[_].filter(Nr).join(`
`),w.length>0&&(w+=`
`),S=[g,_].filter(Nr).join(`
`),S.length>0&&(S+=`
`)):(w=[ch(e),"#define SHADER_NAME "+e.shaderName,_,e.instancing?"#define USE_INSTANCING":"",e.instancingColor?"#define USE_INSTANCING_COLOR":"",e.supportsVertexTextures?"#define VERTEX_TEXTURES":"","#define MAX_BONES "+e.maxBones,e.useFog&&e.fog?"#define USE_FOG":"",e.useFog&&e.fogExp2?"#define FOG_EXP2":"",e.map?"#define USE_MAP":"",e.envMap?"#define USE_ENVMAP":"",e.envMap?"#define "+f:"",e.lightMap?"#define USE_LIGHTMAP":"",e.aoMap?"#define USE_AOMAP":"",e.emissiveMap?"#define USE_EMISSIVEMAP":"",e.bumpMap?"#define USE_BUMPMAP":"",e.normalMap?"#define USE_NORMALMAP":"",e.normalMap&&e.objectSpaceNormalMap?"#define OBJECTSPACE_NORMALMAP":"",e.normalMap&&e.tangentSpaceNormalMap?"#define TANGENTSPACE_NORMALMAP":"",e.clearcoatMap?"#define USE_CLEARCOATMAP":"",e.clearcoatRoughnessMap?"#define USE_CLEARCOAT_ROUGHNESSMAP":"",e.clearcoatNormalMap?"#define USE_CLEARCOAT_NORMALMAP":"",e.displacementMap&&e.supportsVertexTextures?"#define USE_DISPLACEMENTMAP":"",e.specularMap?"#define USE_SPECULARMAP":"",e.specularIntensityMap?"#define USE_SPECULARINTENSITYMAP":"",e.specularColorMap?"#define USE_SPECULARCOLORMAP":"",e.roughnessMap?"#define USE_ROUGHNESSMAP":"",e.metalnessMap?"#define USE_METALNESSMAP":"",e.alphaMap?"#define USE_ALPHAMAP":"",e.transmission?"#define USE_TRANSMISSION":"",e.transmissionMap?"#define USE_TRANSMISSIONMAP":"",e.thicknessMap?"#define USE_THICKNESSMAP":"",e.sheenColorMap?"#define USE_SHEENCOLORMAP":"",e.sheenRoughnessMap?"#define USE_SHEENROUGHNESSMAP":"",e.vertexTangents?"#define USE_TANGENT":"",e.vertexColors?"#define USE_COLOR":"",e.vertexAlphas?"#define USE_COLOR_ALPHA":"",e.vertexUvs?"#define USE_UV":"",e.uvsVertexOnly?"#define UVS_VERTEX_ONLY":"",e.flatShading?"#define FLAT_SHADED":"",e.skinning?"#define USE_SKINNING":"",e.useVertexTexture?"#define BONE_TEXTURE":"",e.morphTargets?"#define USE_MORPHTARGETS":"",e.morphNormals&&e.flatShading===!1?"#define USE_MORPHNORMALS":"",e.morphTargets&&e.isWebGL2?"#define MORPHTARGETS_TEXTURE":"",e.morphTargets&&e.isWebGL2?"#define MORPHTARGETS_COUNT "+e.morphTargetsCount:"",e.doubleSided?"#define DOUBLE_SIDED":"",e.flipSided?"#define FLIP_SIDED":"",e.shadowMapEnabled?"#define USE_SHADOWMAP":"",e.shadowMapEnabled?"#define "+d:"",e.sizeAttenuation?"#define USE_SIZEATTENUATION":"",e.logarithmicDepthBuffer?"#define USE_LOGDEPTHBUF":"",e.logarithmicDepthBuffer&&e.rendererExtensionFragDepth?"#define USE_LOGDEPTHBUF_EXT":"","uniform mat4 modelMatrix;","uniform mat4 modelViewMatrix;","uniform mat4 projectionMatrix;","uniform mat4 viewMatrix;","uniform mat3 normalMatrix;","uniform vec3 cameraPosition;","uniform bool isOrthographic;","#ifdef USE_INSTANCING","	attribute mat4 instanceMatrix;","#endif","#ifdef USE_INSTANCING_COLOR","	attribute vec3 instanceColor;","#endif","attribute vec3 position;","attribute vec3 normal;","attribute vec2 uv;","#ifdef USE_TANGENT","	attribute vec4 tangent;","#endif","#if defined( USE_COLOR_ALPHA )","	attribute vec4 color;","#elif defined( USE_COLOR )","	attribute vec3 color;","#endif","#if ( defined( USE_MORPHTARGETS ) && ! defined( MORPHTARGETS_TEXTURE ) )","	attribute vec3 morphTarget0;","	attribute vec3 morphTarget1;","	attribute vec3 morphTarget2;","	attribute vec3 morphTarget3;","	#ifdef USE_MORPHNORMALS","		attribute vec3 morphNormal0;","		attribute vec3 morphNormal1;","		attribute vec3 morphNormal2;","		attribute vec3 morphNormal3;","	#else","		attribute vec3 morphTarget4;","		attribute vec3 morphTarget5;","		attribute vec3 morphTarget6;","		attribute vec3 morphTarget7;","	#endif","#endif","#ifdef USE_SKINNING","	attribute vec4 skinIndex;","	attribute vec4 skinWeight;","#endif",`
`].filter(Nr).join(`
`),S=[g,ch(e),"#define SHADER_NAME "+e.shaderName,_,e.useFog&&e.fog?"#define USE_FOG":"",e.useFog&&e.fogExp2?"#define FOG_EXP2":"",e.map?"#define USE_MAP":"",e.matcap?"#define USE_MATCAP":"",e.envMap?"#define USE_ENVMAP":"",e.envMap?"#define "+p:"",e.envMap?"#define "+f:"",e.envMap?"#define "+m:"",e.lightMap?"#define USE_LIGHTMAP":"",e.aoMap?"#define USE_AOMAP":"",e.emissiveMap?"#define USE_EMISSIVEMAP":"",e.bumpMap?"#define USE_BUMPMAP":"",e.normalMap?"#define USE_NORMALMAP":"",e.normalMap&&e.objectSpaceNormalMap?"#define OBJECTSPACE_NORMALMAP":"",e.normalMap&&e.tangentSpaceNormalMap?"#define TANGENTSPACE_NORMALMAP":"",e.clearcoat?"#define USE_CLEARCOAT":"",e.clearcoatMap?"#define USE_CLEARCOATMAP":"",e.clearcoatRoughnessMap?"#define USE_CLEARCOAT_ROUGHNESSMAP":"",e.clearcoatNormalMap?"#define USE_CLEARCOAT_NORMALMAP":"",e.specularMap?"#define USE_SPECULARMAP":"",e.specularIntensityMap?"#define USE_SPECULARINTENSITYMAP":"",e.specularColorMap?"#define USE_SPECULARCOLORMAP":"",e.roughnessMap?"#define USE_ROUGHNESSMAP":"",e.metalnessMap?"#define USE_METALNESSMAP":"",e.alphaMap?"#define USE_ALPHAMAP":"",e.alphaTest?"#define USE_ALPHATEST":"",e.sheen?"#define USE_SHEEN":"",e.sheenColorMap?"#define USE_SHEENCOLORMAP":"",e.sheenRoughnessMap?"#define USE_SHEENROUGHNESSMAP":"",e.transmission?"#define USE_TRANSMISSION":"",e.transmissionMap?"#define USE_TRANSMISSIONMAP":"",e.thicknessMap?"#define USE_THICKNESSMAP":"",e.vertexTangents?"#define USE_TANGENT":"",e.vertexColors||e.instancingColor?"#define USE_COLOR":"",e.vertexAlphas?"#define USE_COLOR_ALPHA":"",e.vertexUvs?"#define USE_UV":"",e.uvsVertexOnly?"#define UVS_VERTEX_ONLY":"",e.gradientMap?"#define USE_GRADIENTMAP":"",e.flatShading?"#define FLAT_SHADED":"",e.doubleSided?"#define DOUBLE_SIDED":"",e.flipSided?"#define FLIP_SIDED":"",e.shadowMapEnabled?"#define USE_SHADOWMAP":"",e.shadowMapEnabled?"#define "+d:"",e.premultipliedAlpha?"#define PREMULTIPLIED_ALPHA":"",e.physicallyCorrectLights?"#define PHYSICALLY_CORRECT_LIGHTS":"",e.logarithmicDepthBuffer?"#define USE_LOGDEPTHBUF":"",e.logarithmicDepthBuffer&&e.rendererExtensionFragDepth?"#define USE_LOGDEPTHBUF_EXT":"",(e.extensionShaderTextureLOD||e.envMap)&&e.rendererExtensionShaderTextureLod?"#define TEXTURE_LOD_EXT":"","uniform mat4 viewMatrix;","uniform vec3 cameraPosition;","uniform bool isOrthographic;",e.toneMapping!==qn?"#define TONE_MAPPING":"",e.toneMapping!==qn?jt.tonemapping_pars_fragment:"",e.toneMapping!==qn?wb("toneMapping",e.toneMapping):"",e.dithering?"#define DITHERING":"",e.format===hi?"#define OPAQUE":"",jt.encodings_pars_fragment,e.map?ai("mapTexelToLinear",e.mapEncoding):"",e.matcap?ai("matcapTexelToLinear",e.matcapEncoding):"",e.envMap?ai("envMapTexelToLinear",e.envMapEncoding):"",e.emissiveMap?ai("emissiveMapTexelToLinear",e.emissiveMapEncoding):"",e.specularColorMap?ai("specularColorMapTexelToLinear",e.specularColorMapEncoding):"",e.sheenColorMap?ai("sheenColorMapTexelToLinear",e.sheenColorMapEncoding):"",e.lightMap?ai("lightMapTexelToLinear",e.lightMapEncoding):"",yb("linearToOutputTexel",e.outputEncoding),e.depthPacking?"#define DEPTH_PACKING "+e.depthPacking:"",`
`].filter(Nr).join(`
`)),l=Ta(l),l=oh(l,e),l=ah(l,e),h=Ta(h),h=oh(h,e),h=ah(h,e),l=lh(l),h=lh(h),e.isWebGL2&&e.isRawShaderMaterial!==!0&&(x=`#version 300 es
`,w=["precision mediump sampler2DArray;","#define attribute in","#define varying out","#define texture2D texture"].join(`
`)+`
`+w,S=["#define varying in",e.glslVersion===Dc?"":"layout(location = 0) out highp vec4 pc_fragColor;",e.glslVersion===Dc?"":"#define gl_FragColor pc_fragColor","#define gl_FragDepthEXT gl_FragDepth","#define texture2D texture","#define textureCube texture","#define texture2DProj textureProj","#define texture2DLodEXT textureLod","#define texture2DProjLodEXT textureProjLod","#define textureCubeLodEXT textureLod","#define texture2DGradEXT textureGrad","#define texture2DProjGradEXT textureProjGrad","#define textureCubeGradEXT textureGrad"].join(`
`)+`
`+S);const v=x+w+l,N=x+S+h,M=rh(r,35633,v),R=rh(r,35632,N);if(r.attachShader(y,M),r.attachShader(y,R),e.index0AttributeName!==void 0?r.bindAttribLocation(y,0,e.index0AttributeName):e.morphTargets===!0&&r.bindAttribLocation(y,0,"position"),r.linkProgram(y),o.debug.checkShaderErrors){const j=r.getProgramInfoLog(y).trim(),ot=r.getShaderInfoLog(M).trim(),Y=r.getShaderInfoLog(R).trim();let V=!0,C=!0;if(r.getProgramParameter(y,35714)===!1){V=!1;const A=sh(r,M,"vertex"),H=sh(r,R,"fragment");console.error("THREE.WebGLProgram: Shader Error "+r.getError()+" - VALIDATE_STATUS "+r.getProgramParameter(y,35715)+`

Program Info Log: `+j+`
`+A+`
`+H)}else j!==""?console.warn("THREE.WebGLProgram: Program Info Log:",j):(ot===""||Y==="")&&(C=!1);C&&(this.diagnostics={runnable:V,programLog:j,vertexShader:{log:ot,prefix:w},fragmentShader:{log:Y,prefix:S}})}r.deleteShader(M),r.deleteShader(R);let F;this.getUniforms=function(){return F===void 0&&(F=new Xn(r,y)),F};let k;return this.getAttributes=function(){return k===void 0&&(k=Eb(r,y)),k},this.destroy=function(){n.releaseStatesOfProgram(this),r.deleteProgram(y),this.program=void 0},this.name=e.shaderName,this.id=xb++,this.cacheKey=t,this.usedTimes=1,this.program=y,this.vertexShader=M,this.fragmentShader=R,this}let kb=0;class Vb{constructor(){this.shaderCache=new Map,this.materialCache=new Map}update(t){const e=t.vertexShader,n=t.fragmentShader,r=this._getShaderStage(e),s=this._getShaderStage(n),l=this._getShaderCacheForMaterial(t);return l.has(r)===!1&&(l.add(r),r.usedTimes++),l.has(s)===!1&&(l.add(s),s.usedTimes++),this}remove(t){const e=this.materialCache.get(t);for(const n of e)n.usedTimes--,n.usedTimes===0&&this.shaderCache.delete(n);return this.materialCache.delete(t),this}getVertexShaderID(t){return this._getShaderStage(t.vertexShader).id}getFragmentShaderID(t){return this._getShaderStage(t.fragmentShader).id}dispose(){this.shaderCache.clear(),this.materialCache.clear()}_getShaderCacheForMaterial(t){const e=this.materialCache;return e.has(t)===!1&&e.set(t,new Set),e.get(t)}_getShaderStage(t){const e=this.shaderCache;if(e.has(t)===!1){const n=new Bb;e.set(t,n)}return e.get(t)}}class Bb{constructor(){this.id=kb++,this.usedTimes=0}}function zb(o,t,e,n,r,s,l){const h=new jh,d=new Vb,p=[],f=r.isWebGL2,m=r.logarithmicDepthBuffer,g=r.floatVertexTextures,_=r.maxVertexUniforms,y=r.vertexTextures;let w=r.precision;const S={MeshDepthMaterial:"depth",MeshDistanceMaterial:"distanceRGBA",MeshNormalMaterial:"normal",MeshBasicMaterial:"basic",MeshLambertMaterial:"lambert",MeshPhongMaterial:"phong",MeshToonMaterial:"toon",MeshStandardMaterial:"physical",MeshPhysicalMaterial:"physical",MeshMatcapMaterial:"matcap",LineBasicMaterial:"basic",LineDashedMaterial:"dashed",PointsMaterial:"points",ShadowMaterial:"shadow",SpriteMaterial:"sprite"};function x(C){const H=C.skeleton.bones;if(g)return 1024;{const O=Math.floor((_-20)/4),U=Math.min(O,H.length);return U<H.length?(console.warn("THREE.WebGLRenderer: Skeleton has "+H.length+" bones. This GPU supports "+U+"."),0):U}}function v(C){let A;return C&&C.isTexture?A=C.encoding:C&&C.isWebGLRenderTarget?(console.warn("THREE.WebGLPrograms.getTextureEncodingFromMap: don't use render targets as textures. Use their .texture property instead."),A=C.texture.encoding):A=en,f&&C&&C.isTexture&&C.format===be&&C.type===En&&C.encoding===Ki&&(A=en),A}function N(C,A,H,q,O){const U=q.fog,X=C.isMeshStandardMaterial?q.environment:null,_t=(C.isMeshStandardMaterial?e:t).get(C.envMap||X),J=S[C.type],Z=O.isSkinnedMesh?x(O):0;C.precision!==null&&(w=r.getMaxPrecision(C.precision),w!==C.precision&&console.warn("THREE.WebGLProgram.getParameters:",C.precision,"not supported, using",w,"instead."));let pt,vt,at,Tt;if(J){const Mt=ln[J];pt=Mt.vertexShader,vt=Mt.fragmentShader}else pt=C.vertexShader,vt=C.fragmentShader,d.update(C),at=d.getVertexShaderID(C),Tt=d.getFragmentShaderID(C);const Q=o.getRenderTarget(),zt=C.alphaTest>0,wt=C.clearcoat>0;return{isWebGL2:f,shaderID:J,shaderName:C.type,vertexShader:pt,fragmentShader:vt,defines:C.defines,customVertexShaderID:at,customFragmentShaderID:Tt,isRawShaderMaterial:C.isRawShaderMaterial===!0,glslVersion:C.glslVersion,precision:w,instancing:O.isInstancedMesh===!0,instancingColor:O.isInstancedMesh===!0&&O.instanceColor!==null,supportsVertexTextures:y,outputEncoding:Q!==null?v(Q.texture):o.outputEncoding,map:!!C.map,mapEncoding:v(C.map),matcap:!!C.matcap,matcapEncoding:v(C.matcap),envMap:!!_t,envMapMode:_t&&_t.mapping,envMapEncoding:v(_t),envMapCubeUV:!!_t&&(_t.mapping===Ks||_t.mapping===Ia),lightMap:!!C.lightMap,lightMapEncoding:v(C.lightMap),aoMap:!!C.aoMap,emissiveMap:!!C.emissiveMap,emissiveMapEncoding:v(C.emissiveMap),bumpMap:!!C.bumpMap,normalMap:!!C.normalMap,objectSpaceNormalMap:C.normalMapType===_g,tangentSpaceNormalMap:C.normalMapType===Qi,clearcoat:wt,clearcoatMap:wt&&!!C.clearcoatMap,clearcoatRoughnessMap:wt&&!!C.clearcoatRoughnessMap,clearcoatNormalMap:wt&&!!C.clearcoatNormalMap,displacementMap:!!C.displacementMap,roughnessMap:!!C.roughnessMap,metalnessMap:!!C.metalnessMap,specularMap:!!C.specularMap,specularIntensityMap:!!C.specularIntensityMap,specularColorMap:!!C.specularColorMap,specularColorMapEncoding:v(C.specularColorMap),alphaMap:!!C.alphaMap,alphaTest:zt,gradientMap:!!C.gradientMap,sheen:C.sheen>0,sheenColorMap:!!C.sheenColorMap,sheenColorMapEncoding:v(C.sheenColorMap),sheenRoughnessMap:!!C.sheenRoughnessMap,transmission:C.transmission>0,transmissionMap:!!C.transmissionMap,thicknessMap:!!C.thicknessMap,combine:C.combine,vertexTangents:!!C.normalMap&&!!O.geometry&&!!O.geometry.attributes.tangent,vertexColors:C.vertexColors,vertexAlphas:C.vertexColors===!0&&!!O.geometry&&!!O.geometry.attributes.color&&O.geometry.attributes.color.itemSize===4,vertexUvs:!!C.map||!!C.bumpMap||!!C.normalMap||!!C.specularMap||!!C.alphaMap||!!C.emissiveMap||!!C.roughnessMap||!!C.metalnessMap||!!C.clearcoatMap||!!C.clearcoatRoughnessMap||!!C.clearcoatNormalMap||!!C.displacementMap||!!C.transmissionMap||!!C.thicknessMap||!!C.specularIntensityMap||!!C.specularColorMap||!!C.sheenColorMap||!!C.sheenRoughnessMap,uvsVertexOnly:!(!!C.map||!!C.bumpMap||!!C.normalMap||!!C.specularMap||!!C.alphaMap||!!C.emissiveMap||!!C.roughnessMap||!!C.metalnessMap||!!C.clearcoatNormalMap||C.transmission>0||!!C.transmissionMap||!!C.thicknessMap||!!C.specularIntensityMap||!!C.specularColorMap||C.sheen>0||!!C.sheenColorMap||!!C.sheenRoughnessMap)&&!!C.displacementMap,fog:!!U,useFog:C.fog,fogExp2:U&&U.isFogExp2,flatShading:!!C.flatShading,sizeAttenuation:C.sizeAttenuation,logarithmicDepthBuffer:m,skinning:O.isSkinnedMesh===!0&&Z>0,maxBones:Z,useVertexTexture:g,morphTargets:!!O.geometry&&!!O.geometry.morphAttributes.position,morphNormals:!!O.geometry&&!!O.geometry.morphAttributes.normal,morphTargetsCount:!!O.geometry&&!!O.geometry.morphAttributes.position?O.geometry.morphAttributes.position.length:0,numDirLights:A.directional.length,numPointLights:A.point.length,numSpotLights:A.spot.length,numRectAreaLights:A.rectArea.length,numHemiLights:A.hemi.length,numDirLightShadows:A.directionalShadowMap.length,numPointLightShadows:A.pointShadowMap.length,numSpotLightShadows:A.spotShadowMap.length,numClippingPlanes:l.numPlanes,numClipIntersection:l.numIntersection,format:C.format,dithering:C.dithering,shadowMapEnabled:o.shadowMap.enabled&&H.length>0,shadowMapType:o.shadowMap.type,toneMapping:C.toneMapped?o.toneMapping:qn,physicallyCorrectLights:o.physicallyCorrectLights,premultipliedAlpha:C.premultipliedAlpha,doubleSided:C.side===$i,flipSided:C.side===ge,depthPacking:C.depthPacking!==void 0?C.depthPacking:!1,index0AttributeName:C.index0AttributeName,extensionDerivatives:C.extensions&&C.extensions.derivatives,extensionFragDepth:C.extensions&&C.extensions.fragDepth,extensionDrawBuffers:C.extensions&&C.extensions.drawBuffers,extensionShaderTextureLOD:C.extensions&&C.extensions.shaderTextureLOD,rendererExtensionFragDepth:f||n.has("EXT_frag_depth"),rendererExtensionDrawBuffers:f||n.has("WEBGL_draw_buffers"),rendererExtensionShaderTextureLod:f||n.has("EXT_shader_texture_lod"),customProgramCacheKey:C.customProgramCacheKey()}}function M(C){const A=[];if(C.shaderID?A.push(C.shaderID):(A.push(C.customVertexShaderID),A.push(C.customFragmentShaderID)),C.defines!==void 0)for(const H in C.defines)A.push(H),A.push(C.defines[H]);return C.isRawShaderMaterial===!1&&(R(A,C),F(A,C),A.push(o.outputEncoding)),A.push(C.customProgramCacheKey),A.join()}function R(C,A){C.push(A.precision),C.push(A.outputEncoding),C.push(A.mapEncoding),C.push(A.matcapEncoding),C.push(A.envMapMode),C.push(A.envMapEncoding),C.push(A.lightMapEncoding),C.push(A.emissiveMapEncoding),C.push(A.combine),C.push(A.vertexUvs),C.push(A.fogExp2),C.push(A.sizeAttenuation),C.push(A.maxBones),C.push(A.morphTargetsCount),C.push(A.numDirLights),C.push(A.numPointLights),C.push(A.numSpotLights),C.push(A.numHemiLights),C.push(A.numRectAreaLights),C.push(A.numDirLightShadows),C.push(A.numPointLightShadows),C.push(A.numSpotLightShadows),C.push(A.shadowMapType),C.push(A.toneMapping),C.push(A.numClippingPlanes),C.push(A.numClipIntersection),C.push(A.format),C.push(A.specularColorMapEncoding),C.push(A.sheenColorMapEncoding)}function F(C,A){h.disableAll(),A.isWebGL2&&h.enable(0),A.supportsVertexTextures&&h.enable(1),A.instancing&&h.enable(2),A.instancingColor&&h.enable(3),A.map&&h.enable(4),A.matcap&&h.enable(5),A.envMap&&h.enable(6),A.envMapCubeUV&&h.enable(7),A.lightMap&&h.enable(8),A.aoMap&&h.enable(9),A.emissiveMap&&h.enable(10),A.bumpMap&&h.enable(11),A.normalMap&&h.enable(12),A.objectSpaceNormalMap&&h.enable(13),A.tangentSpaceNormalMap&&h.enable(14),A.clearcoat&&h.enable(15),A.clearcoatMap&&h.enable(16),A.clearcoatRoughnessMap&&h.enable(17),A.clearcoatNormalMap&&h.enable(18),A.displacementMap&&h.enable(19),A.specularMap&&h.enable(20),A.roughnessMap&&h.enable(21),A.metalnessMap&&h.enable(22),A.gradientMap&&h.enable(23),A.alphaMap&&h.enable(24),A.alphaTest&&h.enable(25),A.vertexColors&&h.enable(26),A.vertexAlphas&&h.enable(27),A.vertexUvs&&h.enable(28),A.vertexTangents&&h.enable(29),A.uvsVertexOnly&&h.enable(30),A.fog&&h.enable(31),C.push(h.mask),h.disableAll(),A.useFog&&h.enable(0),A.flatShading&&h.enable(1),A.logarithmicDepthBuffer&&h.enable(2),A.skinning&&h.enable(3),A.useVertexTexture&&h.enable(4),A.morphTargets&&h.enable(5),A.morphNormals&&h.enable(6),A.premultipliedAlpha&&h.enable(7),A.shadowMapEnabled&&h.enable(8),A.physicallyCorrectLights&&h.enable(9),A.doubleSided&&h.enable(10),A.flipSided&&h.enable(11),A.depthPacking&&h.enable(12),A.dithering&&h.enable(13),A.specularIntensityMap&&h.enable(14),A.specularColorMap&&h.enable(15),A.transmission&&h.enable(16),A.transmissionMap&&h.enable(17),A.thicknessMap&&h.enable(18),A.sheen&&h.enable(19),A.sheenColorMap&&h.enable(20),A.sheenRoughnessMap&&h.enable(21),C.push(h.mask)}function k(C){const A=S[C.type];let H;if(A){const q=ln[A];H=Fg.clone(q.uniforms)}else H=C.uniforms;return H}function j(C,A){let H;for(let q=0,O=p.length;q<O;q++){const U=p[q];if(U.cacheKey===A){H=U,++H.usedTimes;break}}return H===void 0&&(H=new Fb(o,A,C,s),p.push(H)),H}function ot(C){if(--C.usedTimes===0){const A=p.indexOf(C);p[A]=p[p.length-1],p.pop(),C.destroy()}}function Y(C){d.remove(C)}function V(){d.dispose()}return{getParameters:N,getProgramCacheKey:M,getUniforms:k,acquireProgram:j,releaseProgram:ot,releaseShaderCache:Y,programs:p,dispose:V}}function Ob(){let o=new WeakMap;function t(s){let l=o.get(s);return l===void 0&&(l={},o.set(s,l)),l}function e(s){o.delete(s)}function n(s,l,h){o.get(s)[l]=h}function r(){o=new WeakMap}return{get:t,remove:e,update:n,dispose:r}}function Ub(o,t){return o.groupOrder!==t.groupOrder?o.groupOrder-t.groupOrder:o.renderOrder!==t.renderOrder?o.renderOrder-t.renderOrder:o.material.id!==t.material.id?o.material.id-t.material.id:o.z!==t.z?o.z-t.z:o.id-t.id}function hh(o,t){return o.groupOrder!==t.groupOrder?o.groupOrder-t.groupOrder:o.renderOrder!==t.renderOrder?o.renderOrder-t.renderOrder:o.z!==t.z?t.z-o.z:o.id-t.id}function uh(){const o=[];let t=0;const e=[],n=[],r=[];function s(){t=0,e.length=0,n.length=0,r.length=0}function l(m,g,_,y,w,S){let x=o[t];return x===void 0?(x={id:m.id,object:m,geometry:g,material:_,groupOrder:y,renderOrder:m.renderOrder,z:w,group:S},o[t]=x):(x.id=m.id,x.object=m,x.geometry=g,x.material=_,x.groupOrder=y,x.renderOrder=m.renderOrder,x.z=w,x.group=S),t++,x}function h(m,g,_,y,w,S){const x=l(m,g,_,y,w,S);_.transmission>0?n.push(x):_.transparent===!0?r.push(x):e.push(x)}function d(m,g,_,y,w,S){const x=l(m,g,_,y,w,S);_.transmission>0?n.unshift(x):_.transparent===!0?r.unshift(x):e.unshift(x)}function p(m,g){e.length>1&&e.sort(m||Ub),n.length>1&&n.sort(g||hh),r.length>1&&r.sort(g||hh)}function f(){for(let m=t,g=o.length;m<g;m++){const _=o[m];if(_.id===null)break;_.id=null,_.object=null,_.geometry=null,_.material=null,_.group=null}}return{opaque:e,transmissive:n,transparent:r,init:s,push:h,unshift:d,finish:f,sort:p}}function Hb(){let o=new WeakMap;function t(n,r){let s;return o.has(n)===!1?(s=new uh,o.set(n,[s])):r>=o.get(n).length?(s=new uh,o.get(n).push(s)):s=o.get(n)[r],s}function e(){o=new WeakMap}return{get:t,dispose:e}}function Gb(){const o={};return{get:function(t){if(o[t.id]!==void 0)return o[t.id];let e;switch(t.type){case"DirectionalLight":e={direction:new D,color:new Et};break;case"SpotLight":e={position:new D,direction:new D,color:new Et,distance:0,coneCos:0,penumbraCos:0,decay:0};break;case"PointLight":e={position:new D,color:new Et,distance:0,decay:0};break;case"HemisphereLight":e={direction:new D,skyColor:new Et,groundColor:new Et};break;case"RectAreaLight":e={color:new Et,position:new D,halfWidth:new D,halfHeight:new D};break}return o[t.id]=e,e}}}function Wb(){const o={};return{get:function(t){if(o[t.id]!==void 0)return o[t.id];let e;switch(t.type){case"DirectionalLight":e={shadowBias:0,shadowNormalBias:0,shadowRadius:1,shadowMapSize:new st};break;case"SpotLight":e={shadowBias:0,shadowNormalBias:0,shadowRadius:1,shadowMapSize:new st};break;case"PointLight":e={shadowBias:0,shadowNormalBias:0,shadowRadius:1,shadowMapSize:new st,shadowCameraNear:1,shadowCameraFar:1e3};break}return o[t.id]=e,e}}}let qb=0;function jb(o,t){return(t.castShadow?1:0)-(o.castShadow?1:0)}function Xb(o,t){const e=new Gb,n=Wb(),r={version:0,hash:{directionalLength:-1,pointLength:-1,spotLength:-1,rectAreaLength:-1,hemiLength:-1,numDirectionalShadows:-1,numPointShadows:-1,numSpotShadows:-1},ambient:[0,0,0],probe:[],directional:[],directionalShadow:[],directionalShadowMap:[],directionalShadowMatrix:[],spot:[],spotShadow:[],spotShadowMap:[],spotShadowMatrix:[],rectArea:[],rectAreaLTC1:null,rectAreaLTC2:null,point:[],pointShadow:[],pointShadowMap:[],pointShadowMatrix:[],hemi:[]};for(let f=0;f<9;f++)r.probe.push(new D);const s=new D,l=new At,h=new At;function d(f,m){let g=0,_=0,y=0;for(let ot=0;ot<9;ot++)r.probe[ot].set(0,0,0);let w=0,S=0,x=0,v=0,N=0,M=0,R=0,F=0;f.sort(jb);const k=m!==!0?Math.PI:1;for(let ot=0,Y=f.length;ot<Y;ot++){const V=f[ot],C=V.color,A=V.intensity,H=V.distance,q=V.shadow&&V.shadow.map?V.shadow.map.texture:null;if(V.isAmbientLight)g+=C.r*A*k,_+=C.g*A*k,y+=C.b*A*k;else if(V.isLightProbe)for(let O=0;O<9;O++)r.probe[O].addScaledVector(V.sh.coefficients[O],A);else if(V.isDirectionalLight){const O=e.get(V);if(O.color.copy(V.color).multiplyScalar(V.intensity*k),V.castShadow){const U=V.shadow,X=n.get(V);X.shadowBias=U.bias,X.shadowNormalBias=U.normalBias,X.shadowRadius=U.radius,X.shadowMapSize=U.mapSize,r.directionalShadow[w]=X,r.directionalShadowMap[w]=q,r.directionalShadowMatrix[w]=V.shadow.matrix,M++}r.directional[w]=O,w++}else if(V.isSpotLight){const O=e.get(V);if(O.position.setFromMatrixPosition(V.matrixWorld),O.color.copy(C).multiplyScalar(A*k),O.distance=H,O.coneCos=Math.cos(V.angle),O.penumbraCos=Math.cos(V.angle*(1-V.penumbra)),O.decay=V.decay,V.castShadow){const U=V.shadow,X=n.get(V);X.shadowBias=U.bias,X.shadowNormalBias=U.normalBias,X.shadowRadius=U.radius,X.shadowMapSize=U.mapSize,r.spotShadow[x]=X,r.spotShadowMap[x]=q,r.spotShadowMatrix[x]=V.shadow.matrix,F++}r.spot[x]=O,x++}else if(V.isRectAreaLight){const O=e.get(V);O.color.copy(C).multiplyScalar(A),O.halfWidth.set(V.width*.5,0,0),O.halfHeight.set(0,V.height*.5,0),r.rectArea[v]=O,v++}else if(V.isPointLight){const O=e.get(V);if(O.color.copy(V.color).multiplyScalar(V.intensity*k),O.distance=V.distance,O.decay=V.decay,V.castShadow){const U=V.shadow,X=n.get(V);X.shadowBias=U.bias,X.shadowNormalBias=U.normalBias,X.shadowRadius=U.radius,X.shadowMapSize=U.mapSize,X.shadowCameraNear=U.camera.near,X.shadowCameraFar=U.camera.far,r.pointShadow[S]=X,r.pointShadowMap[S]=q,r.pointShadowMatrix[S]=V.shadow.matrix,R++}r.point[S]=O,S++}else if(V.isHemisphereLight){const O=e.get(V);O.skyColor.copy(V.color).multiplyScalar(A*k),O.groundColor.copy(V.groundColor).multiplyScalar(A*k),r.hemi[N]=O,N++}}v>0&&(t.isWebGL2||o.has("OES_texture_float_linear")===!0?(r.rectAreaLTC1=gt.LTC_FLOAT_1,r.rectAreaLTC2=gt.LTC_FLOAT_2):o.has("OES_texture_half_float_linear")===!0?(r.rectAreaLTC1=gt.LTC_HALF_1,r.rectAreaLTC2=gt.LTC_HALF_2):console.error("THREE.WebGLRenderer: Unable to use RectAreaLight. Missing WebGL extensions.")),r.ambient[0]=g,r.ambient[1]=_,r.ambient[2]=y;const j=r.hash;(j.directionalLength!==w||j.pointLength!==S||j.spotLength!==x||j.rectAreaLength!==v||j.hemiLength!==N||j.numDirectionalShadows!==M||j.numPointShadows!==R||j.numSpotShadows!==F)&&(r.directional.length=w,r.spot.length=x,r.rectArea.length=v,r.point.length=S,r.hemi.length=N,r.directionalShadow.length=M,r.directionalShadowMap.length=M,r.pointShadow.length=R,r.pointShadowMap.length=R,r.spotShadow.length=F,r.spotShadowMap.length=F,r.directionalShadowMatrix.length=M,r.pointShadowMatrix.length=R,r.spotShadowMatrix.length=F,j.directionalLength=w,j.pointLength=S,j.spotLength=x,j.rectAreaLength=v,j.hemiLength=N,j.numDirectionalShadows=M,j.numPointShadows=R,j.numSpotShadows=F,r.version=qb++)}function p(f,m){let g=0,_=0,y=0,w=0,S=0;const x=m.matrixWorldInverse;for(let v=0,N=f.length;v<N;v++){const M=f[v];if(M.isDirectionalLight){const R=r.directional[g];R.direction.setFromMatrixPosition(M.matrixWorld),s.setFromMatrixPosition(M.target.matrixWorld),R.direction.sub(s),R.direction.transformDirection(x),g++}else if(M.isSpotLight){const R=r.spot[y];R.position.setFromMatrixPosition(M.matrixWorld),R.position.applyMatrix4(x),R.direction.setFromMatrixPosition(M.matrixWorld),s.setFromMatrixPosition(M.target.matrixWorld),R.direction.sub(s),R.direction.transformDirection(x),y++}else if(M.isRectAreaLight){const R=r.rectArea[w];R.position.setFromMatrixPosition(M.matrixWorld),R.position.applyMatrix4(x),h.identity(),l.copy(M.matrixWorld),l.premultiply(x),h.extractRotation(l),R.halfWidth.set(M.width*.5,0,0),R.halfHeight.set(0,M.height*.5,0),R.halfWidth.applyMatrix4(h),R.halfHeight.applyMatrix4(h),w++}else if(M.isPointLight){const R=r.point[_];R.position.setFromMatrixPosition(M.matrixWorld),R.position.applyMatrix4(x),_++}else if(M.isHemisphereLight){const R=r.hemi[S];R.direction.setFromMatrixPosition(M.matrixWorld),R.direction.transformDirection(x),R.direction.normalize(),S++}}}return{setup:d,setupView:p,state:r}}function dh(o,t){const e=new Xb(o,t),n=[],r=[];function s(){n.length=0,r.length=0}function l(m){n.push(m)}function h(m){r.push(m)}function d(m){e.setup(n,m)}function p(m){e.setupView(n,m)}return{init:s,state:{lightsArray:n,shadowsArray:r,lights:e},setupLights:d,setupLightsView:p,pushLight:l,pushShadow:h}}function $b(o,t){let e=new WeakMap;function n(s,l=0){let h;return e.has(s)===!1?(h=new dh(o,t),e.set(s,[h])):l>=e.get(s).length?(h=new dh(o,t),e.get(s).push(h)):h=e.get(s)[l],h}function r(){e=new WeakMap}return{get:n,dispose:r}}class cu extends Pe{constructor(t){super(),this.type="MeshDepthMaterial",this.depthPacking=gg,this.map=null,this.alphaMap=null,this.displacementMap=null,this.displacementScale=1,this.displacementBias=0,this.wireframe=!1,this.wireframeLinewidth=1,this.fog=!1,this.setValues(t)}copy(t){return super.copy(t),this.depthPacking=t.depthPacking,this.map=t.map,this.alphaMap=t.alphaMap,this.displacementMap=t.displacementMap,this.displacementScale=t.displacementScale,this.displacementBias=t.displacementBias,this.wireframe=t.wireframe,this.wireframeLinewidth=t.wireframeLinewidth,this}}cu.prototype.isMeshDepthMaterial=!0;class hu extends Pe{constructor(t){super(),this.type="MeshDistanceMaterial",this.referencePosition=new D,this.nearDistance=1,this.farDistance=1e3,this.map=null,this.alphaMap=null,this.displacementMap=null,this.displacementScale=1,this.displacementBias=0,this.fog=!1,this.setValues(t)}copy(t){return super.copy(t),this.referencePosition.copy(t.referencePosition),this.nearDistance=t.nearDistance,this.farDistance=t.farDistance,this.map=t.map,this.alphaMap=t.alphaMap,this.displacementMap=t.displacementMap,this.displacementScale=t.displacementScale,this.displacementBias=t.displacementBias,this}}hu.prototype.isMeshDistanceMaterial=!0;const Yb=`void main() {
	gl_Position = vec4( position, 1.0 );
}`,Jb=`uniform sampler2D shadow_pass;
uniform vec2 resolution;
uniform float radius;
#include <packing>
void main() {
	const float samples = float( VSM_SAMPLES );
	float mean = 0.0;
	float squared_mean = 0.0;
	float uvStride = samples <= 1.0 ? 0.0 : 2.0 / ( samples - 1.0 );
	float uvStart = samples <= 1.0 ? 0.0 : - 1.0;
	for ( float i = 0.0; i < samples; i ++ ) {
		float uvOffset = uvStart + i * uvStride;
		#ifdef HORIZONTAL_PASS
			vec2 distribution = unpackRGBATo2Half( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( uvOffset, 0.0 ) * radius ) / resolution ) );
			mean += distribution.x;
			squared_mean += distribution.y * distribution.y + distribution.x * distribution.x;
		#else
			float depth = unpackRGBAToDepth( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( 0.0, uvOffset ) * radius ) / resolution ) );
			mean += depth;
			squared_mean += depth * depth;
		#endif
	}
	mean = mean / samples;
	squared_mean = squared_mean / samples;
	float std_dev = sqrt( squared_mean - mean * mean );
	gl_FragColor = pack2HalfToRGBA( vec2( mean, std_dev ) );
}`;function uu(o,t,e){let n=new no;const r=new st,s=new st,l=new re,h=new cu({depthPacking:vg}),d=new hu,p={},f=e.maxTextureSize,m={0:ge,1:zr,2:$i},g=new di({defines:{VSM_SAMPLES:8},uniforms:{shadow_pass:{value:null},resolution:{value:new st},radius:{value:4}},vertexShader:Yb,fragmentShader:Jb}),_=g.clone();_.defines.HORIZONTAL_PASS=1;const y=new ce;y.setAttribute("position",new _e(new Float32Array([-1,-1,.5,3,-1,.5,-1,3,.5]),3));const w=new Ve(y,g),S=this;this.enabled=!1,this.autoUpdate=!0,this.needsUpdate=!1,this.type=zh,this.render=function(M,R,F){if(S.enabled===!1||S.autoUpdate===!1&&S.needsUpdate===!1||M.length===0)return;const k=o.getRenderTarget(),j=o.getActiveCubeFace(),ot=o.getActiveMipmapLevel(),Y=o.state;Y.setBlending(Wn),Y.buffers.color.setClear(1,1,1,1),Y.buffers.depth.setTest(!0),Y.setScissorTest(!1);for(let V=0,C=M.length;V<C;V++){const A=M[V],H=A.shadow;if(H===void 0){console.warn("THREE.WebGLShadowMap:",A,"has no shadow.");continue}if(H.autoUpdate===!1&&H.needsUpdate===!1)continue;r.copy(H.mapSize);const q=H.getFrameExtents();if(r.multiply(q),s.copy(H.mapSize),(r.x>f||r.y>f)&&(r.x>f&&(s.x=Math.floor(f/q.x),r.x=s.x*q.x,H.mapSize.x=s.x),r.y>f&&(s.y=Math.floor(f/q.y),r.y=s.y*q.y,H.mapSize.y=s.y)),H.map===null&&!H.isPointLightShadow&&this.type===Ir){const U={minFilter:Le,magFilter:Le,format:be};H.map=new Ye(r.x,r.y,U),H.map.texture.name=A.name+".shadowMap",H.mapPass=new Ye(r.x,r.y,U),H.camera.updateProjectionMatrix()}if(H.map===null){const U={minFilter:ve,magFilter:ve,format:be};H.map=new Ye(r.x,r.y,U),H.map.texture.name=A.name+".shadowMap",H.camera.updateProjectionMatrix()}o.setRenderTarget(H.map),o.clear();const O=H.getViewportCount();for(let U=0;U<O;U++){const X=H.getViewport(U);l.set(s.x*X.x,s.y*X.y,s.x*X.z,s.y*X.w),Y.viewport(l),H.updateMatrices(A,U),n=H.getFrustum(),N(R,F,H.camera,A,this.type)}!H.isPointLightShadow&&this.type===Ir&&x(H,F),H.needsUpdate=!1}S.needsUpdate=!1,o.setRenderTarget(k,j,ot)};function x(M,R){const F=t.update(w);g.defines.VSM_SAMPLES!==M.blurSamples&&(g.defines.VSM_SAMPLES=M.blurSamples,_.defines.VSM_SAMPLES=M.blurSamples,g.needsUpdate=!0,_.needsUpdate=!0),g.uniforms.shadow_pass.value=M.map.texture,g.uniforms.resolution.value=M.mapSize,g.uniforms.radius.value=M.radius,o.setRenderTarget(M.mapPass),o.clear(),o.renderBufferDirect(R,null,F,g,w,null),_.uniforms.shadow_pass.value=M.mapPass.texture,_.uniforms.resolution.value=M.mapSize,_.uniforms.radius.value=M.radius,o.setRenderTarget(M.map),o.clear(),o.renderBufferDirect(R,null,F,_,w,null)}function v(M,R,F,k,j,ot,Y){let V=null;const C=k.isPointLight===!0?M.customDistanceMaterial:M.customDepthMaterial;if(C!==void 0?V=C:V=k.isPointLight===!0?d:h,o.localClippingEnabled&&F.clipShadows===!0&&F.clippingPlanes.length!==0||F.displacementMap&&F.displacementScale!==0||F.alphaMap&&F.alphaTest>0){const A=V.uuid,H=F.uuid;let q=p[A];q===void 0&&(q={},p[A]=q);let O=q[H];O===void 0&&(O=V.clone(),q[H]=O),V=O}return V.visible=F.visible,V.wireframe=F.wireframe,Y===Ir?V.side=F.shadowSide!==null?F.shadowSide:F.side:V.side=F.shadowSide!==null?F.shadowSide:m[F.side],V.alphaMap=F.alphaMap,V.alphaTest=F.alphaTest,V.clipShadows=F.clipShadows,V.clippingPlanes=F.clippingPlanes,V.clipIntersection=F.clipIntersection,V.displacementMap=F.displacementMap,V.displacementScale=F.displacementScale,V.displacementBias=F.displacementBias,V.wireframeLinewidth=F.wireframeLinewidth,V.linewidth=F.linewidth,k.isPointLight===!0&&V.isMeshDistanceMaterial===!0&&(V.referencePosition.setFromMatrixPosition(k.matrixWorld),V.nearDistance=j,V.farDistance=ot),V}function N(M,R,F,k,j){if(M.visible===!1)return;if(M.layers.test(R.layers)&&(M.isMesh||M.isLine||M.isPoints)&&(M.castShadow||M.receiveShadow&&j===Ir)&&(!M.frustumCulled||n.intersectsObject(M))){M.modelViewMatrix.multiplyMatrices(F.matrixWorldInverse,M.matrixWorld);const V=t.update(M),C=M.material;if(Array.isArray(C)){const A=V.groups;for(let H=0,q=A.length;H<q;H++){const O=A[H],U=C[O.materialIndex];if(U&&U.visible){const X=v(M,V,U,k,F.near,F.far,j);o.renderBufferDirect(F,null,V,X,M,O)}}}else if(C.visible){const A=v(M,V,C,k,F.near,F.far,j);o.renderBufferDirect(F,null,V,A,M,null)}}const Y=M.children;for(let V=0,C=Y.length;V<C;V++)N(Y[V],R,F,k,j)}}function Zb(o,t,e){const n=e.isWebGL2;function r(){let I=!1;const dt=new re;let lt=null;const Lt=new re(0,0,0,0);return{setMask:function(bt){lt!==bt&&!I&&(o.colorMask(bt,bt,bt,bt),lt=bt)},setLocked:function(bt){I=bt},setClear:function(bt,Ft,ft,Nt,ee){ee===!0&&(bt*=Nt,Ft*=Nt,ft*=Nt),dt.set(bt,Ft,ft,Nt),Lt.equals(dt)===!1&&(o.clearColor(bt,Ft,ft,Nt),Lt.copy(dt))},reset:function(){I=!1,lt=null,Lt.set(-1,0,0,0)}}}function s(){let I=!1,dt=null,lt=null,Lt=null;return{setTest:function(bt){bt?vt(2929):at(2929)},setMask:function(bt){dt!==bt&&!I&&(o.depthMask(bt),dt=bt)},setFunc:function(bt){if(lt!==bt){if(bt)switch(bt){case om:o.depthFunc(512);break;case am:o.depthFunc(519);break;case lm:o.depthFunc(513);break;case ba:o.depthFunc(515);break;case cm:o.depthFunc(514);break;case hm:o.depthFunc(518);break;case um:o.depthFunc(516);break;case dm:o.depthFunc(517);break;default:o.depthFunc(515)}else o.depthFunc(515);lt=bt}},setLocked:function(bt){I=bt},setClear:function(bt){Lt!==bt&&(o.clearDepth(bt),Lt=bt)},reset:function(){I=!1,dt=null,lt=null,Lt=null}}}function l(){let I=!1,dt=null,lt=null,Lt=null,bt=null,Ft=null,ft=null,Nt=null,ee=null;return{setTest:function(Zt){I||(Zt?vt(2960):at(2960))},setMask:function(Zt){dt!==Zt&&!I&&(o.stencilMask(Zt),dt=Zt)},setFunc:function(Zt,De,Ie){(lt!==Zt||Lt!==De||bt!==Ie)&&(o.stencilFunc(Zt,De,Ie),lt=Zt,Lt=De,bt=Ie)},setOp:function(Zt,De,Ie){(Ft!==Zt||ft!==De||Nt!==Ie)&&(o.stencilOp(Zt,De,Ie),Ft=Zt,ft=De,Nt=Ie)},setLocked:function(Zt){I=Zt},setClear:function(Zt){ee!==Zt&&(o.clearStencil(Zt),ee=Zt)},reset:function(){I=!1,dt=null,lt=null,Lt=null,bt=null,Ft=null,ft=null,Nt=null,ee=null}}}const h=new r,d=new s,p=new l;let f={},m={},g=null,_=!1,y=null,w=null,S=null,x=null,v=null,N=null,M=null,R=!1,F=null,k=null,j=null,ot=null,Y=null;const V=o.getParameter(35661);let C=!1,A=0;const H=o.getParameter(7938);H.indexOf("WebGL")!==-1?(A=parseFloat(/^WebGL (\d)/.exec(H)[1]),C=A>=1):H.indexOf("OpenGL ES")!==-1&&(A=parseFloat(/^OpenGL ES (\d)/.exec(H)[1]),C=A>=2);let q=null,O={};const U=o.getParameter(3088),X=o.getParameter(2978),_t=new re().fromArray(U),J=new re().fromArray(X);function Z(I,dt,lt){const Lt=new Uint8Array(4),bt=o.createTexture();o.bindTexture(I,bt),o.texParameteri(I,10241,9728),o.texParameteri(I,10240,9728);for(let Ft=0;Ft<lt;Ft++)o.texImage2D(dt+Ft,0,6408,1,1,0,6408,5121,Lt);return bt}const pt={};pt[3553]=Z(3553,3553,1),pt[34067]=Z(34067,34069,6),h.setClear(0,0,0,1),d.setClear(1),p.setClear(0),vt(2929),d.setFunc(ba),Ot(!1),$(fc),vt(2884),yt(Wn);function vt(I){f[I]!==!0&&(o.enable(I),f[I]=!0)}function at(I){f[I]!==!1&&(o.disable(I),f[I]=!1)}function Tt(I,dt){return m[I]!==dt?(o.bindFramebuffer(I,dt),m[I]=dt,n&&(I===36009&&(m[36160]=dt),I===36160&&(m[36009]=dt)),!0):!1}function Q(I){return g!==I?(o.useProgram(I),g=I,!0):!1}const zt={[Hi]:32774,[Yf]:32778,[Jf]:32779};if(n)zt[_c]=32775,zt[xc]=32776;else{const I=t.get("EXT_blend_minmax");I!==null&&(zt[_c]=I.MIN_EXT,zt[xc]=I.MAX_EXT)}const wt={[Zf]:0,[Kf]:1,[Qf]:768,[Uh]:770,[sm]:776,[im]:774,[em]:772,[tm]:769,[Hh]:771,[rm]:775,[nm]:773};function yt(I,dt,lt,Lt,bt,Ft,ft,Nt){if(I===Wn){_===!0&&(at(3042),_=!1);return}if(_===!1&&(vt(3042),_=!0),I!==$f){if(I!==y||Nt!==R){if((w!==Hi||v!==Hi)&&(o.blendEquation(32774),w=Hi,v=Hi),Nt)switch(I){case kr:o.blendFuncSeparate(1,771,1,771);break;case mc:o.blendFunc(1,1);break;case gc:o.blendFuncSeparate(0,0,769,771);break;case vc:o.blendFuncSeparate(0,768,0,770);break;default:console.error("THREE.WebGLState: Invalid blending: ",I);break}else switch(I){case kr:o.blendFuncSeparate(770,771,1,771);break;case mc:o.blendFunc(770,1);break;case gc:o.blendFunc(0,769);break;case vc:o.blendFunc(0,768);break;default:console.error("THREE.WebGLState: Invalid blending: ",I);break}S=null,x=null,N=null,M=null,y=I,R=Nt}return}bt=bt||dt,Ft=Ft||lt,ft=ft||Lt,(dt!==w||bt!==v)&&(o.blendEquationSeparate(zt[dt],zt[bt]),w=dt,v=bt),(lt!==S||Lt!==x||Ft!==N||ft!==M)&&(o.blendFuncSeparate(wt[lt],wt[Lt],wt[Ft],wt[ft]),S=lt,x=Lt,N=Ft,M=ft),y=I,R=null}function Mt(I,dt){I.side===$i?at(2884):vt(2884);let lt=I.side===ge;dt&&(lt=!lt),Ot(lt),I.blending===kr&&I.transparent===!1?yt(Wn):yt(I.blending,I.blendEquation,I.blendSrc,I.blendDst,I.blendEquationAlpha,I.blendSrcAlpha,I.blendDstAlpha,I.premultipliedAlpha),d.setFunc(I.depthFunc),d.setTest(I.depthTest),d.setMask(I.depthWrite),h.setMask(I.colorWrite);const Lt=I.stencilWrite;p.setTest(Lt),Lt&&(p.setMask(I.stencilWriteMask),p.setFunc(I.stencilFunc,I.stencilRef,I.stencilFuncMask),p.setOp(I.stencilFail,I.stencilZFail,I.stencilZPass)),ct(I.polygonOffset,I.polygonOffsetFactor,I.polygonOffsetUnits),I.alphaToCoverage===!0?vt(32926):at(32926)}function Ot(I){F!==I&&(I?o.frontFace(2304):o.frontFace(2305),F=I)}function $(I){I!==qf?(vt(2884),I!==k&&(I===fc?o.cullFace(1029):I===jf?o.cullFace(1028):o.cullFace(1032))):at(2884),k=I}function rt(I){I!==j&&(C&&o.lineWidth(I),j=I)}function ct(I,dt,lt){I?(vt(32823),(ot!==dt||Y!==lt)&&(o.polygonOffset(dt,lt),ot=dt,Y=lt)):at(32823)}function xt(I){I?vt(3089):at(3089)}function ht(I){I===void 0&&(I=33984+V-1),q!==I&&(o.activeTexture(I),q=I)}function Pt(I,dt){q===null&&ht();let lt=O[q];lt===void 0&&(lt={type:void 0,texture:void 0},O[q]=lt),(lt.type!==I||lt.texture!==dt)&&(o.bindTexture(I,dt||pt[I]),lt.type=I,lt.texture=dt)}function Vt(){const I=O[q];I!==void 0&&I.type!==void 0&&(o.bindTexture(I.type,null),I.type=void 0,I.texture=void 0)}function Ut(){try{o.compressedTexImage2D.apply(o,arguments)}catch(I){console.error("THREE.WebGLState:",I)}}function ie(){try{o.texSubImage2D.apply(o,arguments)}catch(I){console.error("THREE.WebGLState:",I)}}function L(){try{o.texSubImage3D.apply(o,arguments)}catch(I){console.error("THREE.WebGLState:",I)}}function T(){try{o.compressedTexSubImage2D.apply(o,arguments)}catch(I){console.error("THREE.WebGLState:",I)}}function tt(){try{o.texStorage2D.apply(o,arguments)}catch(I){console.error("THREE.WebGLState:",I)}}function et(){try{o.texStorage3D.apply(o,arguments)}catch(I){console.error("THREE.WebGLState:",I)}}function mt(){try{o.texImage2D.apply(o,arguments)}catch(I){console.error("THREE.WebGLState:",I)}}function nt(){try{o.texImage3D.apply(o,arguments)}catch(I){console.error("THREE.WebGLState:",I)}}function It(I){_t.equals(I)===!1&&(o.scissor(I.x,I.y,I.z,I.w),_t.copy(I))}function Ct(I){J.equals(I)===!1&&(o.viewport(I.x,I.y,I.z,I.w),J.copy(I))}function ut(){o.disable(3042),o.disable(2884),o.disable(2929),o.disable(32823),o.disable(3089),o.disable(2960),o.disable(32926),o.blendEquation(32774),o.blendFunc(1,0),o.blendFuncSeparate(1,0,1,0),o.colorMask(!0,!0,!0,!0),o.clearColor(0,0,0,0),o.depthMask(!0),o.depthFunc(513),o.clearDepth(1),o.stencilMask(4294967295),o.stencilFunc(519,0,4294967295),o.stencilOp(7680,7680,7680),o.clearStencil(0),o.cullFace(1029),o.frontFace(2305),o.polygonOffset(0,0),o.activeTexture(33984),o.bindFramebuffer(36160,null),n===!0&&(o.bindFramebuffer(36009,null),o.bindFramebuffer(36008,null)),o.useProgram(null),o.lineWidth(1),o.scissor(0,0,o.canvas.width,o.canvas.height),o.viewport(0,0,o.canvas.width,o.canvas.height),f={},q=null,O={},m={},g=null,_=!1,y=null,w=null,S=null,x=null,v=null,N=null,M=null,R=!1,F=null,k=null,j=null,ot=null,Y=null,_t.set(0,0,o.canvas.width,o.canvas.height),J.set(0,0,o.canvas.width,o.canvas.height),h.reset(),d.reset(),p.reset()}return{buffers:{color:h,depth:d,stencil:p},enable:vt,disable:at,bindFramebuffer:Tt,useProgram:Q,setBlending:yt,setMaterial:Mt,setFlipSided:Ot,setCullFace:$,setLineWidth:rt,setPolygonOffset:ct,setScissorTest:xt,activeTexture:ht,bindTexture:Pt,unbindTexture:Vt,compressedTexImage2D:Ut,texImage2D:mt,texImage3D:nt,texStorage2D:tt,texStorage3D:et,texSubImage2D:ie,texSubImage3D:L,compressedTexSubImage2D:T,scissor:It,viewport:Ct,reset:ut}}function Kb(o,t,e,n,r,s,l){const h=r.isWebGL2,d=r.maxTextures,p=r.maxCubemapSize,f=r.maxTextureSize,m=r.maxSamples,_=t.has("WEBGL_multisampled_render_to_texture")?t.get("WEBGL_multisampled_render_to_texture"):void 0,y=new WeakMap;let w,S=!1;try{S=typeof OffscreenCanvas!="undefined"&&new OffscreenCanvas(1,1).getContext("2d")!==null}catch{}function x(L,T){return S?new OffscreenCanvas(L,T):to("canvas")}function v(L,T,tt,et){let mt=1;if((L.width>et||L.height>et)&&(mt=et/Math.max(L.width,L.height)),mt<1||T===!0)if(typeof HTMLImageElement!="undefined"&&L instanceof HTMLImageElement||typeof HTMLCanvasElement!="undefined"&&L instanceof HTMLCanvasElement||typeof ImageBitmap!="undefined"&&L instanceof ImageBitmap){const nt=T?yg:Math.floor,It=nt(mt*L.width),Ct=nt(mt*L.height);w===void 0&&(w=x(It,Ct));const ut=tt?x(It,Ct):w;return ut.width=It,ut.height=Ct,ut.getContext("2d").drawImage(L,0,0,It,Ct),console.warn("THREE.WebGLRenderer: Texture has been resized from ("+L.width+"x"+L.height+") to ("+It+"x"+Ct+")."),ut}else return"data"in L&&console.warn("THREE.WebGLRenderer: Image in DataTexture is too big ("+L.width+"x"+L.height+")."),L;return L}function N(L){return Ic(L.width)&&Ic(L.height)}function M(L){return h?!1:L.wrapS!==qe||L.wrapT!==qe||L.minFilter!==ve&&L.minFilter!==Le}function R(L,T){return L.generateMipmaps&&T&&L.minFilter!==ve&&L.minFilter!==Le}function F(L){o.generateMipmap(L)}function k(L,T,tt,et){if(h===!1)return T;if(L!==null){if(o[L]!==void 0)return o[L];console.warn("THREE.WebGLRenderer: Attempt to use non-existing WebGL internal format '"+L+"'")}let mt=T;return T===6403&&(tt===5126&&(mt=33326),tt===5131&&(mt=33325),tt===5121&&(mt=33321)),T===6407&&(tt===5126&&(mt=34837),tt===5131&&(mt=34843),tt===5121&&(mt=32849)),T===6408&&(tt===5126&&(mt=34836),tt===5131&&(mt=34842),tt===5121&&(mt=et===Ki?35907:32856)),(mt===33325||mt===33326||mt===34842||mt===34836)&&t.get("EXT_color_buffer_float"),mt}function j(L,T,tt){return R(L,tt)===!0||L.isFramebufferTexture&&L.minFilter!==ve&&L.minFilter!==Le?Math.log2(Math.max(T.width,T.height))+1:L.mipmaps!==void 0&&L.mipmaps.length>0?L.mipmaps.length:L.isCompressedTexture&&Array.isArray(L.image)?T.mipmaps.length:1}function ot(L){return L===ve||L===bc||L===yc?9728:9729}function Y(L){const T=L.target;T.removeEventListener("dispose",Y),C(T),T.isVideoTexture&&y.delete(T),l.memory.textures--}function V(L){const T=L.target;T.removeEventListener("dispose",V),A(T)}function C(L){const T=n.get(L);T.__webglInit!==void 0&&(o.deleteTexture(T.__webglTexture),n.remove(L))}function A(L){const T=L.texture,tt=n.get(L),et=n.get(T);if(!!L){if(et.__webglTexture!==void 0&&(o.deleteTexture(et.__webglTexture),l.memory.textures--),L.depthTexture&&L.depthTexture.dispose(),L.isWebGLCubeRenderTarget)for(let mt=0;mt<6;mt++)o.deleteFramebuffer(tt.__webglFramebuffer[mt]),tt.__webglDepthbuffer&&o.deleteRenderbuffer(tt.__webglDepthbuffer[mt]);else o.deleteFramebuffer(tt.__webglFramebuffer),tt.__webglDepthbuffer&&o.deleteRenderbuffer(tt.__webglDepthbuffer),tt.__webglMultisampledFramebuffer&&o.deleteFramebuffer(tt.__webglMultisampledFramebuffer),tt.__webglColorRenderbuffer&&o.deleteRenderbuffer(tt.__webglColorRenderbuffer),tt.__webglDepthRenderbuffer&&o.deleteRenderbuffer(tt.__webglDepthRenderbuffer);if(L.isWebGLMultipleRenderTargets)for(let mt=0,nt=T.length;mt<nt;mt++){const It=n.get(T[mt]);It.__webglTexture&&(o.deleteTexture(It.__webglTexture),l.memory.textures--),n.remove(T[mt])}n.remove(T),n.remove(L)}}let H=0;function q(){H=0}function O(){const L=H;return L>=d&&console.warn("THREE.WebGLTextures: Trying to use "+L+" texture units while this GPU supports only "+d),H+=1,L}function U(L,T){const tt=n.get(L);if(L.isVideoTexture&&ht(L),L.version>0&&tt.__version!==L.version){const et=L.image;if(et===void 0)console.warn("THREE.WebGLRenderer: Texture marked for update but image is undefined");else if(et.complete===!1)console.warn("THREE.WebGLRenderer: Texture marked for update but image is incomplete");else{Tt(tt,L,T);return}}e.activeTexture(33984+T),e.bindTexture(3553,tt.__webglTexture)}function X(L,T){const tt=n.get(L);if(L.version>0&&tt.__version!==L.version){Tt(tt,L,T);return}e.activeTexture(33984+T),e.bindTexture(35866,tt.__webglTexture)}function _t(L,T){const tt=n.get(L);if(L.version>0&&tt.__version!==L.version){Tt(tt,L,T);return}e.activeTexture(33984+T),e.bindTexture(32879,tt.__webglTexture)}function J(L,T){const tt=n.get(L);if(L.version>0&&tt.__version!==L.version){Q(tt,L,T);return}e.activeTexture(33984+T),e.bindTexture(34067,tt.__webglTexture)}const Z={[Ma]:10497,[qe]:33071,[Sa]:33648},pt={[ve]:9728,[bc]:9984,[yc]:9986,[Le]:9729,[bm]:9985,[Qs]:9987};function vt(L,T,tt){if(tt?(o.texParameteri(L,10242,Z[T.wrapS]),o.texParameteri(L,10243,Z[T.wrapT]),(L===32879||L===35866)&&o.texParameteri(L,32882,Z[T.wrapR]),o.texParameteri(L,10240,pt[T.magFilter]),o.texParameteri(L,10241,pt[T.minFilter])):(o.texParameteri(L,10242,33071),o.texParameteri(L,10243,33071),(L===32879||L===35866)&&o.texParameteri(L,32882,33071),(T.wrapS!==qe||T.wrapT!==qe)&&console.warn("THREE.WebGLRenderer: Texture is not power of two. Texture.wrapS and Texture.wrapT should be set to THREE.ClampToEdgeWrapping."),o.texParameteri(L,10240,ot(T.magFilter)),o.texParameteri(L,10241,ot(T.minFilter)),T.minFilter!==ve&&T.minFilter!==Le&&console.warn("THREE.WebGLRenderer: Texture is not power of two. Texture.minFilter should be set to THREE.NearestFilter or THREE.LinearFilter.")),t.has("EXT_texture_filter_anisotropic")===!0){const et=t.get("EXT_texture_filter_anisotropic");if(T.type===Gn&&t.has("OES_texture_float_linear")===!1||h===!1&&T.type===ci&&t.has("OES_texture_half_float_linear")===!1)return;(T.anisotropy>1||n.get(T).__currentAnisotropy)&&(o.texParameterf(L,et.TEXTURE_MAX_ANISOTROPY_EXT,Math.min(T.anisotropy,r.getMaxAnisotropy())),n.get(T).__currentAnisotropy=T.anisotropy)}}function at(L,T){L.__webglInit===void 0&&(L.__webglInit=!0,T.addEventListener("dispose",Y),L.__webglTexture=o.createTexture(),l.memory.textures++)}function Tt(L,T,tt){let et=3553;T.isDataTexture2DArray&&(et=35866),T.isDataTexture3D&&(et=32879),at(L,T),e.activeTexture(33984+tt),e.bindTexture(et,L.__webglTexture),o.pixelStorei(37440,T.flipY),o.pixelStorei(37441,T.premultiplyAlpha),o.pixelStorei(3317,T.unpackAlignment),o.pixelStorei(37443,0);const mt=M(T)&&N(T.image)===!1,nt=v(T.image,mt,!1,f),It=N(nt)||h,Ct=s.convert(T.format);let ut=s.convert(T.type),I=k(T.internalFormat,Ct,ut,T.encoding);vt(et,T,It);let dt;const lt=T.mipmaps,Lt=h&&T.isVideoTexture!==!0,bt=L.__version===void 0,Ft=j(T,nt,It);if(T.isDepthTexture)I=6402,h?T.type===Gn?I=36012:T.type===Hs?I=33190:T.type===ji?I=35056:I=33189:T.type===Gn&&console.error("WebGLRenderer: Floating point depth texture requires WebGL2."),T.format===ui&&I===6402&&T.type!==Or&&T.type!==Hs&&(console.warn("THREE.WebGLRenderer: Use UnsignedShortType or UnsignedIntType for DepthFormat DepthTexture."),T.type=Or,ut=s.convert(T.type)),T.format===Yi&&I===6402&&(I=34041,T.type!==ji&&(console.warn("THREE.WebGLRenderer: Use UnsignedInt248Type for DepthStencilFormat DepthTexture."),T.type=ji,ut=s.convert(T.type))),Lt&&bt?e.texStorage2D(3553,1,I,nt.width,nt.height):e.texImage2D(3553,0,I,nt.width,nt.height,0,Ct,ut,null);else if(T.isDataTexture)if(lt.length>0&&It){Lt&&bt&&e.texStorage2D(3553,Ft,I,lt[0].width,lt[0].height);for(let ft=0,Nt=lt.length;ft<Nt;ft++)dt=lt[ft],Lt?e.texSubImage2D(3553,0,0,0,dt.width,dt.height,Ct,ut,dt.data):e.texImage2D(3553,ft,I,dt.width,dt.height,0,Ct,ut,dt.data);T.generateMipmaps=!1}else Lt?(bt&&e.texStorage2D(3553,Ft,I,nt.width,nt.height),e.texSubImage2D(3553,0,0,0,nt.width,nt.height,Ct,ut,nt.data)):e.texImage2D(3553,0,I,nt.width,nt.height,0,Ct,ut,nt.data);else if(T.isCompressedTexture){Lt&&bt&&e.texStorage2D(3553,Ft,I,lt[0].width,lt[0].height);for(let ft=0,Nt=lt.length;ft<Nt;ft++)dt=lt[ft],T.format!==be&&T.format!==hi?Ct!==null?Lt?e.compressedTexSubImage2D(3553,ft,0,0,dt.width,dt.height,Ct,dt.data):e.compressedTexImage2D(3553,ft,I,dt.width,dt.height,0,dt.data):console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()"):Lt?e.texSubImage2D(3553,ft,0,0,dt.width,dt.height,Ct,ut,dt.data):e.texImage2D(3553,ft,I,dt.width,dt.height,0,Ct,ut,dt.data)}else if(T.isDataTexture2DArray)Lt?(bt&&e.texStorage3D(35866,Ft,I,nt.width,nt.height,nt.depth),e.texSubImage3D(35866,0,0,0,0,nt.width,nt.height,nt.depth,Ct,ut,nt.data)):e.texImage3D(35866,0,I,nt.width,nt.height,nt.depth,0,Ct,ut,nt.data);else if(T.isDataTexture3D)Lt?(bt&&e.texStorage3D(32879,Ft,I,nt.width,nt.height,nt.depth),e.texSubImage3D(32879,0,0,0,0,nt.width,nt.height,nt.depth,Ct,ut,nt.data)):e.texImage3D(32879,0,I,nt.width,nt.height,nt.depth,0,Ct,ut,nt.data);else if(T.isFramebufferTexture)Lt&&bt?e.texStorage2D(3553,Ft,I,nt.width,nt.height):e.texImage2D(3553,0,I,nt.width,nt.height,0,Ct,ut,null);else if(lt.length>0&&It){Lt&&bt&&e.texStorage2D(3553,Ft,I,lt[0].width,lt[0].height);for(let ft=0,Nt=lt.length;ft<Nt;ft++)dt=lt[ft],Lt?e.texSubImage2D(3553,ft,0,0,Ct,ut,dt):e.texImage2D(3553,ft,I,Ct,ut,dt);T.generateMipmaps=!1}else Lt?(bt&&e.texStorage2D(3553,Ft,I,nt.width,nt.height),e.texSubImage2D(3553,0,0,0,Ct,ut,nt)):e.texImage2D(3553,0,I,Ct,ut,nt);R(T,It)&&F(et),L.__version=T.version,T.onUpdate&&T.onUpdate(T)}function Q(L,T,tt){if(T.image.length!==6)return;at(L,T),e.activeTexture(33984+tt),e.bindTexture(34067,L.__webglTexture),o.pixelStorei(37440,T.flipY),o.pixelStorei(37441,T.premultiplyAlpha),o.pixelStorei(3317,T.unpackAlignment),o.pixelStorei(37443,0);const et=T&&(T.isCompressedTexture||T.image[0].isCompressedTexture),mt=T.image[0]&&T.image[0].isDataTexture,nt=[];for(let ft=0;ft<6;ft++)!et&&!mt?nt[ft]=v(T.image[ft],!1,!0,p):nt[ft]=mt?T.image[ft].image:T.image[ft];const It=nt[0],Ct=N(It)||h,ut=s.convert(T.format),I=s.convert(T.type),dt=k(T.internalFormat,ut,I,T.encoding),lt=h&&T.isVideoTexture!==!0,Lt=L.__version===void 0;let bt=j(T,It,Ct);vt(34067,T,Ct);let Ft;if(et){lt&&Lt&&e.texStorage2D(34067,bt,dt,It.width,It.height);for(let ft=0;ft<6;ft++){Ft=nt[ft].mipmaps;for(let Nt=0;Nt<Ft.length;Nt++){const ee=Ft[Nt];T.format!==be&&T.format!==hi?ut!==null?lt?e.compressedTexSubImage2D(34069+ft,Nt,0,0,ee.width,ee.height,ut,ee.data):e.compressedTexImage2D(34069+ft,Nt,dt,ee.width,ee.height,0,ee.data):console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .setTextureCube()"):lt?e.texSubImage2D(34069+ft,Nt,0,0,ee.width,ee.height,ut,I,ee.data):e.texImage2D(34069+ft,Nt,dt,ee.width,ee.height,0,ut,I,ee.data)}}}else{Ft=T.mipmaps,lt&&Lt&&(Ft.length>0&&bt++,e.texStorage2D(34067,bt,dt,nt[0].width,nt[0].height));for(let ft=0;ft<6;ft++)if(mt){lt?e.texSubImage2D(34069+ft,0,0,0,nt[ft].width,nt[ft].height,ut,I,nt[ft].data):e.texImage2D(34069+ft,0,dt,nt[ft].width,nt[ft].height,0,ut,I,nt[ft].data);for(let Nt=0;Nt<Ft.length;Nt++){const Zt=Ft[Nt].image[ft].image;lt?e.texSubImage2D(34069+ft,Nt+1,0,0,Zt.width,Zt.height,ut,I,Zt.data):e.texImage2D(34069+ft,Nt+1,dt,Zt.width,Zt.height,0,ut,I,Zt.data)}}else{lt?e.texSubImage2D(34069+ft,0,0,0,ut,I,nt[ft]):e.texImage2D(34069+ft,0,dt,ut,I,nt[ft]);for(let Nt=0;Nt<Ft.length;Nt++){const ee=Ft[Nt];lt?e.texSubImage2D(34069+ft,Nt+1,0,0,ut,I,ee.image[ft]):e.texImage2D(34069+ft,Nt+1,dt,ut,I,ee.image[ft])}}}R(T,Ct)&&F(34067),L.__version=T.version,T.onUpdate&&T.onUpdate(T)}function zt(L,T,tt,et,mt){const nt=s.convert(tt.format),It=s.convert(tt.type),Ct=k(tt.internalFormat,nt,It,tt.encoding);n.get(T).__hasExternalTextures||(mt===32879||mt===35866?e.texImage3D(mt,0,Ct,T.width,T.height,T.depth,0,nt,It,null):e.texImage2D(mt,0,Ct,T.width,T.height,0,nt,It,null)),e.bindFramebuffer(36160,L),T.useRenderToTexture?_.framebufferTexture2DMultisampleEXT(36160,et,mt,n.get(tt).__webglTexture,0,xt(T)):o.framebufferTexture2D(36160,et,mt,n.get(tt).__webglTexture,0),e.bindFramebuffer(36160,null)}function wt(L,T,tt){if(o.bindRenderbuffer(36161,L),T.depthBuffer&&!T.stencilBuffer){let et=33189;if(tt||T.useRenderToTexture){const mt=T.depthTexture;mt&&mt.isDepthTexture&&(mt.type===Gn?et=36012:mt.type===Hs&&(et=33190));const nt=xt(T);T.useRenderToTexture?_.renderbufferStorageMultisampleEXT(36161,nt,et,T.width,T.height):o.renderbufferStorageMultisample(36161,nt,et,T.width,T.height)}else o.renderbufferStorage(36161,et,T.width,T.height);o.framebufferRenderbuffer(36160,36096,36161,L)}else if(T.depthBuffer&&T.stencilBuffer){const et=xt(T);tt&&T.useRenderbuffer?o.renderbufferStorageMultisample(36161,et,35056,T.width,T.height):T.useRenderToTexture?_.renderbufferStorageMultisampleEXT(36161,et,35056,T.width,T.height):o.renderbufferStorage(36161,34041,T.width,T.height),o.framebufferRenderbuffer(36160,33306,36161,L)}else{const et=T.isWebGLMultipleRenderTargets===!0?T.texture[0]:T.texture,mt=s.convert(et.format),nt=s.convert(et.type),It=k(et.internalFormat,mt,nt,et.encoding),Ct=xt(T);tt&&T.useRenderbuffer?o.renderbufferStorageMultisample(36161,Ct,It,T.width,T.height):T.useRenderToTexture?_.renderbufferStorageMultisampleEXT(36161,Ct,It,T.width,T.height):o.renderbufferStorage(36161,It,T.width,T.height)}o.bindRenderbuffer(36161,null)}function yt(L,T){if(T&&T.isWebGLCubeRenderTarget)throw new Error("Depth Texture with cube render targets is not supported");if(e.bindFramebuffer(36160,L),!(T.depthTexture&&T.depthTexture.isDepthTexture))throw new Error("renderTarget.depthTexture must be an instance of THREE.DepthTexture");(!n.get(T.depthTexture).__webglTexture||T.depthTexture.image.width!==T.width||T.depthTexture.image.height!==T.height)&&(T.depthTexture.image.width=T.width,T.depthTexture.image.height=T.height,T.depthTexture.needsUpdate=!0),U(T.depthTexture,0);const et=n.get(T.depthTexture).__webglTexture,mt=xt(T);if(T.depthTexture.format===ui)T.useRenderToTexture?_.framebufferTexture2DMultisampleEXT(36160,36096,3553,et,0,mt):o.framebufferTexture2D(36160,36096,3553,et,0);else if(T.depthTexture.format===Yi)T.useRenderToTexture?_.framebufferTexture2DMultisampleEXT(36160,33306,3553,et,0,mt):o.framebufferTexture2D(36160,33306,3553,et,0);else throw new Error("Unknown depthTexture format")}function Mt(L){const T=n.get(L),tt=L.isWebGLCubeRenderTarget===!0;if(L.depthTexture&&!T.__autoAllocateDepthBuffer){if(tt)throw new Error("target.depthTexture not supported in Cube render targets");yt(T.__webglFramebuffer,L)}else if(tt){T.__webglDepthbuffer=[];for(let et=0;et<6;et++)e.bindFramebuffer(36160,T.__webglFramebuffer[et]),T.__webglDepthbuffer[et]=o.createRenderbuffer(),wt(T.__webglDepthbuffer[et],L,!1)}else e.bindFramebuffer(36160,T.__webglFramebuffer),T.__webglDepthbuffer=o.createRenderbuffer(),wt(T.__webglDepthbuffer,L,!1);e.bindFramebuffer(36160,null)}function Ot(L,T,tt){const et=n.get(L);T!==void 0&&zt(et.__webglFramebuffer,L,L.texture,36064,3553),tt!==void 0&&Mt(L)}function $(L){const T=L.texture,tt=n.get(L),et=n.get(T);L.addEventListener("dispose",V),L.isWebGLMultipleRenderTargets!==!0&&(et.__webglTexture===void 0&&(et.__webglTexture=o.createTexture()),et.__version=T.version,l.memory.textures++);const mt=L.isWebGLCubeRenderTarget===!0,nt=L.isWebGLMultipleRenderTargets===!0,It=T.isDataTexture3D||T.isDataTexture2DArray,Ct=N(L)||h;if(h&&T.format===hi&&(T.type===Gn||T.type===ci)&&(T.format=be,console.warn("THREE.WebGLRenderer: Rendering to textures with RGB format is not supported. Using RGBA format instead.")),mt){tt.__webglFramebuffer=[];for(let ut=0;ut<6;ut++)tt.__webglFramebuffer[ut]=o.createFramebuffer()}else if(tt.__webglFramebuffer=o.createFramebuffer(),nt)if(r.drawBuffers){const ut=L.texture;for(let I=0,dt=ut.length;I<dt;I++){const lt=n.get(ut[I]);lt.__webglTexture===void 0&&(lt.__webglTexture=o.createTexture(),l.memory.textures++)}}else console.warn("THREE.WebGLRenderer: WebGLMultipleRenderTargets can only be used with WebGL2 or WEBGL_draw_buffers extension.");else if(L.useRenderbuffer)if(h){tt.__webglMultisampledFramebuffer=o.createFramebuffer(),tt.__webglColorRenderbuffer=o.createRenderbuffer(),o.bindRenderbuffer(36161,tt.__webglColorRenderbuffer);const ut=s.convert(T.format),I=s.convert(T.type),dt=k(T.internalFormat,ut,I,T.encoding),lt=xt(L);o.renderbufferStorageMultisample(36161,lt,dt,L.width,L.height),e.bindFramebuffer(36160,tt.__webglMultisampledFramebuffer),o.framebufferRenderbuffer(36160,36064,36161,tt.__webglColorRenderbuffer),o.bindRenderbuffer(36161,null),L.depthBuffer&&(tt.__webglDepthRenderbuffer=o.createRenderbuffer(),wt(tt.__webglDepthRenderbuffer,L,!0)),e.bindFramebuffer(36160,null)}else console.warn("THREE.WebGLRenderer: WebGLMultisampleRenderTarget can only be used with WebGL2.");if(mt){e.bindTexture(34067,et.__webglTexture),vt(34067,T,Ct);for(let ut=0;ut<6;ut++)zt(tt.__webglFramebuffer[ut],L,T,36064,34069+ut);R(T,Ct)&&F(34067),e.unbindTexture()}else if(nt){const ut=L.texture;for(let I=0,dt=ut.length;I<dt;I++){const lt=ut[I],Lt=n.get(lt);e.bindTexture(3553,Lt.__webglTexture),vt(3553,lt,Ct),zt(tt.__webglFramebuffer,L,lt,36064+I,3553),R(lt,Ct)&&F(3553)}e.unbindTexture()}else{let ut=3553;It&&(h?ut=T.isDataTexture3D?32879:35866:console.warn("THREE.DataTexture3D and THREE.DataTexture2DArray only supported with WebGL2.")),e.bindTexture(ut,et.__webglTexture),vt(ut,T,Ct),zt(tt.__webglFramebuffer,L,T,36064,ut),R(T,Ct)&&F(ut),e.unbindTexture()}L.depthBuffer&&Mt(L)}function rt(L){const T=N(L)||h,tt=L.isWebGLMultipleRenderTargets===!0?L.texture:[L.texture];for(let et=0,mt=tt.length;et<mt;et++){const nt=tt[et];if(R(nt,T)){const It=L.isWebGLCubeRenderTarget?34067:3553,Ct=n.get(nt).__webglTexture;e.bindTexture(It,Ct),F(It),e.unbindTexture()}}}function ct(L){if(L.useRenderbuffer)if(h){const T=L.width,tt=L.height;let et=16384;const mt=[36064],nt=L.stencilBuffer?33306:36096;L.depthBuffer&&mt.push(nt),L.ignoreDepthForMultisampleCopy||(L.depthBuffer&&(et|=256),L.stencilBuffer&&(et|=1024));const It=n.get(L);e.bindFramebuffer(36008,It.__webglMultisampledFramebuffer),e.bindFramebuffer(36009,It.__webglFramebuffer),L.ignoreDepthForMultisampleCopy&&(o.invalidateFramebuffer(36008,[nt]),o.invalidateFramebuffer(36009,[nt])),o.blitFramebuffer(0,0,T,tt,0,0,T,tt,et,9728),o.invalidateFramebuffer(36008,mt),e.bindFramebuffer(36008,null),e.bindFramebuffer(36009,It.__webglMultisampledFramebuffer)}else console.warn("THREE.WebGLRenderer: WebGLMultisampleRenderTarget can only be used with WebGL2.")}function xt(L){return h&&(L.useRenderbuffer||L.useRenderToTexture)?Math.min(m,L.samples):0}function ht(L){const T=l.render.frame;y.get(L)!==T&&(y.set(L,T),L.update())}let Pt=!1,Vt=!1;function Ut(L,T){L&&L.isWebGLRenderTarget&&(Pt===!1&&(console.warn("THREE.WebGLTextures.safeSetTexture2D: don't use render targets as textures. Use their .texture property instead."),Pt=!0),L=L.texture),U(L,T)}function ie(L,T){L&&L.isWebGLCubeRenderTarget&&(Vt===!1&&(console.warn("THREE.WebGLTextures.safeSetTextureCube: don't use cube render targets as textures. Use their .texture property instead."),Vt=!0),L=L.texture),J(L,T)}this.allocateTextureUnit=O,this.resetTextureUnits=q,this.setTexture2D=U,this.setTexture2DArray=X,this.setTexture3D=_t,this.setTextureCube=J,this.rebindTextures=Ot,this.setupRenderTarget=$,this.updateRenderTargetMipmap=rt,this.updateMultisampleRenderTarget=ct,this.setupDepthRenderbuffer=Mt,this.setupFrameBufferTexture=zt,this.safeSetTexture2D=Ut,this.safeSetTextureCube=ie}function Qb(o,t,e){const n=e.isWebGL2;function r(s){let l;if(s===En)return 5121;if(s===Sm)return 32819;if(s===Em)return 32820;if(s===Tm)return 33635;if(s===ym)return 5120;if(s===wm)return 5122;if(s===Or)return 5123;if(s===Mm)return 5124;if(s===Hs)return 5125;if(s===Gn)return 5126;if(s===ci)return n?5131:(l=t.get("OES_texture_half_float"),l!==null?l.HALF_FLOAT_OES:null);if(s===Cm)return 6406;if(s===hi)return 6407;if(s===be)return 6408;if(s===Am)return 6409;if(s===Pm)return 6410;if(s===ui)return 6402;if(s===Yi)return 34041;if(s===Lm)return 6403;if(s===Rm)return 36244;if(s===Dm)return 33319;if(s===Im)return 33320;if(s===Nm)return 36248;if(s===Fm)return 36249;if(s===wc||s===Mc||s===Sc||s===Ec)if(l=t.get("WEBGL_compressed_texture_s3tc"),l!==null){if(s===wc)return l.COMPRESSED_RGB_S3TC_DXT1_EXT;if(s===Mc)return l.COMPRESSED_RGBA_S3TC_DXT1_EXT;if(s===Sc)return l.COMPRESSED_RGBA_S3TC_DXT3_EXT;if(s===Ec)return l.COMPRESSED_RGBA_S3TC_DXT5_EXT}else return null;if(s===Tc||s===Cc||s===Ac||s===Pc)if(l=t.get("WEBGL_compressed_texture_pvrtc"),l!==null){if(s===Tc)return l.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;if(s===Cc)return l.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;if(s===Ac)return l.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;if(s===Pc)return l.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG}else return null;if(s===km)return l=t.get("WEBGL_compressed_texture_etc1"),l!==null?l.COMPRESSED_RGB_ETC1_WEBGL:null;if((s===Lc||s===Rc)&&(l=t.get("WEBGL_compressed_texture_etc"),l!==null)){if(s===Lc)return l.COMPRESSED_RGB8_ETC2;if(s===Rc)return l.COMPRESSED_RGBA8_ETC2_EAC}if(s===Vm||s===Bm||s===zm||s===Om||s===Um||s===Hm||s===Gm||s===Wm||s===qm||s===jm||s===Xm||s===$m||s===Ym||s===Jm||s===Km||s===Qm||s===tg||s===eg||s===ng||s===ig||s===rg||s===sg||s===og||s===ag||s===lg||s===cg||s===hg||s===ug)return l=t.get("WEBGL_compressed_texture_astc"),l!==null?s:null;if(s===Zm)return l=t.get("EXT_texture_compression_bptc"),l!==null?s:null;if(s===ji)return n?34042:(l=t.get("WEBGL_depth_texture"),l!==null?l.UNSIGNED_INT_24_8_WEBGL:null)}return{convert:r}}class du extends ke{constructor(t=[]){super(),this.cameras=t}}du.prototype.isArrayCamera=!0;class Fr extends te{constructor(){super(),this.type="Group"}}Fr.prototype.isGroup=!0;const t0={type:"move"};class ua{constructor(){this._targetRay=null,this._grip=null,this._hand=null}getHandSpace(){return this._hand===null&&(this._hand=new Fr,this._hand.matrixAutoUpdate=!1,this._hand.visible=!1,this._hand.joints={},this._hand.inputState={pinching:!1}),this._hand}getTargetRaySpace(){return this._targetRay===null&&(this._targetRay=new Fr,this._targetRay.matrixAutoUpdate=!1,this._targetRay.visible=!1,this._targetRay.hasLinearVelocity=!1,this._targetRay.linearVelocity=new D,this._targetRay.hasAngularVelocity=!1,this._targetRay.angularVelocity=new D),this._targetRay}getGripSpace(){return this._grip===null&&(this._grip=new Fr,this._grip.matrixAutoUpdate=!1,this._grip.visible=!1,this._grip.hasLinearVelocity=!1,this._grip.linearVelocity=new D,this._grip.hasAngularVelocity=!1,this._grip.angularVelocity=new D),this._grip}dispatchEvent(t){return this._targetRay!==null&&this._targetRay.dispatchEvent(t),this._grip!==null&&this._grip.dispatchEvent(t),this._hand!==null&&this._hand.dispatchEvent(t),this}disconnect(t){return this.dispatchEvent({type:"disconnected",data:t}),this._targetRay!==null&&(this._targetRay.visible=!1),this._grip!==null&&(this._grip.visible=!1),this._hand!==null&&(this._hand.visible=!1),this}update(t,e,n){let r=null,s=null,l=null;const h=this._targetRay,d=this._grip,p=this._hand;if(t&&e.session.visibilityState!=="visible-blurred")if(h!==null&&(r=e.getPose(t.targetRaySpace,n),r!==null&&(h.matrix.fromArray(r.transform.matrix),h.matrix.decompose(h.position,h.rotation,h.scale),r.linearVelocity?(h.hasLinearVelocity=!0,h.linearVelocity.copy(r.linearVelocity)):h.hasLinearVelocity=!1,r.angularVelocity?(h.hasAngularVelocity=!0,h.angularVelocity.copy(r.angularVelocity)):h.hasAngularVelocity=!1,this.dispatchEvent(t0))),p&&t.hand){l=!0;for(const w of t.hand.values()){const S=e.getJointPose(w,n);if(p.joints[w.jointName]===void 0){const v=new Fr;v.matrixAutoUpdate=!1,v.visible=!1,p.joints[w.jointName]=v,p.add(v)}const x=p.joints[w.jointName];S!==null&&(x.matrix.fromArray(S.transform.matrix),x.matrix.decompose(x.position,x.rotation,x.scale),x.jointRadius=S.radius),x.visible=S!==null}const f=p.joints["index-finger-tip"],m=p.joints["thumb-tip"],g=f.position.distanceTo(m.position),_=.02,y=.005;p.inputState.pinching&&g>_+y?(p.inputState.pinching=!1,this.dispatchEvent({type:"pinchend",handedness:t.handedness,target:this})):!p.inputState.pinching&&g<=_-y&&(p.inputState.pinching=!0,this.dispatchEvent({type:"pinchstart",handedness:t.handedness,target:this}))}else d!==null&&t.gripSpace&&(s=e.getPose(t.gripSpace,n),s!==null&&(d.matrix.fromArray(s.transform.matrix),d.matrix.decompose(d.position,d.rotation,d.scale),s.linearVelocity?(d.hasLinearVelocity=!0,d.linearVelocity.copy(s.linearVelocity)):d.hasLinearVelocity=!1,s.angularVelocity?(d.hasAngularVelocity=!0,d.angularVelocity.copy(s.angularVelocity)):d.hasAngularVelocity=!1));return h!==null&&(h.visible=r!==null),d!==null&&(d.visible=s!==null),p!==null&&(p.visible=l!==null),this}}class Ca extends we{constructor(t,e,n,r,s,l,h,d,p,f){if(f=f!==void 0?f:ui,f!==ui&&f!==Yi)throw new Error("DepthTexture format must be either THREE.DepthFormat or THREE.DepthStencilFormat");n===void 0&&f===ui&&(n=Or),n===void 0&&f===Yi&&(n=ji),super(null,r,s,l,h,d,f,n,p),this.image={width:t,height:e},this.magFilter=h!==void 0?h:ve,this.minFilter=d!==void 0?d:ve,this.flipY=!1,this.generateMipmaps=!1}}Ca.prototype.isDepthTexture=!0;class e0 extends pi{constructor(t,e){super();const n=this;let r=null,s=1,l=null,h="local-floor";const d=t.extensions.has("WEBGL_multisampled_render_to_texture");let p=null,f=null,m=null,g=null,_=!1,y=null;const w=e.getContextAttributes();let S=null,x=null;const v=[],N=new Map,M=new ke;M.layers.enable(1),M.viewport=new re;const R=new ke;R.layers.enable(2),R.viewport=new re;const F=[M,R],k=new du;k.layers.enable(1),k.layers.enable(2);let j=null,ot=null;this.cameraAutoUpdate=!0,this.enabled=!1,this.isPresenting=!1,this.getController=function(J){let Z=v[J];return Z===void 0&&(Z=new ua,v[J]=Z),Z.getTargetRaySpace()},this.getControllerGrip=function(J){let Z=v[J];return Z===void 0&&(Z=new ua,v[J]=Z),Z.getGripSpace()},this.getHand=function(J){let Z=v[J];return Z===void 0&&(Z=new ua,v[J]=Z),Z.getHandSpace()};function Y(J){const Z=N.get(J.inputSource);Z&&Z.dispatchEvent({type:J.type,data:J.inputSource})}function V(){N.forEach(function(J,Z){J.disconnect(Z)}),N.clear(),j=null,ot=null,t.setRenderTarget(S),g=null,m=null,f=null,r=null,x=null,_t.stop(),n.isPresenting=!1,n.dispatchEvent({type:"sessionend"})}this.setFramebufferScaleFactor=function(J){s=J,n.isPresenting===!0&&console.warn("THREE.WebXRManager: Cannot change framebuffer scale while presenting.")},this.setReferenceSpaceType=function(J){h=J,n.isPresenting===!0&&console.warn("THREE.WebXRManager: Cannot change reference space type while presenting.")},this.getReferenceSpace=function(){return l},this.getBaseLayer=function(){return m!==null?m:g},this.getBinding=function(){return f},this.getFrame=function(){return y},this.getSession=function(){return r},this.setSession=async function(J){if(r=J,r!==null){if(S=t.getRenderTarget(),r.addEventListener("select",Y),r.addEventListener("selectstart",Y),r.addEventListener("selectend",Y),r.addEventListener("squeeze",Y),r.addEventListener("squeezestart",Y),r.addEventListener("squeezeend",Y),r.addEventListener("end",V),r.addEventListener("inputsourceschange",C),w.xrCompatible!==!0&&await e.makeXRCompatible(),r.renderState.layers===void 0||t.capabilities.isWebGL2===!1){const Z={antialias:r.renderState.layers===void 0?w.antialias:!0,alpha:w.alpha,depth:w.depth,stencil:w.stencil,framebufferScaleFactor:s};g=new XRWebGLLayer(r,e,Z),r.updateRenderState({baseLayer:g}),x=new Ye(g.framebufferWidth,g.framebufferHeight,{format:be,type:En,encoding:t.outputEncoding})}else{_=w.antialias;let Z=null,pt=null,vt=null;w.depth&&(vt=w.stencil?35056:33190,Z=w.stencil?Yi:ui,pt=w.stencil?ji:Or);const at={colorFormat:w.alpha||_?32856:32849,depthFormat:vt,scaleFactor:s};f=new XRWebGLBinding(r,e),m=f.createProjectionLayer(at),r.updateRenderState({layers:[m]}),_?x=new Fa(m.textureWidth,m.textureHeight,{format:be,type:En,depthTexture:new Ca(m.textureWidth,m.textureHeight,pt,void 0,void 0,void 0,void 0,void 0,void 0,Z),stencilBuffer:w.stencil,ignoreDepth:m.ignoreDepthValues,useRenderToTexture:d,encoding:t.outputEncoding}):x=new Ye(m.textureWidth,m.textureHeight,{format:w.alpha?be:hi,type:En,depthTexture:new Ca(m.textureWidth,m.textureHeight,pt,void 0,void 0,void 0,void 0,void 0,void 0,Z),stencilBuffer:w.stencil,ignoreDepth:m.ignoreDepthValues,encoding:t.outputEncoding})}this.setFoveation(1),l=await r.requestReferenceSpace(h),_t.setContext(r),_t.start(),n.isPresenting=!0,n.dispatchEvent({type:"sessionstart"})}};function C(J){const Z=r.inputSources;for(let pt=0;pt<v.length;pt++)N.set(Z[pt],v[pt]);for(let pt=0;pt<J.removed.length;pt++){const vt=J.removed[pt],at=N.get(vt);at&&(at.dispatchEvent({type:"disconnected",data:vt}),N.delete(vt))}for(let pt=0;pt<J.added.length;pt++){const vt=J.added[pt],at=N.get(vt);at&&at.dispatchEvent({type:"connected",data:vt})}}const A=new D,H=new D;function q(J,Z,pt){A.setFromMatrixPosition(Z.matrixWorld),H.setFromMatrixPosition(pt.matrixWorld);const vt=A.distanceTo(H),at=Z.projectionMatrix.elements,Tt=pt.projectionMatrix.elements,Q=at[14]/(at[10]-1),zt=at[14]/(at[10]+1),wt=(at[9]+1)/at[5],yt=(at[9]-1)/at[5],Mt=(at[8]-1)/at[0],Ot=(Tt[8]+1)/Tt[0],$=Q*Mt,rt=Q*Ot,ct=vt/(-Mt+Ot),xt=ct*-Mt;Z.matrixWorld.decompose(J.position,J.quaternion,J.scale),J.translateX(xt),J.translateZ(ct),J.matrixWorld.compose(J.position,J.quaternion,J.scale),J.matrixWorldInverse.copy(J.matrixWorld).invert();const ht=Q+ct,Pt=zt+ct,Vt=$-xt,Ut=rt+(vt-xt),ie=wt*zt/Pt*ht,L=yt*zt/Pt*ht;J.projectionMatrix.makePerspective(Vt,Ut,ie,L,ht,Pt)}function O(J,Z){Z===null?J.matrixWorld.copy(J.matrix):J.matrixWorld.multiplyMatrices(Z.matrixWorld,J.matrix),J.matrixWorldInverse.copy(J.matrixWorld).invert()}this.updateCamera=function(J){if(r===null)return;k.near=R.near=M.near=J.near,k.far=R.far=M.far=J.far,(j!==k.near||ot!==k.far)&&(r.updateRenderState({depthNear:k.near,depthFar:k.far}),j=k.near,ot=k.far);const Z=J.parent,pt=k.cameras;O(k,Z);for(let at=0;at<pt.length;at++)O(pt[at],Z);k.matrixWorld.decompose(k.position,k.quaternion,k.scale),J.position.copy(k.position),J.quaternion.copy(k.quaternion),J.scale.copy(k.scale),J.matrix.copy(k.matrix),J.matrixWorld.copy(k.matrixWorld);const vt=J.children;for(let at=0,Tt=vt.length;at<Tt;at++)vt[at].updateMatrixWorld(!0);pt.length===2?q(k,M,R):k.projectionMatrix.copy(M.projectionMatrix)},this.getCamera=function(){return k},this.getFoveation=function(){if(m!==null)return m.fixedFoveation;if(g!==null)return g.fixedFoveation},this.setFoveation=function(J){m!==null&&(m.fixedFoveation=J),g!==null&&g.fixedFoveation!==void 0&&(g.fixedFoveation=J)};let U=null;function X(J,Z){if(p=Z.getViewerPose(l),y=Z,p!==null){const vt=p.views;g!==null&&(t.setRenderTargetFramebuffer(x,g.framebuffer),t.setRenderTarget(x));let at=!1;vt.length!==k.cameras.length&&(k.cameras.length=0,at=!0);for(let Tt=0;Tt<vt.length;Tt++){const Q=vt[Tt];let zt=null;if(g!==null)zt=g.getViewport(Q);else{const yt=f.getViewSubImage(m,Q);zt=yt.viewport,Tt===0&&(t.setRenderTargetTextures(x,yt.colorTexture,m.ignoreDepthValues?void 0:yt.depthStencilTexture),t.setRenderTarget(x))}const wt=F[Tt];wt.matrix.fromArray(Q.transform.matrix),wt.projectionMatrix.fromArray(Q.projectionMatrix),wt.viewport.set(zt.x,zt.y,zt.width,zt.height),Tt===0&&k.matrix.copy(wt.matrix),at===!0&&k.cameras.push(wt)}}const pt=r.inputSources;for(let vt=0;vt<v.length;vt++){const at=v[vt],Tt=pt[vt];at.update(Tt,Z,l)}U&&U(J,Z),y=null}const _t=new Zh;_t.setAnimationLoop(X),this.setAnimationLoop=function(J){U=J},this.dispose=function(){}}}function n0(o){function t(x,v){x.fogColor.value.copy(v.color),v.isFog?(x.fogNear.value=v.near,x.fogFar.value=v.far):v.isFogExp2&&(x.fogDensity.value=v.density)}function e(x,v,N,M,R){v.isMeshBasicMaterial?n(x,v):v.isMeshLambertMaterial?(n(x,v),d(x,v)):v.isMeshToonMaterial?(n(x,v),f(x,v)):v.isMeshPhongMaterial?(n(x,v),p(x,v)):v.isMeshStandardMaterial?(n(x,v),v.isMeshPhysicalMaterial?g(x,v,R):m(x,v)):v.isMeshMatcapMaterial?(n(x,v),_(x,v)):v.isMeshDepthMaterial?(n(x,v),y(x,v)):v.isMeshDistanceMaterial?(n(x,v),w(x,v)):v.isMeshNormalMaterial?(n(x,v),S(x,v)):v.isLineBasicMaterial?(r(x,v),v.isLineDashedMaterial&&s(x,v)):v.isPointsMaterial?l(x,v,N,M):v.isSpriteMaterial?h(x,v):v.isShadowMaterial?(x.color.value.copy(v.color),x.opacity.value=v.opacity):v.isShaderMaterial&&(v.uniformsNeedUpdate=!1)}function n(x,v){x.opacity.value=v.opacity,v.color&&x.diffuse.value.copy(v.color),v.emissive&&x.emissive.value.copy(v.emissive).multiplyScalar(v.emissiveIntensity),v.map&&(x.map.value=v.map),v.alphaMap&&(x.alphaMap.value=v.alphaMap),v.specularMap&&(x.specularMap.value=v.specularMap),v.alphaTest>0&&(x.alphaTest.value=v.alphaTest);const N=o.get(v).envMap;N&&(x.envMap.value=N,x.flipEnvMap.value=N.isCubeTexture&&N.isRenderTargetTexture===!1?-1:1,x.reflectivity.value=v.reflectivity,x.ior.value=v.ior,x.refractionRatio.value=v.refractionRatio),v.lightMap&&(x.lightMap.value=v.lightMap,x.lightMapIntensity.value=v.lightMapIntensity),v.aoMap&&(x.aoMap.value=v.aoMap,x.aoMapIntensity.value=v.aoMapIntensity);let M;v.map?M=v.map:v.specularMap?M=v.specularMap:v.displacementMap?M=v.displacementMap:v.normalMap?M=v.normalMap:v.bumpMap?M=v.bumpMap:v.roughnessMap?M=v.roughnessMap:v.metalnessMap?M=v.metalnessMap:v.alphaMap?M=v.alphaMap:v.emissiveMap?M=v.emissiveMap:v.clearcoatMap?M=v.clearcoatMap:v.clearcoatNormalMap?M=v.clearcoatNormalMap:v.clearcoatRoughnessMap?M=v.clearcoatRoughnessMap:v.specularIntensityMap?M=v.specularIntensityMap:v.specularColorMap?M=v.specularColorMap:v.transmissionMap?M=v.transmissionMap:v.thicknessMap?M=v.thicknessMap:v.sheenColorMap?M=v.sheenColorMap:v.sheenRoughnessMap&&(M=v.sheenRoughnessMap),M!==void 0&&(M.isWebGLRenderTarget&&(M=M.texture),M.matrixAutoUpdate===!0&&M.updateMatrix(),x.uvTransform.value.copy(M.matrix));let R;v.aoMap?R=v.aoMap:v.lightMap&&(R=v.lightMap),R!==void 0&&(R.isWebGLRenderTarget&&(R=R.texture),R.matrixAutoUpdate===!0&&R.updateMatrix(),x.uv2Transform.value.copy(R.matrix))}function r(x,v){x.diffuse.value.copy(v.color),x.opacity.value=v.opacity}function s(x,v){x.dashSize.value=v.dashSize,x.totalSize.value=v.dashSize+v.gapSize,x.scale.value=v.scale}function l(x,v,N,M){x.diffuse.value.copy(v.color),x.opacity.value=v.opacity,x.size.value=v.size*N,x.scale.value=M*.5,v.map&&(x.map.value=v.map),v.alphaMap&&(x.alphaMap.value=v.alphaMap),v.alphaTest>0&&(x.alphaTest.value=v.alphaTest);let R;v.map?R=v.map:v.alphaMap&&(R=v.alphaMap),R!==void 0&&(R.matrixAutoUpdate===!0&&R.updateMatrix(),x.uvTransform.value.copy(R.matrix))}function h(x,v){x.diffuse.value.copy(v.color),x.opacity.value=v.opacity,x.rotation.value=v.rotation,v.map&&(x.map.value=v.map),v.alphaMap&&(x.alphaMap.value=v.alphaMap),v.alphaTest>0&&(x.alphaTest.value=v.alphaTest);let N;v.map?N=v.map:v.alphaMap&&(N=v.alphaMap),N!==void 0&&(N.matrixAutoUpdate===!0&&N.updateMatrix(),x.uvTransform.value.copy(N.matrix))}function d(x,v){v.emissiveMap&&(x.emissiveMap.value=v.emissiveMap)}function p(x,v){x.specular.value.copy(v.specular),x.shininess.value=Math.max(v.shininess,1e-4),v.emissiveMap&&(x.emissiveMap.value=v.emissiveMap),v.bumpMap&&(x.bumpMap.value=v.bumpMap,x.bumpScale.value=v.bumpScale,v.side===ge&&(x.bumpScale.value*=-1)),v.normalMap&&(x.normalMap.value=v.normalMap,x.normalScale.value.copy(v.normalScale),v.side===ge&&x.normalScale.value.negate()),v.displacementMap&&(x.displacementMap.value=v.displacementMap,x.displacementScale.value=v.displacementScale,x.displacementBias.value=v.displacementBias)}function f(x,v){v.gradientMap&&(x.gradientMap.value=v.gradientMap),v.emissiveMap&&(x.emissiveMap.value=v.emissiveMap),v.bumpMap&&(x.bumpMap.value=v.bumpMap,x.bumpScale.value=v.bumpScale,v.side===ge&&(x.bumpScale.value*=-1)),v.normalMap&&(x.normalMap.value=v.normalMap,x.normalScale.value.copy(v.normalScale),v.side===ge&&x.normalScale.value.negate()),v.displacementMap&&(x.displacementMap.value=v.displacementMap,x.displacementScale.value=v.displacementScale,x.displacementBias.value=v.displacementBias)}function m(x,v){x.roughness.value=v.roughness,x.metalness.value=v.metalness,v.roughnessMap&&(x.roughnessMap.value=v.roughnessMap),v.metalnessMap&&(x.metalnessMap.value=v.metalnessMap),v.emissiveMap&&(x.emissiveMap.value=v.emissiveMap),v.bumpMap&&(x.bumpMap.value=v.bumpMap,x.bumpScale.value=v.bumpScale,v.side===ge&&(x.bumpScale.value*=-1)),v.normalMap&&(x.normalMap.value=v.normalMap,x.normalScale.value.copy(v.normalScale),v.side===ge&&x.normalScale.value.negate()),v.displacementMap&&(x.displacementMap.value=v.displacementMap,x.displacementScale.value=v.displacementScale,x.displacementBias.value=v.displacementBias),o.get(v).envMap&&(x.envMapIntensity.value=v.envMapIntensity)}function g(x,v,N){m(x,v),x.ior.value=v.ior,v.sheen>0&&(x.sheenColor.value.copy(v.sheenColor).multiplyScalar(v.sheen),x.sheenRoughness.value=v.sheenRoughness,v.sheenColorMap&&(x.sheenColorMap.value=v.sheenColorMap),v.sheenRoughnessMap&&(x.sheenRoughnessMap.value=v.sheenRoughnessMap)),v.clearcoat>0&&(x.clearcoat.value=v.clearcoat,x.clearcoatRoughness.value=v.clearcoatRoughness,v.clearcoatMap&&(x.clearcoatMap.value=v.clearcoatMap),v.clearcoatRoughnessMap&&(x.clearcoatRoughnessMap.value=v.clearcoatRoughnessMap),v.clearcoatNormalMap&&(x.clearcoatNormalScale.value.copy(v.clearcoatNormalScale),x.clearcoatNormalMap.value=v.clearcoatNormalMap,v.side===ge&&x.clearcoatNormalScale.value.negate())),v.transmission>0&&(x.transmission.value=v.transmission,x.transmissionSamplerMap.value=N.texture,x.transmissionSamplerSize.value.set(N.width,N.height),v.transmissionMap&&(x.transmissionMap.value=v.transmissionMap),x.thickness.value=v.thickness,v.thicknessMap&&(x.thicknessMap.value=v.thicknessMap),x.attenuationDistance.value=v.attenuationDistance,x.attenuationColor.value.copy(v.attenuationColor)),x.specularIntensity.value=v.specularIntensity,x.specularColor.value.copy(v.specularColor),v.specularIntensityMap&&(x.specularIntensityMap.value=v.specularIntensityMap),v.specularColorMap&&(x.specularColorMap.value=v.specularColorMap)}function _(x,v){v.matcap&&(x.matcap.value=v.matcap),v.bumpMap&&(x.bumpMap.value=v.bumpMap,x.bumpScale.value=v.bumpScale,v.side===ge&&(x.bumpScale.value*=-1)),v.normalMap&&(x.normalMap.value=v.normalMap,x.normalScale.value.copy(v.normalScale),v.side===ge&&x.normalScale.value.negate()),v.displacementMap&&(x.displacementMap.value=v.displacementMap,x.displacementScale.value=v.displacementScale,x.displacementBias.value=v.displacementBias)}function y(x,v){v.displacementMap&&(x.displacementMap.value=v.displacementMap,x.displacementScale.value=v.displacementScale,x.displacementBias.value=v.displacementBias)}function w(x,v){v.displacementMap&&(x.displacementMap.value=v.displacementMap,x.displacementScale.value=v.displacementScale,x.displacementBias.value=v.displacementBias),x.referencePosition.value.copy(v.referencePosition),x.nearDistance.value=v.nearDistance,x.farDistance.value=v.farDistance}function S(x,v){v.bumpMap&&(x.bumpMap.value=v.bumpMap,x.bumpScale.value=v.bumpScale,v.side===ge&&(x.bumpScale.value*=-1)),v.normalMap&&(x.normalMap.value=v.normalMap,x.normalScale.value.copy(v.normalScale),v.side===ge&&x.normalScale.value.negate()),v.displacementMap&&(x.displacementMap.value=v.displacementMap,x.displacementScale.value=v.displacementScale,x.displacementBias.value=v.displacementBias)}return{refreshFogUniforms:t,refreshMaterialUniforms:e}}function i0(){const o=to("canvas");return o.style.display="block",o}function ne(o={}){const t=o.canvas!==void 0?o.canvas:i0(),e=o.context!==void 0?o.context:null,n=o.alpha!==void 0?o.alpha:!1,r=o.depth!==void 0?o.depth:!0,s=o.stencil!==void 0?o.stencil:!0,l=o.antialias!==void 0?o.antialias:!1,h=o.premultipliedAlpha!==void 0?o.premultipliedAlpha:!0,d=o.preserveDrawingBuffer!==void 0?o.preserveDrawingBuffer:!1,p=o.powerPreference!==void 0?o.powerPreference:"default",f=o.failIfMajorPerformanceCaveat!==void 0?o.failIfMajorPerformanceCaveat:!1;let m=null,g=null;const _=[],y=[];this.domElement=t,this.debug={checkShaderErrors:!0},this.autoClear=!0,this.autoClearColor=!0,this.autoClearDepth=!0,this.autoClearStencil=!0,this.sortObjects=!0,this.clippingPlanes=[],this.localClippingEnabled=!1,this.outputEncoding=en,this.physicallyCorrectLights=!1,this.toneMapping=qn,this.toneMappingExposure=1;const w=this;let S=!1,x=0,v=0,N=null,M=-1,R=null;const F=new re,k=new re;let j=null,ot=t.width,Y=t.height,V=1,C=null,A=null;const H=new re(0,0,ot,Y),q=new re(0,0,ot,Y);let O=!1;const U=[],X=new no;let _t=!1,J=!1,Z=null;const pt=new At,vt=new D,at={background:null,fog:null,environment:null,overrideMaterial:null,isScene:!0};function Tt(){return N===null?V:1}let Q=e;function zt(E,z){for(let W=0;W<E.length;W++){const G=E[W],K=t.getContext(G,z);if(K!==null)return K}return null}try{const E={alpha:n,depth:r,stencil:s,antialias:l,premultipliedAlpha:h,preserveDrawingBuffer:d,powerPreference:p,failIfMajorPerformanceCaveat:f};if("setAttribute"in t&&t.setAttribute("data-engine",`three.js r${Da}`),t.addEventListener("webglcontextlost",Lt,!1),t.addEventListener("webglcontextrestored",bt,!1),Q===null){const z=["webgl2","webgl","experimental-webgl"];if(w.isWebGL1Renderer===!0&&z.shift(),Q=zt(z,E),Q===null)throw zt(z)?new Error("Error creating WebGL context with your selected attributes."):new Error("Error creating WebGL context.")}Q.getShaderPrecisionFormat===void 0&&(Q.getShaderPrecisionFormat=function(){return{rangeMin:1,rangeMax:1,precision:1}})}catch(E){throw console.error("THREE.WebGLRenderer: "+E.message),E}let wt,yt,Mt,Ot,$,rt,ct,xt,ht,Pt,Vt,Ut,ie,L,T,tt,et,mt,nt,It,Ct,ut,I;function dt(){wt=new Mx(Q),yt=new gx(Q,wt,o),wt.init(yt),ut=new Qb(Q,wt,yt),Mt=new Zb(Q,wt,yt),U[0]=1029,Ot=new Tx(Q),$=new Ob,rt=new Kb(Q,wt,Mt,$,yt,ut,Ot),ct=new _x(w),xt=new wx(w),ht=new Og(Q,yt),I=new fx(Q,wt,ht,yt),Pt=new Sx(Q,ht,Ot,I),Vt=new Lx(Q,Pt,ht,Ot),nt=new Px(Q,yt,rt),tt=new vx($),Ut=new zb(w,ct,xt,wt,yt,I,tt),ie=new n0($),L=new Hb,T=new $b(wt,yt),mt=new px(w,ct,Mt,Vt,h),et=new uu(w,Vt,yt),It=new mx(Q,wt,Ot,yt),Ct=new Ex(Q,wt,Ot,yt),Ot.programs=Ut.programs,w.capabilities=yt,w.extensions=wt,w.properties=$,w.renderLists=L,w.shadowMap=et,w.state=Mt,w.info=Ot}dt();const lt=new e0(w,Q);this.xr=lt,this.getContext=function(){return Q},this.getContextAttributes=function(){return Q.getContextAttributes()},this.forceContextLoss=function(){const E=wt.get("WEBGL_lose_context");E&&E.loseContext()},this.forceContextRestore=function(){const E=wt.get("WEBGL_lose_context");E&&E.restoreContext()},this.getPixelRatio=function(){return V},this.setPixelRatio=function(E){E!==void 0&&(V=E,this.setSize(ot,Y,!1))},this.getSize=function(E){return E.set(ot,Y)},this.setSize=function(E,z,W){if(lt.isPresenting){console.warn("THREE.WebGLRenderer: Can't change size while VR device is presenting.");return}ot=E,Y=z,t.width=Math.floor(E*V),t.height=Math.floor(z*V),W!==!1&&(t.style.width=E+"px",t.style.height=z+"px"),this.setViewport(0,0,E,z)},this.getDrawingBufferSize=function(E){return E.set(ot*V,Y*V).floor()},this.setDrawingBufferSize=function(E,z,W){ot=E,Y=z,V=W,t.width=Math.floor(E*W),t.height=Math.floor(z*W),this.setViewport(0,0,E,z)},this.getCurrentViewport=function(E){return E.copy(F)},this.getViewport=function(E){return E.copy(H)},this.setViewport=function(E,z,W,G){E.isVector4?H.set(E.x,E.y,E.z,E.w):H.set(E,z,W,G),Mt.viewport(F.copy(H).multiplyScalar(V).floor())},this.getScissor=function(E){return E.copy(q)},this.setScissor=function(E,z,W,G){E.isVector4?q.set(E.x,E.y,E.z,E.w):q.set(E,z,W,G),Mt.scissor(k.copy(q).multiplyScalar(V).floor())},this.getScissorTest=function(){return O},this.setScissorTest=function(E){Mt.setScissorTest(O=E)},this.setOpaqueSort=function(E){C=E},this.setTransparentSort=function(E){A=E},this.getClearColor=function(E){return E.copy(mt.getClearColor())},this.setClearColor=function(){mt.setClearColor.apply(mt,arguments)},this.getClearAlpha=function(){return mt.getClearAlpha()},this.setClearAlpha=function(){mt.setClearAlpha.apply(mt,arguments)},this.clear=function(E,z,W){let G=0;(E===void 0||E)&&(G|=16384),(z===void 0||z)&&(G|=256),(W===void 0||W)&&(G|=1024),Q.clear(G)},this.clearColor=function(){this.clear(!0,!1,!1)},this.clearDepth=function(){this.clear(!1,!0,!1)},this.clearStencil=function(){this.clear(!1,!1,!0)},this.dispose=function(){t.removeEventListener("webglcontextlost",Lt,!1),t.removeEventListener("webglcontextrestored",bt,!1),L.dispose(),T.dispose(),$.dispose(),ct.dispose(),xt.dispose(),Vt.dispose(),I.dispose(),Ut.dispose(),lt.dispose(),lt.removeEventListener("sessionstart",De),lt.removeEventListener("sessionend",Ie),Z&&(Z.dispose(),Z=null),dn.stop()};function Lt(E){E.preventDefault(),console.log("THREE.WebGLRenderer: Context Lost."),S=!0}function bt(){console.log("THREE.WebGLRenderer: Context Restored."),S=!1;const E=Ot.autoReset,z=et.enabled,W=et.autoUpdate,G=et.needsUpdate,K=et.type;dt(),Ot.autoReset=E,et.enabled=z,et.autoUpdate=W,et.needsUpdate=G,et.type=K}function Ft(E){const z=E.target;z.removeEventListener("dispose",Ft),ft(z)}function ft(E){Nt(E),$.remove(E)}function Nt(E){const z=$.get(E).programs;z!==void 0&&(z.forEach(function(W){Ut.releaseProgram(W)}),E.isShaderMaterial&&Ut.releaseShaderCache(E))}this.renderBufferDirect=function(E,z,W,G,K,kt){z===null&&(z=at);const Bt=K.isMesh&&K.matrixWorld.determinant()<0,Ht=rn(E,z,W,G,K);Mt.setMaterial(G,Bt);let Rt=W.index;const Xt=W.attributes.position;if(Rt===null){if(Xt===void 0||Xt.count===0)return}else if(Rt.count===0)return;let Gt=1;G.wireframe===!0&&(Rt=Pt.getWireframeAttribute(W),Gt=2),I.setup(K,G,Ht,W,Rt);let Wt,oe=It;Rt!==null&&(Wt=ht.get(Rt),oe=Ct,oe.setIndex(Wt));const pn=Rt!==null?Rt.count:Xt.count,sn=W.drawRange.start*Gt,Yt=W.drawRange.count*Gt,Me=kt!==null?kt.start*Gt:0,ue=kt!==null?kt.count*Gt:1/0,ze=Math.max(sn,Me),mi=Math.min(pn,sn+Yt,Me+ue)-1,Oe=Math.max(0,mi-ze+1);if(Oe!==0){if(K.isMesh)G.wireframe===!0?(Mt.setLineWidth(G.wireframeLinewidth*Tt()),oe.setMode(1)):oe.setMode(4);else if(K.isLine){let Ze=G.linewidth;Ze===void 0&&(Ze=1),Mt.setLineWidth(Ze*Tt()),K.isLineSegments?oe.setMode(1):K.isLineLoop?oe.setMode(2):oe.setMode(3)}else K.isPoints?oe.setMode(0):K.isSprite&&oe.setMode(4);if(K.isInstancedMesh)oe.renderInstances(ze,Oe,K.count);else if(W.isInstancedBufferGeometry){const Ze=Math.min(W.instanceCount,W._maxInstanceCount);oe.renderInstances(ze,Oe,Ze)}else oe.render(ze,Oe)}},this.compile=function(E,z){g=T.get(E),g.init(),y.push(g),E.traverseVisible(function(W){W.isLight&&W.layers.test(z.layers)&&(g.pushLight(W),W.castShadow&&g.pushShadow(W))}),g.setupLights(w.physicallyCorrectLights),E.traverse(function(W){const G=W.material;if(G)if(Array.isArray(G))for(let K=0;K<G.length;K++){const kt=G[K];Ne(kt,E,W)}else Ne(G,E,W)}),y.pop(),g=null};let ee=null;function Zt(E){ee&&ee(E)}function De(){dn.stop()}function Ie(){dn.start()}const dn=new Zh;dn.setAnimationLoop(Zt),typeof window!="undefined"&&dn.setContext(window),this.setAnimationLoop=function(E){ee=E,lt.setAnimationLoop(E),E===null?dn.stop():dn.start()},lt.addEventListener("sessionstart",De),lt.addEventListener("sessionend",Ie),this.render=function(E,z){if(z!==void 0&&z.isCamera!==!0){console.error("THREE.WebGLRenderer.render: camera is not an instance of THREE.Camera.");return}if(S===!0)return;E.autoUpdate===!0&&E.updateMatrixWorld(),z.parent===null&&z.updateMatrixWorld(),lt.enabled===!0&&lt.isPresenting===!0&&(lt.cameraAutoUpdate===!0&&lt.updateCamera(z),z=lt.getCamera()),E.isScene===!0&&E.onBeforeRender(w,E,z,N),g=T.get(E,y.length),g.init(),y.push(g),pt.multiplyMatrices(z.projectionMatrix,z.matrixWorldInverse),X.setFromProjectionMatrix(pt),J=this.localClippingEnabled,_t=tt.init(this.clippingPlanes,J,z),m=L.get(E,_.length),m.init(),_.push(m),Kr(E,z,0,w.sortObjects),m.finish(),w.sortObjects===!0&&m.sort(C,A),_t===!0&&tt.beginShadows();const W=g.state.shadowsArray;if(et.render(W,E,z),_t===!0&&tt.endShadows(),this.info.autoReset===!0&&this.info.reset(),mt.render(m,E),g.setupLights(w.physicallyCorrectLights),z.isArrayCamera){const G=z.cameras;for(let K=0,kt=G.length;K<kt;K++){const Bt=G[K];Qr(m,E,Bt,Bt.viewport)}}else Qr(m,E,z);N!==null&&(rt.updateMultisampleRenderTarget(N),rt.updateRenderTargetMipmap(N)),E.isScene===!0&&E.onAfterRender(w,E,z),Mt.buffers.depth.setTest(!0),Mt.buffers.depth.setMask(!0),Mt.buffers.color.setMask(!0),Mt.setPolygonOffset(!1),I.resetDefaultState(),M=-1,R=null,y.pop(),y.length>0?g=y[y.length-1]:g=null,_.pop(),_.length>0?m=_[_.length-1]:m=null};function Kr(E,z,W,G){if(E.visible===!1)return;if(E.layers.test(z.layers)){if(E.isGroup)W=E.renderOrder;else if(E.isLOD)E.autoUpdate===!0&&E.update(z);else if(E.isLight)g.pushLight(E),E.castShadow&&g.pushShadow(E);else if(E.isSprite){if(!E.frustumCulled||X.intersectsSprite(E)){G&&vt.setFromMatrixPosition(E.matrixWorld).applyMatrix4(pt);const Bt=Vt.update(E),Ht=E.material;Ht.visible&&m.push(E,Bt,Ht,W,vt.z,null)}}else if((E.isMesh||E.isLine||E.isPoints)&&(E.isSkinnedMesh&&E.skeleton.frame!==Ot.render.frame&&(E.skeleton.update(),E.skeleton.frame=Ot.render.frame),!E.frustumCulled||X.intersectsObject(E))){G&&vt.setFromMatrixPosition(E.matrixWorld).applyMatrix4(pt);const Bt=Vt.update(E),Ht=E.material;if(Array.isArray(Ht)){const Rt=Bt.groups;for(let Xt=0,Gt=Rt.length;Xt<Gt;Xt++){const Wt=Rt[Xt],oe=Ht[Wt.materialIndex];oe&&oe.visible&&m.push(E,Bt,oe,W,vt.z,Wt)}}else Ht.visible&&m.push(E,Bt,Ht,W,vt.z,null)}}const kt=E.children;for(let Bt=0,Ht=kt.length;Bt<Ht;Bt++)Kr(kt[Bt],z,W,G)}function Qr(E,z,W,G){const K=E.opaque,kt=E.transmissive,Bt=E.transparent;g.setupLightsView(W),kt.length>0&&lo(K,z,W),G&&Mt.viewport(F.copy(G)),K.length>0&&An(K,z,W),kt.length>0&&An(kt,z,W),Bt.length>0&&An(Bt,z,W)}function lo(E,z,W){if(Z===null){const Bt=l===!0&&yt.isWebGL2===!0?Fa:Ye;Z=new Bt(1024,1024,{generateMipmaps:!0,type:ut.convert(ci)!==null?ci:En,minFilter:Qs,magFilter:ve,wrapS:qe,wrapT:qe,useRenderToTexture:wt.has("WEBGL_multisampled_render_to_texture")})}const G=w.getRenderTarget();w.setRenderTarget(Z),w.clear();const K=w.toneMapping;w.toneMapping=qn,An(E,z,W),w.toneMapping=K,rt.updateMultisampleRenderTarget(Z),rt.updateRenderTargetMipmap(Z),w.setRenderTarget(G)}function An(E,z,W){const G=z.isScene===!0?z.overrideMaterial:null;for(let K=0,kt=E.length;K<kt;K++){const Bt=E[K],Ht=Bt.object,Rt=Bt.geometry,Xt=G===null?Bt.material:G,Gt=Bt.group;Ht.layers.test(W.layers)&&lr(Ht,z,W,Rt,Xt,Gt)}}function lr(E,z,W,G,K,kt){E.onBeforeRender(w,z,W,G,K,kt),E.modelViewMatrix.multiplyMatrices(W.matrixWorldInverse,E.matrixWorld),E.normalMatrix.getNormalMatrix(E.modelViewMatrix),K.onBeforeRender(w,z,W,G,E,kt),K.transparent===!0&&K.side===$i?(K.side=ge,K.needsUpdate=!0,w.renderBufferDirect(W,z,G,K,E,kt),K.side=zr,K.needsUpdate=!0,w.renderBufferDirect(W,z,G,K,E,kt),K.side=$i):w.renderBufferDirect(W,z,G,K,E,kt),E.onAfterRender(w,z,W,G,K,kt)}function Ne(E,z,W){z.isScene!==!0&&(z=at);const G=$.get(E),K=g.state.lights,kt=g.state.shadowsArray,Bt=K.state.version,Ht=Ut.getParameters(E,K.state,kt,z,W),Rt=Ut.getProgramCacheKey(Ht);let Xt=G.programs;G.environment=E.isMeshStandardMaterial?z.environment:null,G.fog=z.fog,G.envMap=(E.isMeshStandardMaterial?xt:ct).get(E.envMap||G.environment),Xt===void 0&&(E.addEventListener("dispose",Ft),Xt=new Map,G.programs=Xt);let Gt=Xt.get(Rt);if(Gt!==void 0){if(G.currentProgram===Gt&&G.lightsStateVersion===Bt)return fi(E,Ht),Gt}else Ht.uniforms=Ut.getUniforms(E),E.onBuild(W,Ht,w),E.onBeforeCompile(Ht,w),Gt=Ut.acquireProgram(Ht,Rt),Xt.set(Rt,Gt),G.uniforms=Ht.uniforms;const Wt=G.uniforms;(!E.isShaderMaterial&&!E.isRawShaderMaterial||E.clipping===!0)&&(Wt.clippingPlanes=tt.uniform),fi(E,Ht),G.needsLights=Zn(E),G.lightsStateVersion=Bt,G.needsLights&&(Wt.ambientLightColor.value=K.state.ambient,Wt.lightProbe.value=K.state.probe,Wt.directionalLights.value=K.state.directional,Wt.directionalLightShadows.value=K.state.directionalShadow,Wt.spotLights.value=K.state.spot,Wt.spotLightShadows.value=K.state.spotShadow,Wt.rectAreaLights.value=K.state.rectArea,Wt.ltc_1.value=K.state.rectAreaLTC1,Wt.ltc_2.value=K.state.rectAreaLTC2,Wt.pointLights.value=K.state.point,Wt.pointLightShadows.value=K.state.pointShadow,Wt.hemisphereLights.value=K.state.hemi,Wt.directionalShadowMap.value=K.state.directionalShadowMap,Wt.directionalShadowMatrix.value=K.state.directionalShadowMatrix,Wt.spotShadowMap.value=K.state.spotShadowMap,Wt.spotShadowMatrix.value=K.state.spotShadowMatrix,Wt.pointShadowMap.value=K.state.pointShadowMap,Wt.pointShadowMatrix.value=K.state.pointShadowMatrix);const oe=Gt.getUniforms(),pn=Xn.seqWithValue(oe.seq,Wt);return G.currentProgram=Gt,G.uniformsList=pn,Gt}function fi(E,z){const W=$.get(E);W.outputEncoding=z.outputEncoding,W.instancing=z.instancing,W.skinning=z.skinning,W.morphTargets=z.morphTargets,W.morphNormals=z.morphNormals,W.morphTargetsCount=z.morphTargetsCount,W.numClippingPlanes=z.numClippingPlanes,W.numIntersection=z.numClipIntersection,W.vertexAlphas=z.vertexAlphas,W.vertexTangents=z.vertexTangents,W.toneMapping=z.toneMapping}function rn(E,z,W,G,K){z.isScene!==!0&&(z=at),rt.resetTextureUnits();const kt=z.fog,Bt=G.isMeshStandardMaterial?z.environment:null,Ht=N===null?w.outputEncoding:N.texture.encoding,Rt=(G.isMeshStandardMaterial?xt:ct).get(G.envMap||Bt),Xt=G.vertexColors===!0&&!!W.attributes.color&&W.attributes.color.itemSize===4,Gt=!!G.normalMap&&!!W.attributes.tangent,Wt=!!W.morphAttributes.position,oe=!!W.morphAttributes.normal,pn=W.morphAttributes.position?W.morphAttributes.position.length:0,sn=G.toneMapped?w.toneMapping:qn,Yt=$.get(G),Me=g.state.lights;if(_t===!0&&(J===!0||E!==R)){const Ue=E===R&&G.id===M;tt.setState(G,E,Ue)}let ue=!1;G.version===Yt.__version?(Yt.needsLights&&Yt.lightsStateVersion!==Me.state.version||Yt.outputEncoding!==Ht||K.isInstancedMesh&&Yt.instancing===!1||!K.isInstancedMesh&&Yt.instancing===!0||K.isSkinnedMesh&&Yt.skinning===!1||!K.isSkinnedMesh&&Yt.skinning===!0||Yt.envMap!==Rt||G.fog&&Yt.fog!==kt||Yt.numClippingPlanes!==void 0&&(Yt.numClippingPlanes!==tt.numPlanes||Yt.numIntersection!==tt.numIntersection)||Yt.vertexAlphas!==Xt||Yt.vertexTangents!==Gt||Yt.morphTargets!==Wt||Yt.morphNormals!==oe||Yt.toneMapping!==sn||yt.isWebGL2===!0&&Yt.morphTargetsCount!==pn)&&(ue=!0):(ue=!0,Yt.__version=G.version);let ze=Yt.currentProgram;ue===!0&&(ze=Ne(G,z,K));let mi=!1,Oe=!1,Ze=!1;const de=ze.getUniforms(),Kn=Yt.uniforms;if(Mt.useProgram(ze.program)&&(mi=!0,Oe=!0,Ze=!0),G.id!==M&&(M=G.id,Oe=!0),mi||R!==E){if(de.setValue(Q,"projectionMatrix",E.projectionMatrix),yt.logarithmicDepthBuffer&&de.setValue(Q,"logDepthBufFC",2/(Math.log(E.far+1)/Math.LN2)),R!==E&&(R=E,Oe=!0,Ze=!0),G.isShaderMaterial||G.isMeshPhongMaterial||G.isMeshToonMaterial||G.isMeshStandardMaterial||G.envMap){const Ue=de.map.cameraPosition;Ue!==void 0&&Ue.setValue(Q,vt.setFromMatrixPosition(E.matrixWorld))}(G.isMeshPhongMaterial||G.isMeshToonMaterial||G.isMeshLambertMaterial||G.isMeshBasicMaterial||G.isMeshStandardMaterial||G.isShaderMaterial)&&de.setValue(Q,"isOrthographic",E.isOrthographicCamera===!0),(G.isMeshPhongMaterial||G.isMeshToonMaterial||G.isMeshLambertMaterial||G.isMeshBasicMaterial||G.isMeshStandardMaterial||G.isShaderMaterial||G.isShadowMaterial||K.isSkinnedMesh)&&de.setValue(Q,"viewMatrix",E.matrixWorldInverse)}if(K.isSkinnedMesh){de.setOptional(Q,K,"bindMatrix"),de.setOptional(Q,K,"bindMatrixInverse");const Ue=K.skeleton;Ue&&(yt.floatVertexTextures?(Ue.boneTexture===null&&Ue.computeBoneTexture(),de.setValue(Q,"boneTexture",Ue.boneTexture,rt),de.setValue(Q,"boneTextureSize",Ue.boneTextureSize)):de.setOptional(Q,Ue,"boneMatrices"))}return!!W&&(W.morphAttributes.position!==void 0||W.morphAttributes.normal!==void 0)&&nt.update(K,W,G,ze),(Oe||Yt.receiveShadow!==K.receiveShadow)&&(Yt.receiveShadow=K.receiveShadow,de.setValue(Q,"receiveShadow",K.receiveShadow)),Oe&&(de.setValue(Q,"toneMappingExposure",w.toneMappingExposure),Yt.needsLights&&co(Kn,Ze),kt&&G.fog&&ie.refreshFogUniforms(Kn,kt),ie.refreshMaterialUniforms(Kn,G,V,Y,Z),Xn.upload(Q,Yt.uniformsList,Kn,rt)),G.isShaderMaterial&&G.uniformsNeedUpdate===!0&&(Xn.upload(Q,Yt.uniformsList,Kn,rt),G.uniformsNeedUpdate=!1),G.isSpriteMaterial&&de.setValue(Q,"center",K.center),de.setValue(Q,"modelViewMatrix",K.modelViewMatrix),de.setValue(Q,"normalMatrix",K.normalMatrix),de.setValue(Q,"modelMatrix",K.matrixWorld),ze}function co(E,z){E.ambientLightColor.needsUpdate=z,E.lightProbe.needsUpdate=z,E.directionalLights.needsUpdate=z,E.directionalLightShadows.needsUpdate=z,E.pointLights.needsUpdate=z,E.pointLightShadows.needsUpdate=z,E.spotLights.needsUpdate=z,E.spotLightShadows.needsUpdate=z,E.rectAreaLights.needsUpdate=z,E.hemisphereLights.needsUpdate=z}function Zn(E){return E.isMeshLambertMaterial||E.isMeshToonMaterial||E.isMeshPhongMaterial||E.isMeshStandardMaterial||E.isShadowMaterial||E.isShaderMaterial&&E.lights===!0}this.getActiveCubeFace=function(){return x},this.getActiveMipmapLevel=function(){return v},this.getRenderTarget=function(){return N},this.setRenderTargetTextures=function(E,z,W){$.get(E.texture).__webglTexture=z,$.get(E.depthTexture).__webglTexture=W;const G=$.get(E);G.__hasExternalTextures=!0,G.__hasExternalTextures&&(G.__autoAllocateDepthBuffer=W===void 0,G.__autoAllocateDepthBuffer||E.useRenderToTexture&&(console.warn("render-to-texture extension was disabled because an external texture was provided"),E.useRenderToTexture=!1,E.useRenderbuffer=!0))},this.setRenderTargetFramebuffer=function(E,z){const W=$.get(E);W.__webglFramebuffer=z,W.__useDefaultFramebuffer=z===void 0},this.setRenderTarget=function(E,z=0,W=0){N=E,x=z,v=W;let G=!0;if(E){const Rt=$.get(E);Rt.__useDefaultFramebuffer!==void 0?(Mt.bindFramebuffer(36160,null),G=!1):Rt.__webglFramebuffer===void 0?rt.setupRenderTarget(E):Rt.__hasExternalTextures&&rt.rebindTextures(E,$.get(E.texture).__webglTexture,$.get(E.depthTexture).__webglTexture)}let K=null,kt=!1,Bt=!1;if(E){const Rt=E.texture;(Rt.isDataTexture3D||Rt.isDataTexture2DArray)&&(Bt=!0);const Xt=$.get(E).__webglFramebuffer;E.isWebGLCubeRenderTarget?(K=Xt[z],kt=!0):E.useRenderbuffer?K=$.get(E).__webglMultisampledFramebuffer:K=Xt,F.copy(E.viewport),k.copy(E.scissor),j=E.scissorTest}else F.copy(H).multiplyScalar(V).floor(),k.copy(q).multiplyScalar(V).floor(),j=O;if(Mt.bindFramebuffer(36160,K)&&yt.drawBuffers&&G){let Rt=!1;if(E)if(E.isWebGLMultipleRenderTargets){const Xt=E.texture;if(U.length!==Xt.length||U[0]!==36064){for(let Gt=0,Wt=Xt.length;Gt<Wt;Gt++)U[Gt]=36064+Gt;U.length=Xt.length,Rt=!0}}else(U.length!==1||U[0]!==36064)&&(U[0]=36064,U.length=1,Rt=!0);else(U.length!==1||U[0]!==1029)&&(U[0]=1029,U.length=1,Rt=!0);Rt&&(yt.isWebGL2?Q.drawBuffers(U):wt.get("WEBGL_draw_buffers").drawBuffersWEBGL(U))}if(Mt.viewport(F),Mt.scissor(k),Mt.setScissorTest(j),kt){const Rt=$.get(E.texture);Q.framebufferTexture2D(36160,36064,34069+z,Rt.__webglTexture,W)}else if(Bt){const Rt=$.get(E.texture),Xt=z||0;Q.framebufferTextureLayer(36160,36064,Rt.__webglTexture,W||0,Xt)}M=-1},this.readRenderTargetPixels=function(E,z,W,G,K,kt,Bt){if(!(E&&E.isWebGLRenderTarget)){console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget.");return}let Ht=$.get(E).__webglFramebuffer;if(E.isWebGLCubeRenderTarget&&Bt!==void 0&&(Ht=Ht[Bt]),Ht){Mt.bindFramebuffer(36160,Ht);try{const Rt=E.texture,Xt=Rt.format,Gt=Rt.type;if(Xt!==be&&ut.convert(Xt)!==Q.getParameter(35739)){console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in RGBA or implementation defined format.");return}const Wt=Gt===ci&&(wt.has("EXT_color_buffer_half_float")||yt.isWebGL2&&wt.has("EXT_color_buffer_float"));if(Gt!==En&&ut.convert(Gt)!==Q.getParameter(35738)&&!(Gt===Gn&&(yt.isWebGL2||wt.has("OES_texture_float")||wt.has("WEBGL_color_buffer_float")))&&!Wt){console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in UnsignedByteType or implementation defined type.");return}Q.checkFramebufferStatus(36160)===36053?z>=0&&z<=E.width-G&&W>=0&&W<=E.height-K&&Q.readPixels(z,W,G,K,ut.convert(Xt),ut.convert(Gt),kt):console.error("THREE.WebGLRenderer.readRenderTargetPixels: readPixels from renderTarget failed. Framebuffer not complete.")}finally{const Rt=N!==null?$.get(N).__webglFramebuffer:null;Mt.bindFramebuffer(36160,Rt)}}},this.copyFramebufferToTexture=function(E,z,W=0){if(z.isFramebufferTexture!==!0){console.error("THREE.WebGLRenderer: copyFramebufferToTexture() can only be used with FramebufferTexture.");return}const G=Math.pow(2,-W),K=Math.floor(z.image.width*G),kt=Math.floor(z.image.height*G);rt.setTexture2D(z,0),Q.copyTexSubImage2D(3553,W,0,0,E.x,E.y,K,kt),Mt.unbindTexture()},this.copyTextureToTexture=function(E,z,W,G=0){const K=z.image.width,kt=z.image.height,Bt=ut.convert(W.format),Ht=ut.convert(W.type);rt.setTexture2D(W,0),Q.pixelStorei(37440,W.flipY),Q.pixelStorei(37441,W.premultiplyAlpha),Q.pixelStorei(3317,W.unpackAlignment),z.isDataTexture?Q.texSubImage2D(3553,G,E.x,E.y,K,kt,Bt,Ht,z.image.data):z.isCompressedTexture?Q.compressedTexSubImage2D(3553,G,E.x,E.y,z.mipmaps[0].width,z.mipmaps[0].height,Bt,z.mipmaps[0].data):Q.texSubImage2D(3553,G,E.x,E.y,Bt,Ht,z.image),G===0&&W.generateMipmaps&&Q.generateMipmap(3553),Mt.unbindTexture()},this.copyTextureToTexture3D=function(E,z,W,G,K=0){if(w.isWebGL1Renderer){console.warn("THREE.WebGLRenderer.copyTextureToTexture3D: can only be used with WebGL2.");return}const kt=E.max.x-E.min.x+1,Bt=E.max.y-E.min.y+1,Ht=E.max.z-E.min.z+1,Rt=ut.convert(G.format),Xt=ut.convert(G.type);let Gt;if(G.isDataTexture3D)rt.setTexture3D(G,0),Gt=32879;else if(G.isDataTexture2DArray)rt.setTexture2DArray(G,0),Gt=35866;else{console.warn("THREE.WebGLRenderer.copyTextureToTexture3D: only supports THREE.DataTexture3D and THREE.DataTexture2DArray.");return}Q.pixelStorei(37440,G.flipY),Q.pixelStorei(37441,G.premultiplyAlpha),Q.pixelStorei(3317,G.unpackAlignment);const Wt=Q.getParameter(3314),oe=Q.getParameter(32878),pn=Q.getParameter(3316),sn=Q.getParameter(3315),Yt=Q.getParameter(32877),Me=W.isCompressedTexture?W.mipmaps[0]:W.image;Q.pixelStorei(3314,Me.width),Q.pixelStorei(32878,Me.height),Q.pixelStorei(3316,E.min.x),Q.pixelStorei(3315,E.min.y),Q.pixelStorei(32877,E.min.z),W.isDataTexture||W.isDataTexture3D?Q.texSubImage3D(Gt,K,z.x,z.y,z.z,kt,Bt,Ht,Rt,Xt,Me.data):W.isCompressedTexture?(console.warn("THREE.WebGLRenderer.copyTextureToTexture3D: untested support for compressed srcTexture."),Q.compressedTexSubImage3D(Gt,K,z.x,z.y,z.z,kt,Bt,Ht,Rt,Me.data)):Q.texSubImage3D(Gt,K,z.x,z.y,z.z,kt,Bt,Ht,Rt,Xt,Me),Q.pixelStorei(3314,Wt),Q.pixelStorei(32878,oe),Q.pixelStorei(3316,pn),Q.pixelStorei(3315,sn),Q.pixelStorei(32877,Yt),K===0&&G.generateMipmaps&&Q.generateMipmap(Gt),Mt.unbindTexture()},this.initTexture=function(E){rt.setTexture2D(E,0),Mt.unbindTexture()},this.resetState=function(){x=0,v=0,N=null,Mt.reset(),I.reset()},typeof __THREE_DEVTOOLS__!="undefined"&&__THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("observe",{detail:this}))}ne.prototype.isWebGLRenderer=!0;class r0 extends ne{}r0.prototype.isWebGL1Renderer=!0;class pu extends te{constructor(){super(),this.type="Scene",this.background=null,this.environment=null,this.fog=null,this.overrideMaterial=null,this.autoUpdate=!0,typeof __THREE_DEVTOOLS__!="undefined"&&__THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("observe",{detail:this}))}copy(t,e){return super.copy(t,e),t.background!==null&&(this.background=t.background.clone()),t.environment!==null&&(this.environment=t.environment.clone()),t.fog!==null&&(this.fog=t.fog.clone()),t.overrideMaterial!==null&&(this.overrideMaterial=t.overrideMaterial.clone()),this.autoUpdate=t.autoUpdate,this.matrixAutoUpdate=t.matrixAutoUpdate,this}toJSON(t){const e=super.toJSON(t);return this.fog!==null&&(e.object.fog=this.fog.toJSON()),e}}pu.prototype.isScene=!0;class Yr{constructor(t,e){this.array=t,this.stride=e,this.count=t!==void 0?t.length/e:0,this.usage=Ur,this.updateRange={offset:0,count:-1},this.version=0,this.uuid=cn()}onUploadCallback(){}set needsUpdate(t){t===!0&&this.version++}setUsage(t){return this.usage=t,this}copy(t){return this.array=new t.array.constructor(t.array),this.count=t.count,this.stride=t.stride,this.usage=t.usage,this}copyAt(t,e,n){t*=this.stride,n*=e.stride;for(let r=0,s=this.stride;r<s;r++)this.array[t+r]=e.array[n+r];return this}set(t,e=0){return this.array.set(t,e),this}clone(t){t.arrayBuffers===void 0&&(t.arrayBuffers={}),this.array.buffer._uuid===void 0&&(this.array.buffer._uuid=cn()),t.arrayBuffers[this.array.buffer._uuid]===void 0&&(t.arrayBuffers[this.array.buffer._uuid]=this.array.slice(0).buffer);const e=new this.array.constructor(t.arrayBuffers[this.array.buffer._uuid]),n=new this.constructor(e,this.stride);return n.setUsage(this.usage),n}onUpload(t){return this.onUploadCallback=t,this}toJSON(t){return t.arrayBuffers===void 0&&(t.arrayBuffers={}),this.array.buffer._uuid===void 0&&(this.array.buffer._uuid=cn()),t.arrayBuffers[this.array.buffer._uuid]===void 0&&(t.arrayBuffers[this.array.buffer._uuid]=Array.prototype.slice.call(new Uint32Array(this.array.buffer))),{uuid:this.uuid,buffer:this.array.buffer._uuid,type:this.array.constructor.name,stride:this.stride}}}Yr.prototype.isInterleavedBuffer=!0;const pe=new D;class Hr{constructor(t,e,n,r=!1){this.name="",this.data=t,this.itemSize=e,this.offset=n,this.normalized=r===!0}get count(){return this.data.count}get array(){return this.data.array}set needsUpdate(t){this.data.needsUpdate=t}applyMatrix4(t){for(let e=0,n=this.data.count;e<n;e++)pe.x=this.getX(e),pe.y=this.getY(e),pe.z=this.getZ(e),pe.applyMatrix4(t),this.setXYZ(e,pe.x,pe.y,pe.z);return this}applyNormalMatrix(t){for(let e=0,n=this.count;e<n;e++)pe.x=this.getX(e),pe.y=this.getY(e),pe.z=this.getZ(e),pe.applyNormalMatrix(t),this.setXYZ(e,pe.x,pe.y,pe.z);return this}transformDirection(t){for(let e=0,n=this.count;e<n;e++)pe.x=this.getX(e),pe.y=this.getY(e),pe.z=this.getZ(e),pe.transformDirection(t),this.setXYZ(e,pe.x,pe.y,pe.z);return this}setX(t,e){return this.data.array[t*this.data.stride+this.offset]=e,this}setY(t,e){return this.data.array[t*this.data.stride+this.offset+1]=e,this}setZ(t,e){return this.data.array[t*this.data.stride+this.offset+2]=e,this}setW(t,e){return this.data.array[t*this.data.stride+this.offset+3]=e,this}getX(t){return this.data.array[t*this.data.stride+this.offset]}getY(t){return this.data.array[t*this.data.stride+this.offset+1]}getZ(t){return this.data.array[t*this.data.stride+this.offset+2]}getW(t){return this.data.array[t*this.data.stride+this.offset+3]}setXY(t,e,n){return t=t*this.data.stride+this.offset,this.data.array[t+0]=e,this.data.array[t+1]=n,this}setXYZ(t,e,n,r){return t=t*this.data.stride+this.offset,this.data.array[t+0]=e,this.data.array[t+1]=n,this.data.array[t+2]=r,this}setXYZW(t,e,n,r,s){return t=t*this.data.stride+this.offset,this.data.array[t+0]=e,this.data.array[t+1]=n,this.data.array[t+2]=r,this.data.array[t+3]=s,this}clone(t){if(t===void 0){console.log("THREE.InterleavedBufferAttribute.clone(): Cloning an interlaved buffer attribute will deinterleave buffer data.");const e=[];for(let n=0;n<this.count;n++){const r=n*this.data.stride+this.offset;for(let s=0;s<this.itemSize;s++)e.push(this.data.array[r+s])}return new _e(new this.array.constructor(e),this.itemSize,this.normalized)}else return t.interleavedBuffers===void 0&&(t.interleavedBuffers={}),t.interleavedBuffers[this.data.uuid]===void 0&&(t.interleavedBuffers[this.data.uuid]=this.data.clone(t)),new Hr(t.interleavedBuffers[this.data.uuid],this.itemSize,this.offset,this.normalized)}toJSON(t){if(t===void 0){console.log("THREE.InterleavedBufferAttribute.toJSON(): Serializing an interlaved buffer attribute will deinterleave buffer data.");const e=[];for(let n=0;n<this.count;n++){const r=n*this.data.stride+this.offset;for(let s=0;s<this.itemSize;s++)e.push(this.data.array[r+s])}return{itemSize:this.itemSize,type:this.array.constructor.name,array:e,normalized:this.normalized}}else return t.interleavedBuffers===void 0&&(t.interleavedBuffers={}),t.interleavedBuffers[this.data.uuid]===void 0&&(t.interleavedBuffers[this.data.uuid]=this.data.toJSON(t)),{isInterleavedBufferAttribute:!0,itemSize:this.itemSize,data:this.data.uuid,offset:this.offset,normalized:this.normalized}}}Hr.prototype.isInterleavedBufferAttribute=!0;class fu extends Pe{constructor(t){super(),this.type="SpriteMaterial",this.color=new Et(16777215),this.map=null,this.alphaMap=null,this.rotation=0,this.sizeAttenuation=!0,this.transparent=!0,this.setValues(t)}copy(t){return super.copy(t),this.color.copy(t.color),this.map=t.map,this.alphaMap=t.alphaMap,this.rotation=t.rotation,this.sizeAttenuation=t.sizeAttenuation,this}}fu.prototype.isSpriteMaterial=!0;let Bi;const Ar=new D,zi=new D,Oi=new D,Ui=new st,Pr=new st,mu=new At,Ls=new D,Lr=new D,Rs=new D,ph=new st,da=new st,fh=new st;class s0 extends te{constructor(t){if(super(),this.type="Sprite",Bi===void 0){Bi=new ce;const e=new Float32Array([-.5,-.5,0,0,0,.5,-.5,0,1,0,.5,.5,0,1,1,-.5,.5,0,0,1]),n=new Yr(e,5);Bi.setIndex([0,1,2,0,2,3]),Bi.setAttribute("position",new Hr(n,3,0,!1)),Bi.setAttribute("uv",new Hr(n,2,3,!1))}this.geometry=Bi,this.material=t!==void 0?t:new fu,this.center=new st(.5,.5)}raycast(t,e){t.camera===null&&console.error('THREE.Sprite: "Raycaster.camera" needs to be set in order to raycast against sprites.'),zi.setFromMatrixScale(this.matrixWorld),mu.copy(t.camera.matrixWorld),this.modelViewMatrix.multiplyMatrices(t.camera.matrixWorldInverse,this.matrixWorld),Oi.setFromMatrixPosition(this.modelViewMatrix),t.camera.isPerspectiveCamera&&this.material.sizeAttenuation===!1&&zi.multiplyScalar(-Oi.z);const n=this.material.rotation;let r,s;n!==0&&(s=Math.cos(n),r=Math.sin(n));const l=this.center;Ds(Ls.set(-.5,-.5,0),Oi,l,zi,r,s),Ds(Lr.set(.5,-.5,0),Oi,l,zi,r,s),Ds(Rs.set(.5,.5,0),Oi,l,zi,r,s),ph.set(0,0),da.set(1,0),fh.set(1,1);let h=t.ray.intersectTriangle(Ls,Lr,Rs,!1,Ar);if(h===null&&(Ds(Lr.set(-.5,.5,0),Oi,l,zi,r,s),da.set(0,1),h=t.ray.intersectTriangle(Ls,Rs,Lr,!1,Ar),h===null))return;const d=t.ray.origin.distanceTo(Ar);d<t.near||d>t.far||e.push({distance:d,point:Ar.clone(),uv:fe.getUV(Ar,Ls,Lr,Rs,ph,da,fh,new st),face:null,object:this})}copy(t){return super.copy(t),t.center!==void 0&&this.center.copy(t.center),this.material=t.material,this}}s0.prototype.isSprite=!0;function Ds(o,t,e,n,r,s){Ui.subVectors(o,e).addScalar(.5).multiply(n),r!==void 0?(Pr.x=s*Ui.x-r*Ui.y,Pr.y=r*Ui.x+s*Ui.y):Pr.copy(Ui),o.copy(t),o.x+=Pr.x,o.y+=Pr.y,o.applyMatrix4(mu)}const mh=new D,gh=new re,vh=new re,o0=new D,_h=new At;class gu extends Ve{constructor(t,e){super(t,e),this.type="SkinnedMesh",this.bindMode="attached",this.bindMatrix=new At,this.bindMatrixInverse=new At}copy(t){return super.copy(t),this.bindMode=t.bindMode,this.bindMatrix.copy(t.bindMatrix),this.bindMatrixInverse.copy(t.bindMatrixInverse),this.skeleton=t.skeleton,this}bind(t,e){this.skeleton=t,e===void 0&&(this.updateMatrixWorld(!0),this.skeleton.calculateInverses(),e=this.matrixWorld),this.bindMatrix.copy(e),this.bindMatrixInverse.copy(e).invert()}pose(){this.skeleton.pose()}normalizeSkinWeights(){const t=new re,e=this.geometry.attributes.skinWeight;for(let n=0,r=e.count;n<r;n++){t.x=e.getX(n),t.y=e.getY(n),t.z=e.getZ(n),t.w=e.getW(n);const s=1/t.manhattanLength();s!==1/0?t.multiplyScalar(s):t.set(1,0,0,0),e.setXYZW(n,t.x,t.y,t.z,t.w)}}updateMatrixWorld(t){super.updateMatrixWorld(t),this.bindMode==="attached"?this.bindMatrixInverse.copy(this.matrixWorld).invert():this.bindMode==="detached"?this.bindMatrixInverse.copy(this.bindMatrix).invert():console.warn("THREE.SkinnedMesh: Unrecognized bindMode: "+this.bindMode)}boneTransform(t,e){const n=this.skeleton,r=this.geometry;gh.fromBufferAttribute(r.attributes.skinIndex,t),vh.fromBufferAttribute(r.attributes.skinWeight,t),mh.copy(e).applyMatrix4(this.bindMatrix),e.set(0,0,0);for(let s=0;s<4;s++){const l=vh.getComponent(s);if(l!==0){const h=gh.getComponent(s);_h.multiplyMatrices(n.bones[h].matrixWorld,n.boneInverses[h]),e.addScaledVector(o0.copy(mh).applyMatrix4(_h),l)}}return e.applyMatrix4(this.bindMatrixInverse)}}gu.prototype.isSkinnedMesh=!0;class a0 extends te{constructor(){super(),this.type="Bone"}}a0.prototype.isBone=!0;class l0 extends we{constructor(t=null,e=1,n=1,r,s,l,h,d,p=ve,f=ve,m,g){super(null,l,h,d,p,f,r,s,m,g),this.image={data:t,width:e,height:n},this.magFilter=p,this.minFilter=f,this.generateMipmaps=!1,this.flipY=!1,this.unpackAlignment=1}}l0.prototype.isDataTexture=!0;class Aa extends _e{constructor(t,e,n,r=1){typeof n=="number"&&(r=n,n=!1,console.error("THREE.InstancedBufferAttribute: The constructor now expects normalized as the third argument.")),super(t,e,n),this.meshPerAttribute=r}copy(t){return super.copy(t),this.meshPerAttribute=t.meshPerAttribute,this}toJSON(){const t=super.toJSON();return t.meshPerAttribute=this.meshPerAttribute,t.isInstancedBufferAttribute=!0,t}}Aa.prototype.isInstancedBufferAttribute=!0;const xh=new At,bh=new At,Is=[],Rr=new Ve;class c0 extends Ve{constructor(t,e,n){super(t,e),this.instanceMatrix=new Aa(new Float32Array(n*16),16),this.instanceColor=null,this.count=n,this.frustumCulled=!1}copy(t){return super.copy(t),this.instanceMatrix.copy(t.instanceMatrix),t.instanceColor!==null&&(this.instanceColor=t.instanceColor.clone()),this.count=t.count,this}getColorAt(t,e){e.fromArray(this.instanceColor.array,t*3)}getMatrixAt(t,e){e.fromArray(this.instanceMatrix.array,t*16)}raycast(t,e){const n=this.matrixWorld,r=this.count;if(Rr.geometry=this.geometry,Rr.material=this.material,Rr.material!==void 0)for(let s=0;s<r;s++){this.getMatrixAt(s,xh),bh.multiplyMatrices(n,xh),Rr.matrixWorld=bh,Rr.raycast(t,Is);for(let l=0,h=Is.length;l<h;l++){const d=Is[l];d.instanceId=s,d.object=this,e.push(d)}Is.length=0}}setColorAt(t,e){this.instanceColor===null&&(this.instanceColor=new Aa(new Float32Array(this.instanceMatrix.count*3),3)),e.toArray(this.instanceColor.array,t*3)}setMatrixAt(t,e){e.toArray(this.instanceMatrix.array,t*16)}updateMorphTargets(){}dispose(){this.dispatchEvent({type:"dispose"})}}c0.prototype.isInstancedMesh=!0;class Jr extends Pe{constructor(t){super(),this.type="LineBasicMaterial",this.color=new Et(16777215),this.linewidth=1,this.linecap="round",this.linejoin="round",this.setValues(t)}copy(t){return super.copy(t),this.color.copy(t.color),this.linewidth=t.linewidth,this.linecap=t.linecap,this.linejoin=t.linejoin,this}}Jr.prototype.isLineBasicMaterial=!0;const yh=new D,wh=new D,Mh=new At,pa=new nr,Ns=new er;class Wa extends te{constructor(t=new ce,e=new Jr){super(),this.type="Line",this.geometry=t,this.material=e,this.updateMorphTargets()}copy(t){return super.copy(t),this.material=t.material,this.geometry=t.geometry,this}computeLineDistances(){const t=this.geometry;if(t.isBufferGeometry)if(t.index===null){const e=t.attributes.position,n=[0];for(let r=1,s=e.count;r<s;r++)yh.fromBufferAttribute(e,r-1),wh.fromBufferAttribute(e,r),n[r]=n[r-1],n[r]+=yh.distanceTo(wh);t.setAttribute("lineDistance",new ye(n,1))}else console.warn("THREE.Line.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.");else t.isGeometry&&console.error("THREE.Line.computeLineDistances() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.");return this}raycast(t,e){const n=this.geometry,r=this.matrixWorld,s=t.params.Line.threshold,l=n.drawRange;if(n.boundingSphere===null&&n.computeBoundingSphere(),Ns.copy(n.boundingSphere),Ns.applyMatrix4(r),Ns.radius+=s,t.ray.intersectsSphere(Ns)===!1)return;Mh.copy(r).invert(),pa.copy(t.ray).applyMatrix4(Mh);const h=s/((this.scale.x+this.scale.y+this.scale.z)/3),d=h*h,p=new D,f=new D,m=new D,g=new D,_=this.isLineSegments?2:1;if(n.isBufferGeometry){const y=n.index,S=n.attributes.position;if(y!==null){const x=Math.max(0,l.start),v=Math.min(y.count,l.start+l.count);for(let N=x,M=v-1;N<M;N+=_){const R=y.getX(N),F=y.getX(N+1);if(p.fromBufferAttribute(S,R),f.fromBufferAttribute(S,F),pa.distanceSqToSegment(p,f,g,m)>d)continue;g.applyMatrix4(this.matrixWorld);const j=t.ray.origin.distanceTo(g);j<t.near||j>t.far||e.push({distance:j,point:m.clone().applyMatrix4(this.matrixWorld),index:N,face:null,faceIndex:null,object:this})}}else{const x=Math.max(0,l.start),v=Math.min(S.count,l.start+l.count);for(let N=x,M=v-1;N<M;N+=_){if(p.fromBufferAttribute(S,N),f.fromBufferAttribute(S,N+1),pa.distanceSqToSegment(p,f,g,m)>d)continue;g.applyMatrix4(this.matrixWorld);const F=t.ray.origin.distanceTo(g);F<t.near||F>t.far||e.push({distance:F,point:m.clone().applyMatrix4(this.matrixWorld),index:N,face:null,faceIndex:null,object:this})}}}else n.isGeometry&&console.error("THREE.Line.raycast() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.")}updateMorphTargets(){const t=this.geometry;if(t.isBufferGeometry){const e=t.morphAttributes,n=Object.keys(e);if(n.length>0){const r=e[n[0]];if(r!==void 0){this.morphTargetInfluences=[],this.morphTargetDictionary={};for(let s=0,l=r.length;s<l;s++){const h=r[s].name||String(s);this.morphTargetInfluences.push(0),this.morphTargetDictionary[h]=s}}}}else{const e=t.morphTargets;e!==void 0&&e.length>0&&console.error("THREE.Line.updateMorphTargets() does not support THREE.Geometry. Use THREE.BufferGeometry instead.")}}}Wa.prototype.isLine=!0;const Sh=new D,Eh=new D;class qa extends Wa{constructor(t,e){super(t,e),this.type="LineSegments"}computeLineDistances(){const t=this.geometry;if(t.isBufferGeometry)if(t.index===null){const e=t.attributes.position,n=[];for(let r=0,s=e.count;r<s;r+=2)Sh.fromBufferAttribute(e,r),Eh.fromBufferAttribute(e,r+1),n[r]=r===0?0:n[r-1],n[r+1]=n[r]+Sh.distanceTo(Eh);t.setAttribute("lineDistance",new ye(n,1))}else console.warn("THREE.LineSegments.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.");else t.isGeometry&&console.error("THREE.LineSegments.computeLineDistances() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.");return this}}qa.prototype.isLineSegments=!0;class h0 extends Wa{constructor(t,e){super(t,e),this.type="LineLoop"}}h0.prototype.isLineLoop=!0;class vu extends Pe{constructor(t){super(),this.type="PointsMaterial",this.color=new Et(16777215),this.map=null,this.alphaMap=null,this.size=1,this.sizeAttenuation=!0,this.setValues(t)}copy(t){return super.copy(t),this.color.copy(t.color),this.map=t.map,this.alphaMap=t.alphaMap,this.size=t.size,this.sizeAttenuation=t.sizeAttenuation,this}}vu.prototype.isPointsMaterial=!0;const Th=new At,Pa=new nr,Fs=new er,ks=new D;class u0 extends te{constructor(t=new ce,e=new vu){super(),this.type="Points",this.geometry=t,this.material=e,this.updateMorphTargets()}copy(t){return super.copy(t),this.material=t.material,this.geometry=t.geometry,this}raycast(t,e){const n=this.geometry,r=this.matrixWorld,s=t.params.Points.threshold,l=n.drawRange;if(n.boundingSphere===null&&n.computeBoundingSphere(),Fs.copy(n.boundingSphere),Fs.applyMatrix4(r),Fs.radius+=s,t.ray.intersectsSphere(Fs)===!1)return;Th.copy(r).invert(),Pa.copy(t.ray).applyMatrix4(Th);const h=s/((this.scale.x+this.scale.y+this.scale.z)/3),d=h*h;if(n.isBufferGeometry){const p=n.index,m=n.attributes.position;if(p!==null){const g=Math.max(0,l.start),_=Math.min(p.count,l.start+l.count);for(let y=g,w=_;y<w;y++){const S=p.getX(y);ks.fromBufferAttribute(m,S),Ch(ks,S,d,r,t,e,this)}}else{const g=Math.max(0,l.start),_=Math.min(m.count,l.start+l.count);for(let y=g,w=_;y<w;y++)ks.fromBufferAttribute(m,y),Ch(ks,y,d,r,t,e,this)}}else console.error("THREE.Points.raycast() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.")}updateMorphTargets(){const t=this.geometry;if(t.isBufferGeometry){const e=t.morphAttributes,n=Object.keys(e);if(n.length>0){const r=e[n[0]];if(r!==void 0){this.morphTargetInfluences=[],this.morphTargetDictionary={};for(let s=0,l=r.length;s<l;s++){const h=r[s].name||String(s);this.morphTargetInfluences.push(0),this.morphTargetDictionary[h]=s}}}}else{const e=t.morphTargets;e!==void 0&&e.length>0&&console.error("THREE.Points.updateMorphTargets() does not support THREE.Geometry. Use THREE.BufferGeometry instead.")}}}u0.prototype.isPoints=!0;function Ch(o,t,e,n,r,s,l){const h=Pa.distanceSqToPoint(o);if(h<e){const d=new D;Pa.closestPointToPoint(o,d),d.applyMatrix4(n);const p=r.ray.origin.distanceTo(d);if(p<r.near||p>r.far)return;s.push({distance:p,distanceToRay:Math.sqrt(h),point:d,index:t,face:null,object:l})}}class d0 extends we{constructor(t,e,n,r,s,l,h,d,p){super(t,e,n,r,s,l,h,d,p),this.format=h!==void 0?h:hi,this.minFilter=l!==void 0?l:Le,this.magFilter=s!==void 0?s:Le,this.generateMipmaps=!1;const f=this;function m(){f.needsUpdate=!0,t.requestVideoFrameCallback(m)}"requestVideoFrameCallback"in t&&t.requestVideoFrameCallback(m)}clone(){return new this.constructor(this.image).copy(this)}update(){const t=this.image;"requestVideoFrameCallback"in t===!1&&t.readyState>=t.HAVE_CURRENT_DATA&&(this.needsUpdate=!0)}}d0.prototype.isVideoTexture=!0;class p0 extends we{constructor(t,e,n){super({width:t,height:e}),this.format=n,this.magFilter=ve,this.minFilter=ve,this.generateMipmaps=!1,this.needsUpdate=!0}}p0.prototype.isFramebufferTexture=!0;class f0 extends we{constructor(t,e,n,r,s,l,h,d,p,f,m,g){super(null,l,h,d,p,f,r,s,m,g),this.image={width:e,height:n},this.mipmaps=t,this.flipY=!1,this.generateMipmaps=!1}}f0.prototype.isCompressedTexture=!0;class m0 extends we{constructor(t,e,n,r,s,l,h,d,p){super(t,e,n,r,s,l,h,d,p),this.needsUpdate=!0}}m0.prototype.isCanvasTexture=!0;new D;new D;new D;new fe;class Je{constructor(){this.type="Curve",this.arcLengthDivisions=200}getPoint(){return console.warn("THREE.Curve: .getPoint() not implemented."),null}getPointAt(t,e){const n=this.getUtoTmapping(t);return this.getPoint(n,e)}getPoints(t=5){const e=[];for(let n=0;n<=t;n++)e.push(this.getPoint(n/t));return e}getSpacedPoints(t=5){const e=[];for(let n=0;n<=t;n++)e.push(this.getPointAt(n/t));return e}getLength(){const t=this.getLengths();return t[t.length-1]}getLengths(t=this.arcLengthDivisions){if(this.cacheArcLengths&&this.cacheArcLengths.length===t+1&&!this.needsUpdate)return this.cacheArcLengths;this.needsUpdate=!1;const e=[];let n,r=this.getPoint(0),s=0;e.push(0);for(let l=1;l<=t;l++)n=this.getPoint(l/t),s+=n.distanceTo(r),e.push(s),r=n;return this.cacheArcLengths=e,e}updateArcLengths(){this.needsUpdate=!0,this.getLengths()}getUtoTmapping(t,e){const n=this.getLengths();let r=0;const s=n.length;let l;e?l=e:l=t*n[s-1];let h=0,d=s-1,p;for(;h<=d;)if(r=Math.floor(h+(d-h)/2),p=n[r]-l,p<0)h=r+1;else if(p>0)d=r-1;else{d=r;break}if(r=d,n[r]===l)return r/(s-1);const f=n[r],g=n[r+1]-f,_=(l-f)/g;return(r+_)/(s-1)}getTangent(t,e){let r=t-1e-4,s=t+1e-4;r<0&&(r=0),s>1&&(s=1);const l=this.getPoint(r),h=this.getPoint(s),d=e||(l.isVector2?new st:new D);return d.copy(h).sub(l).normalize(),d}getTangentAt(t,e){const n=this.getUtoTmapping(t);return this.getTangent(n,e)}computeFrenetFrames(t,e){const n=new D,r=[],s=[],l=[],h=new D,d=new At;for(let _=0;_<=t;_++){const y=_/t;r[_]=this.getTangentAt(y,new D)}s[0]=new D,l[0]=new D;let p=Number.MAX_VALUE;const f=Math.abs(r[0].x),m=Math.abs(r[0].y),g=Math.abs(r[0].z);f<=p&&(p=f,n.set(1,0,0)),m<=p&&(p=m,n.set(0,1,0)),g<=p&&n.set(0,0,1),h.crossVectors(r[0],n).normalize(),s[0].crossVectors(r[0],h),l[0].crossVectors(r[0],s[0]);for(let _=1;_<=t;_++){if(s[_]=s[_-1].clone(),l[_]=l[_-1].clone(),h.crossVectors(r[_-1],r[_]),h.length()>Number.EPSILON){h.normalize();const y=Math.acos(We(r[_-1].dot(r[_]),-1,1));s[_].applyMatrix4(d.makeRotationAxis(h,y))}l[_].crossVectors(r[_],s[_])}if(e===!0){let _=Math.acos(We(s[0].dot(s[t]),-1,1));_/=t,r[0].dot(h.crossVectors(s[0],s[t]))>0&&(_=-_);for(let y=1;y<=t;y++)s[y].applyMatrix4(d.makeRotationAxis(r[y],_*y)),l[y].crossVectors(r[y],s[y])}return{tangents:r,normals:s,binormals:l}}clone(){return new this.constructor().copy(this)}copy(t){return this.arcLengthDivisions=t.arcLengthDivisions,this}toJSON(){const t={metadata:{version:4.5,type:"Curve",generator:"Curve.toJSON"}};return t.arcLengthDivisions=this.arcLengthDivisions,t.type=this.type,t}fromJSON(t){return this.arcLengthDivisions=t.arcLengthDivisions,this}}class so extends Je{constructor(t=0,e=0,n=1,r=1,s=0,l=Math.PI*2,h=!1,d=0){super(),this.type="EllipseCurve",this.aX=t,this.aY=e,this.xRadius=n,this.yRadius=r,this.aStartAngle=s,this.aEndAngle=l,this.aClockwise=h,this.aRotation=d}getPoint(t,e){const n=e||new st,r=Math.PI*2;let s=this.aEndAngle-this.aStartAngle;const l=Math.abs(s)<Number.EPSILON;for(;s<0;)s+=r;for(;s>r;)s-=r;s<Number.EPSILON&&(l?s=0:s=r),this.aClockwise===!0&&!l&&(s===r?s=-r:s=s-r);const h=this.aStartAngle+t*s;let d=this.aX+this.xRadius*Math.cos(h),p=this.aY+this.yRadius*Math.sin(h);if(this.aRotation!==0){const f=Math.cos(this.aRotation),m=Math.sin(this.aRotation),g=d-this.aX,_=p-this.aY;d=g*f-_*m+this.aX,p=g*m+_*f+this.aY}return n.set(d,p)}copy(t){return super.copy(t),this.aX=t.aX,this.aY=t.aY,this.xRadius=t.xRadius,this.yRadius=t.yRadius,this.aStartAngle=t.aStartAngle,this.aEndAngle=t.aEndAngle,this.aClockwise=t.aClockwise,this.aRotation=t.aRotation,this}toJSON(){const t=super.toJSON();return t.aX=this.aX,t.aY=this.aY,t.xRadius=this.xRadius,t.yRadius=this.yRadius,t.aStartAngle=this.aStartAngle,t.aEndAngle=this.aEndAngle,t.aClockwise=this.aClockwise,t.aRotation=this.aRotation,t}fromJSON(t){return super.fromJSON(t),this.aX=t.aX,this.aY=t.aY,this.xRadius=t.xRadius,this.yRadius=t.yRadius,this.aStartAngle=t.aStartAngle,this.aEndAngle=t.aEndAngle,this.aClockwise=t.aClockwise,this.aRotation=t.aRotation,this}}so.prototype.isEllipseCurve=!0;class _u extends so{constructor(t,e,n,r,s,l){super(t,e,n,n,r,s,l),this.type="ArcCurve"}}_u.prototype.isArcCurve=!0;function ja(){let o=0,t=0,e=0,n=0;function r(s,l,h,d){o=s,t=h,e=-3*s+3*l-2*h-d,n=2*s-2*l+h+d}return{initCatmullRom:function(s,l,h,d,p){r(l,h,p*(h-s),p*(d-l))},initNonuniformCatmullRom:function(s,l,h,d,p,f,m){let g=(l-s)/p-(h-s)/(p+f)+(h-l)/f,_=(h-l)/f-(d-l)/(f+m)+(d-h)/m;g*=f,_*=f,r(l,h,g,_)},calc:function(s){const l=s*s,h=l*s;return o+t*s+e*l+n*h}}}const Vs=new D,fa=new ja,ma=new ja,ga=new ja;class xu extends Je{constructor(t=[],e=!1,n="centripetal",r=.5){super(),this.type="CatmullRomCurve3",this.points=t,this.closed=e,this.curveType=n,this.tension=r}getPoint(t,e=new D){const n=e,r=this.points,s=r.length,l=(s-(this.closed?0:1))*t;let h=Math.floor(l),d=l-h;this.closed?h+=h>0?0:(Math.floor(Math.abs(h)/s)+1)*s:d===0&&h===s-1&&(h=s-2,d=1);let p,f;this.closed||h>0?p=r[(h-1)%s]:(Vs.subVectors(r[0],r[1]).add(r[0]),p=Vs);const m=r[h%s],g=r[(h+1)%s];if(this.closed||h+2<s?f=r[(h+2)%s]:(Vs.subVectors(r[s-1],r[s-2]).add(r[s-1]),f=Vs),this.curveType==="centripetal"||this.curveType==="chordal"){const _=this.curveType==="chordal"?.5:.25;let y=Math.pow(p.distanceToSquared(m),_),w=Math.pow(m.distanceToSquared(g),_),S=Math.pow(g.distanceToSquared(f),_);w<1e-4&&(w=1),y<1e-4&&(y=w),S<1e-4&&(S=w),fa.initNonuniformCatmullRom(p.x,m.x,g.x,f.x,y,w,S),ma.initNonuniformCatmullRom(p.y,m.y,g.y,f.y,y,w,S),ga.initNonuniformCatmullRom(p.z,m.z,g.z,f.z,y,w,S)}else this.curveType==="catmullrom"&&(fa.initCatmullRom(p.x,m.x,g.x,f.x,this.tension),ma.initCatmullRom(p.y,m.y,g.y,f.y,this.tension),ga.initCatmullRom(p.z,m.z,g.z,f.z,this.tension));return n.set(fa.calc(d),ma.calc(d),ga.calc(d)),n}copy(t){super.copy(t),this.points=[];for(let e=0,n=t.points.length;e<n;e++){const r=t.points[e];this.points.push(r.clone())}return this.closed=t.closed,this.curveType=t.curveType,this.tension=t.tension,this}toJSON(){const t=super.toJSON();t.points=[];for(let e=0,n=this.points.length;e<n;e++){const r=this.points[e];t.points.push(r.toArray())}return t.closed=this.closed,t.curveType=this.curveType,t.tension=this.tension,t}fromJSON(t){super.fromJSON(t),this.points=[];for(let e=0,n=t.points.length;e<n;e++){const r=t.points[e];this.points.push(new D().fromArray(r))}return this.closed=t.closed,this.curveType=t.curveType,this.tension=t.tension,this}}xu.prototype.isCatmullRomCurve3=!0;function Ah(o,t,e,n,r){const s=(n-t)*.5,l=(r-e)*.5,h=o*o,d=o*h;return(2*e-2*n+s+l)*d+(-3*e+3*n-2*s-l)*h+s*o+e}function g0(o,t){const e=1-o;return e*e*t}function v0(o,t){return 2*(1-o)*o*t}function _0(o,t){return o*o*t}function Vr(o,t,e,n){return g0(o,t)+v0(o,e)+_0(o,n)}function x0(o,t){const e=1-o;return e*e*e*t}function b0(o,t){const e=1-o;return 3*e*e*o*t}function y0(o,t){return 3*(1-o)*o*o*t}function w0(o,t){return o*o*o*t}function Br(o,t,e,n,r){return x0(o,t)+b0(o,e)+y0(o,n)+w0(o,r)}class Xa extends Je{constructor(t=new st,e=new st,n=new st,r=new st){super(),this.type="CubicBezierCurve",this.v0=t,this.v1=e,this.v2=n,this.v3=r}getPoint(t,e=new st){const n=e,r=this.v0,s=this.v1,l=this.v2,h=this.v3;return n.set(Br(t,r.x,s.x,l.x,h.x),Br(t,r.y,s.y,l.y,h.y)),n}copy(t){return super.copy(t),this.v0.copy(t.v0),this.v1.copy(t.v1),this.v2.copy(t.v2),this.v3.copy(t.v3),this}toJSON(){const t=super.toJSON();return t.v0=this.v0.toArray(),t.v1=this.v1.toArray(),t.v2=this.v2.toArray(),t.v3=this.v3.toArray(),t}fromJSON(t){return super.fromJSON(t),this.v0.fromArray(t.v0),this.v1.fromArray(t.v1),this.v2.fromArray(t.v2),this.v3.fromArray(t.v3),this}}Xa.prototype.isCubicBezierCurve=!0;class bu extends Je{constructor(t=new D,e=new D,n=new D,r=new D){super(),this.type="CubicBezierCurve3",this.v0=t,this.v1=e,this.v2=n,this.v3=r}getPoint(t,e=new D){const n=e,r=this.v0,s=this.v1,l=this.v2,h=this.v3;return n.set(Br(t,r.x,s.x,l.x,h.x),Br(t,r.y,s.y,l.y,h.y),Br(t,r.z,s.z,l.z,h.z)),n}copy(t){return super.copy(t),this.v0.copy(t.v0),this.v1.copy(t.v1),this.v2.copy(t.v2),this.v3.copy(t.v3),this}toJSON(){const t=super.toJSON();return t.v0=this.v0.toArray(),t.v1=this.v1.toArray(),t.v2=this.v2.toArray(),t.v3=this.v3.toArray(),t}fromJSON(t){return super.fromJSON(t),this.v0.fromArray(t.v0),this.v1.fromArray(t.v1),this.v2.fromArray(t.v2),this.v3.fromArray(t.v3),this}}bu.prototype.isCubicBezierCurve3=!0;class oo extends Je{constructor(t=new st,e=new st){super(),this.type="LineCurve",this.v1=t,this.v2=e}getPoint(t,e=new st){const n=e;return t===1?n.copy(this.v2):(n.copy(this.v2).sub(this.v1),n.multiplyScalar(t).add(this.v1)),n}getPointAt(t,e){return this.getPoint(t,e)}getTangent(t,e){const n=e||new st;return n.copy(this.v2).sub(this.v1).normalize(),n}copy(t){return super.copy(t),this.v1.copy(t.v1),this.v2.copy(t.v2),this}toJSON(){const t=super.toJSON();return t.v1=this.v1.toArray(),t.v2=this.v2.toArray(),t}fromJSON(t){return super.fromJSON(t),this.v1.fromArray(t.v1),this.v2.fromArray(t.v2),this}}oo.prototype.isLineCurve=!0;class M0 extends Je{constructor(t=new D,e=new D){super(),this.type="LineCurve3",this.isLineCurve3=!0,this.v1=t,this.v2=e}getPoint(t,e=new D){const n=e;return t===1?n.copy(this.v2):(n.copy(this.v2).sub(this.v1),n.multiplyScalar(t).add(this.v1)),n}getPointAt(t,e){return this.getPoint(t,e)}copy(t){return super.copy(t),this.v1.copy(t.v1),this.v2.copy(t.v2),this}toJSON(){const t=super.toJSON();return t.v1=this.v1.toArray(),t.v2=this.v2.toArray(),t}fromJSON(t){return super.fromJSON(t),this.v1.fromArray(t.v1),this.v2.fromArray(t.v2),this}}class $a extends Je{constructor(t=new st,e=new st,n=new st){super(),this.type="QuadraticBezierCurve",this.v0=t,this.v1=e,this.v2=n}getPoint(t,e=new st){const n=e,r=this.v0,s=this.v1,l=this.v2;return n.set(Vr(t,r.x,s.x,l.x),Vr(t,r.y,s.y,l.y)),n}copy(t){return super.copy(t),this.v0.copy(t.v0),this.v1.copy(t.v1),this.v2.copy(t.v2),this}toJSON(){const t=super.toJSON();return t.v0=this.v0.toArray(),t.v1=this.v1.toArray(),t.v2=this.v2.toArray(),t}fromJSON(t){return super.fromJSON(t),this.v0.fromArray(t.v0),this.v1.fromArray(t.v1),this.v2.fromArray(t.v2),this}}$a.prototype.isQuadraticBezierCurve=!0;class yu extends Je{constructor(t=new D,e=new D,n=new D){super(),this.type="QuadraticBezierCurve3",this.v0=t,this.v1=e,this.v2=n}getPoint(t,e=new D){const n=e,r=this.v0,s=this.v1,l=this.v2;return n.set(Vr(t,r.x,s.x,l.x),Vr(t,r.y,s.y,l.y),Vr(t,r.z,s.z,l.z)),n}copy(t){return super.copy(t),this.v0.copy(t.v0),this.v1.copy(t.v1),this.v2.copy(t.v2),this}toJSON(){const t=super.toJSON();return t.v0=this.v0.toArray(),t.v1=this.v1.toArray(),t.v2=this.v2.toArray(),t}fromJSON(t){return super.fromJSON(t),this.v0.fromArray(t.v0),this.v1.fromArray(t.v1),this.v2.fromArray(t.v2),this}}yu.prototype.isQuadraticBezierCurve3=!0;class Ya extends Je{constructor(t=[]){super(),this.type="SplineCurve",this.points=t}getPoint(t,e=new st){const n=e,r=this.points,s=(r.length-1)*t,l=Math.floor(s),h=s-l,d=r[l===0?l:l-1],p=r[l],f=r[l>r.length-2?r.length-1:l+1],m=r[l>r.length-3?r.length-1:l+2];return n.set(Ah(h,d.x,p.x,f.x,m.x),Ah(h,d.y,p.y,f.y,m.y)),n}copy(t){super.copy(t),this.points=[];for(let e=0,n=t.points.length;e<n;e++){const r=t.points[e];this.points.push(r.clone())}return this}toJSON(){const t=super.toJSON();t.points=[];for(let e=0,n=this.points.length;e<n;e++){const r=this.points[e];t.points.push(r.toArray())}return t}fromJSON(t){super.fromJSON(t),this.points=[];for(let e=0,n=t.points.length;e<n;e++){const r=t.points[e];this.points.push(new st().fromArray(r))}return this}}Ya.prototype.isSplineCurve=!0;var wu=Object.freeze({__proto__:null,ArcCurve:_u,CatmullRomCurve3:xu,CubicBezierCurve:Xa,CubicBezierCurve3:bu,EllipseCurve:so,LineCurve:oo,LineCurve3:M0,QuadraticBezierCurve:$a,QuadraticBezierCurve3:yu,SplineCurve:Ya});class S0 extends Je{constructor(){super(),this.type="CurvePath",this.curves=[],this.autoClose=!1}add(t){this.curves.push(t)}closePath(){const t=this.curves[0].getPoint(0),e=this.curves[this.curves.length-1].getPoint(1);t.equals(e)||this.curves.push(new oo(e,t))}getPoint(t,e){const n=t*this.getLength(),r=this.getCurveLengths();let s=0;for(;s<r.length;){if(r[s]>=n){const l=r[s]-n,h=this.curves[s],d=h.getLength(),p=d===0?0:1-l/d;return h.getPointAt(p,e)}s++}return null}getLength(){const t=this.getCurveLengths();return t[t.length-1]}updateArcLengths(){this.needsUpdate=!0,this.cacheLengths=null,this.getCurveLengths()}getCurveLengths(){if(this.cacheLengths&&this.cacheLengths.length===this.curves.length)return this.cacheLengths;const t=[];let e=0;for(let n=0,r=this.curves.length;n<r;n++)e+=this.curves[n].getLength(),t.push(e);return this.cacheLengths=t,t}getSpacedPoints(t=40){const e=[];for(let n=0;n<=t;n++)e.push(this.getPoint(n/t));return this.autoClose&&e.push(e[0]),e}getPoints(t=12){const e=[];let n;for(let r=0,s=this.curves;r<s.length;r++){const l=s[r],h=l&&l.isEllipseCurve?t*2:l&&(l.isLineCurve||l.isLineCurve3)?1:l&&l.isSplineCurve?t*l.points.length:t,d=l.getPoints(h);for(let p=0;p<d.length;p++){const f=d[p];n&&n.equals(f)||(e.push(f),n=f)}}return this.autoClose&&e.length>1&&!e[e.length-1].equals(e[0])&&e.push(e[0]),e}copy(t){super.copy(t),this.curves=[];for(let e=0,n=t.curves.length;e<n;e++){const r=t.curves[e];this.curves.push(r.clone())}return this.autoClose=t.autoClose,this}toJSON(){const t=super.toJSON();t.autoClose=this.autoClose,t.curves=[];for(let e=0,n=this.curves.length;e<n;e++){const r=this.curves[e];t.curves.push(r.toJSON())}return t}fromJSON(t){super.fromJSON(t),this.autoClose=t.autoClose,this.curves=[];for(let e=0,n=t.curves.length;e<n;e++){const r=t.curves[e];this.curves.push(new wu[r.type]().fromJSON(r))}return this}}class $s extends S0{constructor(t){super(),this.type="Path",this.currentPoint=new st,t&&this.setFromPoints(t)}setFromPoints(t){this.moveTo(t[0].x,t[0].y);for(let e=1,n=t.length;e<n;e++)this.lineTo(t[e].x,t[e].y);return this}moveTo(t,e){return this.currentPoint.set(t,e),this}lineTo(t,e){const n=new oo(this.currentPoint.clone(),new st(t,e));return this.curves.push(n),this.currentPoint.set(t,e),this}quadraticCurveTo(t,e,n,r){const s=new $a(this.currentPoint.clone(),new st(t,e),new st(n,r));return this.curves.push(s),this.currentPoint.set(n,r),this}bezierCurveTo(t,e,n,r,s,l){const h=new Xa(this.currentPoint.clone(),new st(t,e),new st(n,r),new st(s,l));return this.curves.push(h),this.currentPoint.set(s,l),this}splineThru(t){const e=[this.currentPoint.clone()].concat(t),n=new Ya(e);return this.curves.push(n),this.currentPoint.copy(t[t.length-1]),this}arc(t,e,n,r,s,l){const h=this.currentPoint.x,d=this.currentPoint.y;return this.absarc(t+h,e+d,n,r,s,l),this}absarc(t,e,n,r,s,l){return this.absellipse(t,e,n,n,r,s,l),this}ellipse(t,e,n,r,s,l,h,d){const p=this.currentPoint.x,f=this.currentPoint.y;return this.absellipse(t+p,e+f,n,r,s,l,h,d),this}absellipse(t,e,n,r,s,l,h,d){const p=new so(t,e,n,r,s,l,h,d);if(this.curves.length>0){const m=p.getPoint(0);m.equals(this.currentPoint)||this.lineTo(m.x,m.y)}this.curves.push(p);const f=p.getPoint(1);return this.currentPoint.copy(f),this}copy(t){return super.copy(t),this.currentPoint.copy(t.currentPoint),this}toJSON(){const t=super.toJSON();return t.currentPoint=this.currentPoint.toArray(),t}fromJSON(t){return super.fromJSON(t),this.currentPoint.fromArray(t.currentPoint),this}}class $n extends $s{constructor(t){super(t),this.uuid=cn(),this.type="Shape",this.holes=[]}getPointsHoles(t){const e=[];for(let n=0,r=this.holes.length;n<r;n++)e[n]=this.holes[n].getPoints(t);return e}extractPoints(t){return{shape:this.getPoints(t),holes:this.getPointsHoles(t)}}copy(t){super.copy(t),this.holes=[];for(let e=0,n=t.holes.length;e<n;e++){const r=t.holes[e];this.holes.push(r.clone())}return this}toJSON(){const t=super.toJSON();t.uuid=this.uuid,t.holes=[];for(let e=0,n=this.holes.length;e<n;e++){const r=this.holes[e];t.holes.push(r.toJSON())}return t}fromJSON(t){super.fromJSON(t),this.uuid=t.uuid,this.holes=[];for(let e=0,n=t.holes.length;e<n;e++){const r=t.holes[e];this.holes.push(new $s().fromJSON(r))}return this}}const E0={triangulate:function(o,t,e=2){const n=t&&t.length,r=n?t[0]*e:o.length;let s=Mu(o,0,r,e,!0);const l=[];if(!s||s.next===s.prev)return l;let h,d,p,f,m,g,_;if(n&&(s=L0(o,t,s,e)),o.length>80*e){h=p=o[0],d=f=o[1];for(let y=e;y<r;y+=e)m=o[y],g=o[y+1],m<h&&(h=m),g<d&&(d=g),m>p&&(p=m),g>f&&(f=g);_=Math.max(p-h,f-d),_=_!==0?1/_:0}return Gr(s,l,e,h,d,_),l}};function Mu(o,t,e,n,r){let s,l;if(r===U0(o,t,e,n)>0)for(s=t;s<e;s+=n)l=Ph(s,o[s],o[s+1],l);else for(s=e-n;s>=t;s-=n)l=Ph(s,o[s],o[s+1],l);return l&&ao(l,l.next)&&(qr(l),l=l.next),l}function Yn(o,t){if(!o)return o;t||(t=o);let e=o,n;do if(n=!1,!e.steiner&&(ao(e,e.next)||he(e.prev,e,e.next)===0)){if(qr(e),e=t=e.prev,e===e.next)break;n=!0}else e=e.next;while(n||e!==t);return t}function Gr(o,t,e,n,r,s,l){if(!o)return;!l&&s&&F0(o,n,r,s);let h=o,d,p;for(;o.prev!==o.next;){if(d=o.prev,p=o.next,s?C0(o,n,r,s):T0(o)){t.push(d.i/e),t.push(o.i/e),t.push(p.i/e),qr(o),o=p.next,h=p.next;continue}if(o=p,o===h){l?l===1?(o=A0(Yn(o),t,e),Gr(o,t,e,n,r,s,2)):l===2&&P0(o,t,e,n,r,s):Gr(Yn(o),t,e,n,r,s,1);break}}}function T0(o){const t=o.prev,e=o,n=o.next;if(he(t,e,n)>=0)return!1;let r=o.next.next;for(;r!==o.prev;){if(qi(t.x,t.y,e.x,e.y,n.x,n.y,r.x,r.y)&&he(r.prev,r,r.next)>=0)return!1;r=r.next}return!0}function C0(o,t,e,n){const r=o.prev,s=o,l=o.next;if(he(r,s,l)>=0)return!1;const h=r.x<s.x?r.x<l.x?r.x:l.x:s.x<l.x?s.x:l.x,d=r.y<s.y?r.y<l.y?r.y:l.y:s.y<l.y?s.y:l.y,p=r.x>s.x?r.x>l.x?r.x:l.x:s.x>l.x?s.x:l.x,f=r.y>s.y?r.y>l.y?r.y:l.y:s.y>l.y?s.y:l.y,m=La(h,d,t,e,n),g=La(p,f,t,e,n);let _=o.prevZ,y=o.nextZ;for(;_&&_.z>=m&&y&&y.z<=g;){if(_!==o.prev&&_!==o.next&&qi(r.x,r.y,s.x,s.y,l.x,l.y,_.x,_.y)&&he(_.prev,_,_.next)>=0||(_=_.prevZ,y!==o.prev&&y!==o.next&&qi(r.x,r.y,s.x,s.y,l.x,l.y,y.x,y.y)&&he(y.prev,y,y.next)>=0))return!1;y=y.nextZ}for(;_&&_.z>=m;){if(_!==o.prev&&_!==o.next&&qi(r.x,r.y,s.x,s.y,l.x,l.y,_.x,_.y)&&he(_.prev,_,_.next)>=0)return!1;_=_.prevZ}for(;y&&y.z<=g;){if(y!==o.prev&&y!==o.next&&qi(r.x,r.y,s.x,s.y,l.x,l.y,y.x,y.y)&&he(y.prev,y,y.next)>=0)return!1;y=y.nextZ}return!0}function A0(o,t,e){let n=o;do{const r=n.prev,s=n.next.next;!ao(r,s)&&Su(r,n,n.next,s)&&Wr(r,s)&&Wr(s,r)&&(t.push(r.i/e),t.push(n.i/e),t.push(s.i/e),qr(n),qr(n.next),n=o=s),n=n.next}while(n!==o);return Yn(n)}function P0(o,t,e,n,r,s){let l=o;do{let h=l.next.next;for(;h!==l.prev;){if(l.i!==h.i&&B0(l,h)){let d=Eu(l,h);l=Yn(l,l.next),d=Yn(d,d.next),Gr(l,t,e,n,r,s),Gr(d,t,e,n,r,s);return}h=h.next}l=l.next}while(l!==o)}function L0(o,t,e,n){const r=[];let s,l,h,d,p;for(s=0,l=t.length;s<l;s++)h=t[s]*n,d=s<l-1?t[s+1]*n:o.length,p=Mu(o,h,d,n,!1),p===p.next&&(p.steiner=!0),r.push(V0(p));for(r.sort(R0),s=0;s<r.length;s++)D0(r[s],e),e=Yn(e,e.next);return e}function R0(o,t){return o.x-t.x}function D0(o,t){if(t=I0(o,t),t){const e=Eu(t,o);Yn(t,t.next),Yn(e,e.next)}}function I0(o,t){let e=t;const n=o.x,r=o.y;let s=-1/0,l;do{if(r<=e.y&&r>=e.next.y&&e.next.y!==e.y){const g=e.x+(r-e.y)*(e.next.x-e.x)/(e.next.y-e.y);if(g<=n&&g>s){if(s=g,g===n){if(r===e.y)return e;if(r===e.next.y)return e.next}l=e.x<e.next.x?e:e.next}}e=e.next}while(e!==t);if(!l)return null;if(n===s)return l;const h=l,d=l.x,p=l.y;let f=1/0,m;e=l;do n>=e.x&&e.x>=d&&n!==e.x&&qi(r<p?n:s,r,d,p,r<p?s:n,r,e.x,e.y)&&(m=Math.abs(r-e.y)/(n-e.x),Wr(e,o)&&(m<f||m===f&&(e.x>l.x||e.x===l.x&&N0(l,e)))&&(l=e,f=m)),e=e.next;while(e!==h);return l}function N0(o,t){return he(o.prev,o,t.prev)<0&&he(t.next,o,o.next)<0}function F0(o,t,e,n){let r=o;do r.z===null&&(r.z=La(r.x,r.y,t,e,n)),r.prevZ=r.prev,r.nextZ=r.next,r=r.next;while(r!==o);r.prevZ.nextZ=null,r.prevZ=null,k0(r)}function k0(o){let t,e,n,r,s,l,h,d,p=1;do{for(e=o,o=null,s=null,l=0;e;){for(l++,n=e,h=0,t=0;t<p&&(h++,n=n.nextZ,!!n);t++);for(d=p;h>0||d>0&&n;)h!==0&&(d===0||!n||e.z<=n.z)?(r=e,e=e.nextZ,h--):(r=n,n=n.nextZ,d--),s?s.nextZ=r:o=r,r.prevZ=s,s=r;e=n}s.nextZ=null,p*=2}while(l>1);return o}function La(o,t,e,n,r){return o=32767*(o-e)*r,t=32767*(t-n)*r,o=(o|o<<8)&16711935,o=(o|o<<4)&252645135,o=(o|o<<2)&858993459,o=(o|o<<1)&1431655765,t=(t|t<<8)&16711935,t=(t|t<<4)&252645135,t=(t|t<<2)&858993459,t=(t|t<<1)&1431655765,o|t<<1}function V0(o){let t=o,e=o;do(t.x<e.x||t.x===e.x&&t.y<e.y)&&(e=t),t=t.next;while(t!==o);return e}function qi(o,t,e,n,r,s,l,h){return(r-l)*(t-h)-(o-l)*(s-h)>=0&&(o-l)*(n-h)-(e-l)*(t-h)>=0&&(e-l)*(s-h)-(r-l)*(n-h)>=0}function B0(o,t){return o.next.i!==t.i&&o.prev.i!==t.i&&!z0(o,t)&&(Wr(o,t)&&Wr(t,o)&&O0(o,t)&&(he(o.prev,o,t.prev)||he(o,t.prev,t))||ao(o,t)&&he(o.prev,o,o.next)>0&&he(t.prev,t,t.next)>0)}function he(o,t,e){return(t.y-o.y)*(e.x-t.x)-(t.x-o.x)*(e.y-t.y)}function ao(o,t){return o.x===t.x&&o.y===t.y}function Su(o,t,e,n){const r=zs(he(o,t,e)),s=zs(he(o,t,n)),l=zs(he(e,n,o)),h=zs(he(e,n,t));return!!(r!==s&&l!==h||r===0&&Bs(o,e,t)||s===0&&Bs(o,n,t)||l===0&&Bs(e,o,n)||h===0&&Bs(e,t,n))}function Bs(o,t,e){return t.x<=Math.max(o.x,e.x)&&t.x>=Math.min(o.x,e.x)&&t.y<=Math.max(o.y,e.y)&&t.y>=Math.min(o.y,e.y)}function zs(o){return o>0?1:o<0?-1:0}function z0(o,t){let e=o;do{if(e.i!==o.i&&e.next.i!==o.i&&e.i!==t.i&&e.next.i!==t.i&&Su(e,e.next,o,t))return!0;e=e.next}while(e!==o);return!1}function Wr(o,t){return he(o.prev,o,o.next)<0?he(o,t,o.next)>=0&&he(o,o.prev,t)>=0:he(o,t,o.prev)<0||he(o,o.next,t)<0}function O0(o,t){let e=o,n=!1;const r=(o.x+t.x)/2,s=(o.y+t.y)/2;do e.y>s!=e.next.y>s&&e.next.y!==e.y&&r<(e.next.x-e.x)*(s-e.y)/(e.next.y-e.y)+e.x&&(n=!n),e=e.next;while(e!==o);return n}function Eu(o,t){const e=new Ra(o.i,o.x,o.y),n=new Ra(t.i,t.x,t.y),r=o.next,s=t.prev;return o.next=t,t.prev=o,e.next=r,r.prev=e,n.next=e,e.prev=n,s.next=n,n.prev=s,n}function Ph(o,t,e,n){const r=new Ra(o,t,e);return n?(r.next=n.next,r.prev=n,n.next.prev=r,n.next=r):(r.prev=r,r.next=r),r}function qr(o){o.next.prev=o.prev,o.prev.next=o.next,o.prevZ&&(o.prevZ.nextZ=o.nextZ),o.nextZ&&(o.nextZ.prevZ=o.prevZ)}function Ra(o,t,e){this.i=o,this.x=t,this.y=e,this.prev=null,this.next=null,this.z=null,this.prevZ=null,this.nextZ=null,this.steiner=!1}function U0(o,t,e,n){let r=0;for(let s=t,l=e-n;s<e;s+=n)r+=(o[l]-o[s])*(o[s+1]+o[l+1]),l=s;return r}class Tn{static area(t){const e=t.length;let n=0;for(let r=e-1,s=0;s<e;r=s++)n+=t[r].x*t[s].y-t[s].x*t[r].y;return n*.5}static isClockWise(t){return Tn.area(t)<0}static triangulateShape(t,e){const n=[],r=[],s=[];Lh(t),Rh(n,t);let l=t.length;e.forEach(Lh);for(let d=0;d<e.length;d++)r.push(l),l+=e[d].length,Rh(n,e[d]);const h=E0.triangulate(n,r);for(let d=0;d<h.length;d+=3)s.push(h.slice(d,d+3));return s}}function Lh(o){const t=o.length;t>2&&o[t-1].equals(o[0])&&o.pop()}function Rh(o,t){for(let e=0;e<t.length;e++)o.push(t[e].x),o.push(t[e].y)}class sr extends ce{constructor(t=new $n([new st(.5,.5),new st(-.5,.5),new st(-.5,-.5),new st(.5,-.5)]),e={}){super(),this.type="ExtrudeGeometry",this.parameters={shapes:t,options:e},t=Array.isArray(t)?t:[t];const n=this,r=[],s=[];for(let h=0,d=t.length;h<d;h++){const p=t[h];l(p)}this.setAttribute("position",new ye(r,3)),this.setAttribute("uv",new ye(s,2)),this.computeVertexNormals();function l(h){const d=[],p=e.curveSegments!==void 0?e.curveSegments:12,f=e.steps!==void 0?e.steps:1;let m=e.depth!==void 0?e.depth:1,g=e.bevelEnabled!==void 0?e.bevelEnabled:!0,_=e.bevelThickness!==void 0?e.bevelThickness:.2,y=e.bevelSize!==void 0?e.bevelSize:_-.1,w=e.bevelOffset!==void 0?e.bevelOffset:0,S=e.bevelSegments!==void 0?e.bevelSegments:3;const x=e.extrudePath,v=e.UVGenerator!==void 0?e.UVGenerator:H0;e.amount!==void 0&&(console.warn("THREE.ExtrudeBufferGeometry: amount has been renamed to depth."),m=e.amount);let N,M=!1,R,F,k,j;x&&(N=x.getSpacedPoints(f),M=!0,g=!1,R=x.computeFrenetFrames(f,!1),F=new D,k=new D,j=new D),g||(S=0,_=0,y=0,w=0);const ot=h.extractPoints(p);let Y=ot.shape;const V=ot.holes;if(!Tn.isClockWise(Y)){Y=Y.reverse();for(let $=0,rt=V.length;$<rt;$++){const ct=V[$];Tn.isClockWise(ct)&&(V[$]=ct.reverse())}}const A=Tn.triangulateShape(Y,V),H=Y;for(let $=0,rt=V.length;$<rt;$++){const ct=V[$];Y=Y.concat(ct)}function q($,rt,ct){return rt||console.error("THREE.ExtrudeGeometry: vec does not exist"),rt.clone().multiplyScalar(ct).add($)}const O=Y.length,U=A.length;function X($,rt,ct){let xt,ht,Pt;const Vt=$.x-rt.x,Ut=$.y-rt.y,ie=ct.x-$.x,L=ct.y-$.y,T=Vt*Vt+Ut*Ut,tt=Vt*L-Ut*ie;if(Math.abs(tt)>Number.EPSILON){const et=Math.sqrt(T),mt=Math.sqrt(ie*ie+L*L),nt=rt.x-Ut/et,It=rt.y+Vt/et,Ct=ct.x-L/mt,ut=ct.y+ie/mt,I=((Ct-nt)*L-(ut-It)*ie)/(Vt*L-Ut*ie);xt=nt+Vt*I-$.x,ht=It+Ut*I-$.y;const dt=xt*xt+ht*ht;if(dt<=2)return new st(xt,ht);Pt=Math.sqrt(dt/2)}else{let et=!1;Vt>Number.EPSILON?ie>Number.EPSILON&&(et=!0):Vt<-Number.EPSILON?ie<-Number.EPSILON&&(et=!0):Math.sign(Ut)===Math.sign(L)&&(et=!0),et?(xt=-Ut,ht=Vt,Pt=Math.sqrt(T)):(xt=Vt,ht=Ut,Pt=Math.sqrt(T/2))}return new st(xt/Pt,ht/Pt)}const _t=[];for(let $=0,rt=H.length,ct=rt-1,xt=$+1;$<rt;$++,ct++,xt++)ct===rt&&(ct=0),xt===rt&&(xt=0),_t[$]=X(H[$],H[ct],H[xt]);const J=[];let Z,pt=_t.concat();for(let $=0,rt=V.length;$<rt;$++){const ct=V[$];Z=[];for(let xt=0,ht=ct.length,Pt=ht-1,Vt=xt+1;xt<ht;xt++,Pt++,Vt++)Pt===ht&&(Pt=0),Vt===ht&&(Vt=0),Z[xt]=X(ct[xt],ct[Pt],ct[Vt]);J.push(Z),pt=pt.concat(Z)}for(let $=0;$<S;$++){const rt=$/S,ct=_*Math.cos(rt*Math.PI/2),xt=y*Math.sin(rt*Math.PI/2)+w;for(let ht=0,Pt=H.length;ht<Pt;ht++){const Vt=q(H[ht],_t[ht],xt);zt(Vt.x,Vt.y,-ct)}for(let ht=0,Pt=V.length;ht<Pt;ht++){const Vt=V[ht];Z=J[ht];for(let Ut=0,ie=Vt.length;Ut<ie;Ut++){const L=q(Vt[Ut],Z[Ut],xt);zt(L.x,L.y,-ct)}}}const vt=y+w;for(let $=0;$<O;$++){const rt=g?q(Y[$],pt[$],vt):Y[$];M?(k.copy(R.normals[0]).multiplyScalar(rt.x),F.copy(R.binormals[0]).multiplyScalar(rt.y),j.copy(N[0]).add(k).add(F),zt(j.x,j.y,j.z)):zt(rt.x,rt.y,0)}for(let $=1;$<=f;$++)for(let rt=0;rt<O;rt++){const ct=g?q(Y[rt],pt[rt],vt):Y[rt];M?(k.copy(R.normals[$]).multiplyScalar(ct.x),F.copy(R.binormals[$]).multiplyScalar(ct.y),j.copy(N[$]).add(k).add(F),zt(j.x,j.y,j.z)):zt(ct.x,ct.y,m/f*$)}for(let $=S-1;$>=0;$--){const rt=$/S,ct=_*Math.cos(rt*Math.PI/2),xt=y*Math.sin(rt*Math.PI/2)+w;for(let ht=0,Pt=H.length;ht<Pt;ht++){const Vt=q(H[ht],_t[ht],xt);zt(Vt.x,Vt.y,m+ct)}for(let ht=0,Pt=V.length;ht<Pt;ht++){const Vt=V[ht];Z=J[ht];for(let Ut=0,ie=Vt.length;Ut<ie;Ut++){const L=q(Vt[Ut],Z[Ut],xt);M?zt(L.x,L.y+N[f-1].y,N[f-1].x+ct):zt(L.x,L.y,m+ct)}}}at(),Tt();function at(){const $=r.length/3;if(g){let rt=0,ct=O*rt;for(let xt=0;xt<U;xt++){const ht=A[xt];wt(ht[2]+ct,ht[1]+ct,ht[0]+ct)}rt=f+S*2,ct=O*rt;for(let xt=0;xt<U;xt++){const ht=A[xt];wt(ht[0]+ct,ht[1]+ct,ht[2]+ct)}}else{for(let rt=0;rt<U;rt++){const ct=A[rt];wt(ct[2],ct[1],ct[0])}for(let rt=0;rt<U;rt++){const ct=A[rt];wt(ct[0]+O*f,ct[1]+O*f,ct[2]+O*f)}}n.addGroup($,r.length/3-$,0)}function Tt(){const $=r.length/3;let rt=0;Q(H,rt),rt+=H.length;for(let ct=0,xt=V.length;ct<xt;ct++){const ht=V[ct];Q(ht,rt),rt+=ht.length}n.addGroup($,r.length/3-$,1)}function Q($,rt){let ct=$.length;for(;--ct>=0;){const xt=ct;let ht=ct-1;ht<0&&(ht=$.length-1);for(let Pt=0,Vt=f+S*2;Pt<Vt;Pt++){const Ut=O*Pt,ie=O*(Pt+1),L=rt+xt+Ut,T=rt+ht+Ut,tt=rt+ht+ie,et=rt+xt+ie;yt(L,T,tt,et)}}}function zt($,rt,ct){d.push($),d.push(rt),d.push(ct)}function wt($,rt,ct){Mt($),Mt(rt),Mt(ct);const xt=r.length/3,ht=v.generateTopUV(n,r,xt-3,xt-2,xt-1);Ot(ht[0]),Ot(ht[1]),Ot(ht[2])}function yt($,rt,ct,xt){Mt($),Mt(rt),Mt(xt),Mt(rt),Mt(ct),Mt(xt);const ht=r.length/3,Pt=v.generateSideWallUV(n,r,ht-6,ht-3,ht-2,ht-1);Ot(Pt[0]),Ot(Pt[1]),Ot(Pt[3]),Ot(Pt[1]),Ot(Pt[2]),Ot(Pt[3])}function Mt($){r.push(d[$*3+0]),r.push(d[$*3+1]),r.push(d[$*3+2])}function Ot($){s.push($.x),s.push($.y)}}}toJSON(){const t=super.toJSON(),e=this.parameters.shapes,n=this.parameters.options;return G0(e,n,t)}static fromJSON(t,e){const n=[];for(let s=0,l=t.shapes.length;s<l;s++){const h=e[t.shapes[s]];n.push(h)}const r=t.options.extrudePath;return r!==void 0&&(t.options.extrudePath=new wu[r.type]().fromJSON(r)),new sr(n,t.options)}}const H0={generateTopUV:function(o,t,e,n,r){const s=t[e*3],l=t[e*3+1],h=t[n*3],d=t[n*3+1],p=t[r*3],f=t[r*3+1];return[new st(s,l),new st(h,d),new st(p,f)]},generateSideWallUV:function(o,t,e,n,r,s){const l=t[e*3],h=t[e*3+1],d=t[e*3+2],p=t[n*3],f=t[n*3+1],m=t[n*3+2],g=t[r*3],_=t[r*3+1],y=t[r*3+2],w=t[s*3],S=t[s*3+1],x=t[s*3+2];return Math.abs(h-f)<Math.abs(l-p)?[new st(l,1-d),new st(p,1-m),new st(g,1-y),new st(w,1-x)]:[new st(h,1-d),new st(f,1-m),new st(_,1-y),new st(S,1-x)]}};function G0(o,t,e){if(e.shapes=[],Array.isArray(o))for(let n=0,r=o.length;n<r;n++){const s=o[n];e.shapes.push(s.uuid)}else e.shapes.push(o.uuid);return t.extrudePath!==void 0&&(e.options.extrudePath=t.extrudePath.toJSON()),e}class Ja extends ce{constructor(t=new $n([new st(0,.5),new st(-.5,-.5),new st(.5,-.5)]),e=12){super(),this.type="ShapeGeometry",this.parameters={shapes:t,curveSegments:e};const n=[],r=[],s=[],l=[];let h=0,d=0;if(Array.isArray(t)===!1)p(t);else for(let f=0;f<t.length;f++)p(t[f]),this.addGroup(h,d,f),h+=d,d=0;this.setIndex(n),this.setAttribute("position",new ye(r,3)),this.setAttribute("normal",new ye(s,3)),this.setAttribute("uv",new ye(l,2));function p(f){const m=r.length/3,g=f.extractPoints(e);let _=g.shape;const y=g.holes;Tn.isClockWise(_)===!1&&(_=_.reverse());for(let S=0,x=y.length;S<x;S++){const v=y[S];Tn.isClockWise(v)===!0&&(y[S]=v.reverse())}const w=Tn.triangulateShape(_,y);for(let S=0,x=y.length;S<x;S++){const v=y[S];_=_.concat(v)}for(let S=0,x=_.length;S<x;S++){const v=_[S];r.push(v.x,v.y,0),s.push(0,0,1),l.push(v.x,v.y)}for(let S=0,x=w.length;S<x;S++){const v=w[S],N=v[0]+m,M=v[1]+m,R=v[2]+m;n.push(N,M,R),d+=3}}}toJSON(){const t=super.toJSON(),e=this.parameters.shapes;return W0(e,t)}static fromJSON(t,e){const n=[];for(let r=0,s=t.shapes.length;r<s;r++){const l=e[t.shapes[r]];n.push(l)}return new Ja(n,t.curveSegments)}}function W0(o,t){if(t.shapes=[],Array.isArray(o))for(let e=0,n=o.length;e<n;e++){const r=o[e];t.shapes.push(r.uuid)}else t.shapes.push(o.uuid);return t}class q0 extends Pe{constructor(t){super(),this.type="ShadowMaterial",this.color=new Et(0),this.transparent=!0,this.setValues(t)}copy(t){return super.copy(t),this.color.copy(t.color),this}}q0.prototype.isShadowMaterial=!0;class Tu extends Pe{constructor(t){super(),this.defines={STANDARD:""},this.type="MeshStandardMaterial",this.color=new Et(16777215),this.roughness=1,this.metalness=0,this.map=null,this.lightMap=null,this.lightMapIntensity=1,this.aoMap=null,this.aoMapIntensity=1,this.emissive=new Et(0),this.emissiveIntensity=1,this.emissiveMap=null,this.bumpMap=null,this.bumpScale=1,this.normalMap=null,this.normalMapType=Qi,this.normalScale=new st(1,1),this.displacementMap=null,this.displacementScale=1,this.displacementBias=0,this.roughnessMap=null,this.metalnessMap=null,this.alphaMap=null,this.envMap=null,this.envMapIntensity=1,this.refractionRatio=.98,this.wireframe=!1,this.wireframeLinewidth=1,this.wireframeLinecap="round",this.wireframeLinejoin="round",this.flatShading=!1,this.setValues(t)}copy(t){return super.copy(t),this.defines={STANDARD:""},this.color.copy(t.color),this.roughness=t.roughness,this.metalness=t.metalness,this.map=t.map,this.lightMap=t.lightMap,this.lightMapIntensity=t.lightMapIntensity,this.aoMap=t.aoMap,this.aoMapIntensity=t.aoMapIntensity,this.emissive.copy(t.emissive),this.emissiveMap=t.emissiveMap,this.emissiveIntensity=t.emissiveIntensity,this.bumpMap=t.bumpMap,this.bumpScale=t.bumpScale,this.normalMap=t.normalMap,this.normalMapType=t.normalMapType,this.normalScale.copy(t.normalScale),this.displacementMap=t.displacementMap,this.displacementScale=t.displacementScale,this.displacementBias=t.displacementBias,this.roughnessMap=t.roughnessMap,this.metalnessMap=t.metalnessMap,this.alphaMap=t.alphaMap,this.envMap=t.envMap,this.envMapIntensity=t.envMapIntensity,this.refractionRatio=t.refractionRatio,this.wireframe=t.wireframe,this.wireframeLinewidth=t.wireframeLinewidth,this.wireframeLinecap=t.wireframeLinecap,this.wireframeLinejoin=t.wireframeLinejoin,this.flatShading=t.flatShading,this}}Tu.prototype.isMeshStandardMaterial=!0;class j0 extends Tu{constructor(t){super(),this.defines={STANDARD:"",PHYSICAL:""},this.type="MeshPhysicalMaterial",this.clearcoatMap=null,this.clearcoatRoughness=0,this.clearcoatRoughnessMap=null,this.clearcoatNormalScale=new st(1,1),this.clearcoatNormalMap=null,this.ior=1.5,Object.defineProperty(this,"reflectivity",{get:function(){return We(2.5*(this.ior-1)/(this.ior+1),0,1)},set:function(e){this.ior=(1+.4*e)/(1-.4*e)}}),this.sheenColor=new Et(0),this.sheenColorMap=null,this.sheenRoughness=1,this.sheenRoughnessMap=null,this.transmissionMap=null,this.thickness=0,this.thicknessMap=null,this.attenuationDistance=0,this.attenuationColor=new Et(1,1,1),this.specularIntensity=1,this.specularIntensityMap=null,this.specularColor=new Et(1,1,1),this.specularColorMap=null,this._sheen=0,this._clearcoat=0,this._transmission=0,this.setValues(t)}get sheen(){return this._sheen}set sheen(t){this._sheen>0!=t>0&&this.version++,this._sheen=t}get clearcoat(){return this._clearcoat}set clearcoat(t){this._clearcoat>0!=t>0&&this.version++,this._clearcoat=t}get transmission(){return this._transmission}set transmission(t){this._transmission>0!=t>0&&this.version++,this._transmission=t}copy(t){return super.copy(t),this.defines={STANDARD:"",PHYSICAL:""},this.clearcoat=t.clearcoat,this.clearcoatMap=t.clearcoatMap,this.clearcoatRoughness=t.clearcoatRoughness,this.clearcoatRoughnessMap=t.clearcoatRoughnessMap,this.clearcoatNormalMap=t.clearcoatNormalMap,this.clearcoatNormalScale.copy(t.clearcoatNormalScale),this.ior=t.ior,this.sheen=t.sheen,this.sheenColor.copy(t.sheenColor),this.sheenColorMap=t.sheenColorMap,this.sheenRoughness=t.sheenRoughness,this.sheenRoughnessMap=t.sheenRoughnessMap,this.transmission=t.transmission,this.transmissionMap=t.transmissionMap,this.thickness=t.thickness,this.thicknessMap=t.thicknessMap,this.attenuationDistance=t.attenuationDistance,this.attenuationColor.copy(t.attenuationColor),this.specularIntensity=t.specularIntensity,this.specularIntensityMap=t.specularIntensityMap,this.specularColor.copy(t.specularColor),this.specularColorMap=t.specularColorMap,this}}j0.prototype.isMeshPhysicalMaterial=!0;class X0 extends Pe{constructor(t){super(),this.type="MeshPhongMaterial",this.color=new Et(16777215),this.specular=new Et(1118481),this.shininess=30,this.map=null,this.lightMap=null,this.lightMapIntensity=1,this.aoMap=null,this.aoMapIntensity=1,this.emissive=new Et(0),this.emissiveIntensity=1,this.emissiveMap=null,this.bumpMap=null,this.bumpScale=1,this.normalMap=null,this.normalMapType=Qi,this.normalScale=new st(1,1),this.displacementMap=null,this.displacementScale=1,this.displacementBias=0,this.specularMap=null,this.alphaMap=null,this.envMap=null,this.combine=Zs,this.reflectivity=1,this.refractionRatio=.98,this.wireframe=!1,this.wireframeLinewidth=1,this.wireframeLinecap="round",this.wireframeLinejoin="round",this.flatShading=!1,this.setValues(t)}copy(t){return super.copy(t),this.color.copy(t.color),this.specular.copy(t.specular),this.shininess=t.shininess,this.map=t.map,this.lightMap=t.lightMap,this.lightMapIntensity=t.lightMapIntensity,this.aoMap=t.aoMap,this.aoMapIntensity=t.aoMapIntensity,this.emissive.copy(t.emissive),this.emissiveMap=t.emissiveMap,this.emissiveIntensity=t.emissiveIntensity,this.bumpMap=t.bumpMap,this.bumpScale=t.bumpScale,this.normalMap=t.normalMap,this.normalMapType=t.normalMapType,this.normalScale.copy(t.normalScale),this.displacementMap=t.displacementMap,this.displacementScale=t.displacementScale,this.displacementBias=t.displacementBias,this.specularMap=t.specularMap,this.alphaMap=t.alphaMap,this.envMap=t.envMap,this.combine=t.combine,this.reflectivity=t.reflectivity,this.refractionRatio=t.refractionRatio,this.wireframe=t.wireframe,this.wireframeLinewidth=t.wireframeLinewidth,this.wireframeLinecap=t.wireframeLinecap,this.wireframeLinejoin=t.wireframeLinejoin,this.flatShading=t.flatShading,this}}X0.prototype.isMeshPhongMaterial=!0;class $0 extends Pe{constructor(t){super(),this.defines={TOON:""},this.type="MeshToonMaterial",this.color=new Et(16777215),this.map=null,this.gradientMap=null,this.lightMap=null,this.lightMapIntensity=1,this.aoMap=null,this.aoMapIntensity=1,this.emissive=new Et(0),this.emissiveIntensity=1,this.emissiveMap=null,this.bumpMap=null,this.bumpScale=1,this.normalMap=null,this.normalMapType=Qi,this.normalScale=new st(1,1),this.displacementMap=null,this.displacementScale=1,this.displacementBias=0,this.alphaMap=null,this.wireframe=!1,this.wireframeLinewidth=1,this.wireframeLinecap="round",this.wireframeLinejoin="round",this.setValues(t)}copy(t){return super.copy(t),this.color.copy(t.color),this.map=t.map,this.gradientMap=t.gradientMap,this.lightMap=t.lightMap,this.lightMapIntensity=t.lightMapIntensity,this.aoMap=t.aoMap,this.aoMapIntensity=t.aoMapIntensity,this.emissive.copy(t.emissive),this.emissiveMap=t.emissiveMap,this.emissiveIntensity=t.emissiveIntensity,this.bumpMap=t.bumpMap,this.bumpScale=t.bumpScale,this.normalMap=t.normalMap,this.normalMapType=t.normalMapType,this.normalScale.copy(t.normalScale),this.displacementMap=t.displacementMap,this.displacementScale=t.displacementScale,this.displacementBias=t.displacementBias,this.alphaMap=t.alphaMap,this.wireframe=t.wireframe,this.wireframeLinewidth=t.wireframeLinewidth,this.wireframeLinecap=t.wireframeLinecap,this.wireframeLinejoin=t.wireframeLinejoin,this}}$0.prototype.isMeshToonMaterial=!0;class Y0 extends Pe{constructor(t){super(),this.type="MeshNormalMaterial",this.bumpMap=null,this.bumpScale=1,this.normalMap=null,this.normalMapType=Qi,this.normalScale=new st(1,1),this.displacementMap=null,this.displacementScale=1,this.displacementBias=0,this.wireframe=!1,this.wireframeLinewidth=1,this.fog=!1,this.flatShading=!1,this.setValues(t)}copy(t){return super.copy(t),this.bumpMap=t.bumpMap,this.bumpScale=t.bumpScale,this.normalMap=t.normalMap,this.normalMapType=t.normalMapType,this.normalScale.copy(t.normalScale),this.displacementMap=t.displacementMap,this.displacementScale=t.displacementScale,this.displacementBias=t.displacementBias,this.wireframe=t.wireframe,this.wireframeLinewidth=t.wireframeLinewidth,this.flatShading=t.flatShading,this}}Y0.prototype.isMeshNormalMaterial=!0;class J0 extends Pe{constructor(t){super(),this.type="MeshLambertMaterial",this.color=new Et(16777215),this.map=null,this.lightMap=null,this.lightMapIntensity=1,this.aoMap=null,this.aoMapIntensity=1,this.emissive=new Et(0),this.emissiveIntensity=1,this.emissiveMap=null,this.specularMap=null,this.alphaMap=null,this.envMap=null,this.combine=Zs,this.reflectivity=1,this.refractionRatio=.98,this.wireframe=!1,this.wireframeLinewidth=1,this.wireframeLinecap="round",this.wireframeLinejoin="round",this.setValues(t)}copy(t){return super.copy(t),this.color.copy(t.color),this.map=t.map,this.lightMap=t.lightMap,this.lightMapIntensity=t.lightMapIntensity,this.aoMap=t.aoMap,this.aoMapIntensity=t.aoMapIntensity,this.emissive.copy(t.emissive),this.emissiveMap=t.emissiveMap,this.emissiveIntensity=t.emissiveIntensity,this.specularMap=t.specularMap,this.alphaMap=t.alphaMap,this.envMap=t.envMap,this.combine=t.combine,this.reflectivity=t.reflectivity,this.refractionRatio=t.refractionRatio,this.wireframe=t.wireframe,this.wireframeLinewidth=t.wireframeLinewidth,this.wireframeLinecap=t.wireframeLinecap,this.wireframeLinejoin=t.wireframeLinejoin,this}}J0.prototype.isMeshLambertMaterial=!0;class Z0 extends Pe{constructor(t){super(),this.defines={MATCAP:""},this.type="MeshMatcapMaterial",this.color=new Et(16777215),this.matcap=null,this.map=null,this.bumpMap=null,this.bumpScale=1,this.normalMap=null,this.normalMapType=Qi,this.normalScale=new st(1,1),this.displacementMap=null,this.displacementScale=1,this.displacementBias=0,this.alphaMap=null,this.flatShading=!1,this.setValues(t)}copy(t){return super.copy(t),this.defines={MATCAP:""},this.color.copy(t.color),this.matcap=t.matcap,this.map=t.map,this.bumpMap=t.bumpMap,this.bumpScale=t.bumpScale,this.normalMap=t.normalMap,this.normalMapType=t.normalMapType,this.normalScale.copy(t.normalScale),this.displacementMap=t.displacementMap,this.displacementScale=t.displacementScale,this.displacementBias=t.displacementBias,this.alphaMap=t.alphaMap,this.flatShading=t.flatShading,this}}Z0.prototype.isMeshMatcapMaterial=!0;class K0 extends Jr{constructor(t){super(),this.type="LineDashedMaterial",this.scale=1,this.dashSize=3,this.gapSize=1,this.setValues(t)}copy(t){return super.copy(t),this.scale=t.scale,this.dashSize=t.dashSize,this.gapSize=t.gapSize,this}}K0.prototype.isLineDashedMaterial=!0;const le={arraySlice:function(o,t,e){return le.isTypedArray(o)?new o.constructor(o.subarray(t,e!==void 0?e:o.length)):o.slice(t,e)},convertArray:function(o,t,e){return!o||!e&&o.constructor===t?o:typeof t.BYTES_PER_ELEMENT=="number"?new t(o):Array.prototype.slice.call(o)},isTypedArray:function(o){return ArrayBuffer.isView(o)&&!(o instanceof DataView)},getKeyframeOrder:function(o){function t(r,s){return o[r]-o[s]}const e=o.length,n=new Array(e);for(let r=0;r!==e;++r)n[r]=r;return n.sort(t),n},sortedArray:function(o,t,e){const n=o.length,r=new o.constructor(n);for(let s=0,l=0;l!==n;++s){const h=e[s]*t;for(let d=0;d!==t;++d)r[l++]=o[h+d]}return r},flattenJSON:function(o,t,e,n){let r=1,s=o[0];for(;s!==void 0&&s[n]===void 0;)s=o[r++];if(s===void 0)return;let l=s[n];if(l!==void 0)if(Array.isArray(l))do l=s[n],l!==void 0&&(t.push(s.time),e.push.apply(e,l)),s=o[r++];while(s!==void 0);else if(l.toArray!==void 0)do l=s[n],l!==void 0&&(t.push(s.time),l.toArray(e,e.length)),s=o[r++];while(s!==void 0);else do l=s[n],l!==void 0&&(t.push(s.time),e.push(l)),s=o[r++];while(s!==void 0)},subclip:function(o,t,e,n,r=30){const s=o.clone();s.name=t;const l=[];for(let d=0;d<s.tracks.length;++d){const p=s.tracks[d],f=p.getValueSize(),m=[],g=[];for(let _=0;_<p.times.length;++_){const y=p.times[_]*r;if(!(y<e||y>=n)){m.push(p.times[_]);for(let w=0;w<f;++w)g.push(p.values[_*f+w])}}m.length!==0&&(p.times=le.convertArray(m,p.times.constructor),p.values=le.convertArray(g,p.values.constructor),l.push(p))}s.tracks=l;let h=1/0;for(let d=0;d<s.tracks.length;++d)h>s.tracks[d].times[0]&&(h=s.tracks[d].times[0]);for(let d=0;d<s.tracks.length;++d)s.tracks[d].shift(-1*h);return s.resetDuration(),s},makeClipAdditive:function(o,t=0,e=o,n=30){n<=0&&(n=30);const r=e.tracks.length,s=t/n;for(let l=0;l<r;++l){const h=e.tracks[l],d=h.ValueTypeName;if(d==="bool"||d==="string")continue;const p=o.tracks.find(function(x){return x.name===h.name&&x.ValueTypeName===d});if(p===void 0)continue;let f=0;const m=h.getValueSize();h.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline&&(f=m/3);let g=0;const _=p.getValueSize();p.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline&&(g=_/3);const y=h.times.length-1;let w;if(s<=h.times[0]){const x=f,v=m-f;w=le.arraySlice(h.values,x,v)}else if(s>=h.times[y]){const x=y*m+f,v=x+m-f;w=le.arraySlice(h.values,x,v)}else{const x=h.createInterpolant(),v=f,N=m-f;x.evaluate(s),w=le.arraySlice(x.resultBuffer,v,N)}d==="quaternion"&&new Be().fromArray(w).normalize().conjugate().toArray(w);const S=p.times.length;for(let x=0;x<S;++x){const v=x*_+g;if(d==="quaternion")Be.multiplyQuaternionsFlat(p.values,v,w,0,p.values,v);else{const N=_-g*2;for(let M=0;M<N;++M)p.values[v+M]-=w[M]}}}return o.blendMode=Wh,o}};class Jn{constructor(t,e,n,r){this.parameterPositions=t,this._cachedIndex=0,this.resultBuffer=r!==void 0?r:new e.constructor(n),this.sampleValues=e,this.valueSize=n,this.settings=null,this.DefaultSettings_={}}evaluate(t){const e=this.parameterPositions;let n=this._cachedIndex,r=e[n],s=e[n-1];t:{e:{let l;n:{i:if(!(t<r)){for(let h=n+2;;){if(r===void 0){if(t<s)break i;return n=e.length,this._cachedIndex=n,this.afterEnd_(n-1,t,s)}if(n===h)break;if(s=r,r=e[++n],t<r)break e}l=e.length;break n}if(!(t>=s)){const h=e[1];t<h&&(n=2,s=h);for(let d=n-2;;){if(s===void 0)return this._cachedIndex=0,this.beforeStart_(0,t,r);if(n===d)break;if(r=s,s=e[--n-1],t>=s)break e}l=n,n=0;break n}break t}for(;n<l;){const h=n+l>>>1;t<e[h]?l=h:n=h+1}if(r=e[n],s=e[n-1],s===void 0)return this._cachedIndex=0,this.beforeStart_(0,t,r);if(r===void 0)return n=e.length,this._cachedIndex=n,this.afterEnd_(n-1,s,t)}this._cachedIndex=n,this.intervalChanged_(n,s,r)}return this.interpolate_(n,s,t,r)}getSettings_(){return this.settings||this.DefaultSettings_}copySampleValue_(t){const e=this.resultBuffer,n=this.sampleValues,r=this.valueSize,s=t*r;for(let l=0;l!==r;++l)e[l]=n[s+l];return e}interpolate_(){throw new Error("call to abstract method")}intervalChanged_(){}}Jn.prototype.beforeStart_=Jn.prototype.copySampleValue_;Jn.prototype.afterEnd_=Jn.prototype.copySampleValue_;class Q0 extends Jn{constructor(t,e,n,r){super(t,e,n,r),this._weightPrev=-0,this._offsetPrev=-0,this._weightNext=-0,this._offsetNext=-0,this.DefaultSettings_={endingStart:Gi,endingEnd:Gi}}intervalChanged_(t,e,n){const r=this.parameterPositions;let s=t-2,l=t+1,h=r[s],d=r[l];if(h===void 0)switch(this.getSettings_().endingStart){case Wi:s=t,h=2*e-n;break;case qs:s=r.length-2,h=e+r[s]-r[s+1];break;default:s=t,h=n}if(d===void 0)switch(this.getSettings_().endingEnd){case Wi:l=t,d=2*n-e;break;case qs:l=1,d=n+r[1]-r[0];break;default:l=t-1,d=e}const p=(n-e)*.5,f=this.valueSize;this._weightPrev=p/(e-h),this._weightNext=p/(d-n),this._offsetPrev=s*f,this._offsetNext=l*f}interpolate_(t,e,n,r){const s=this.resultBuffer,l=this.sampleValues,h=this.valueSize,d=t*h,p=d-h,f=this._offsetPrev,m=this._offsetNext,g=this._weightPrev,_=this._weightNext,y=(n-e)/(r-e),w=y*y,S=w*y,x=-g*S+2*g*w-g*y,v=(1+g)*S+(-1.5-2*g)*w+(-.5+g)*y+1,N=(-1-_)*S+(1.5+_)*w+.5*y,M=_*S-_*w;for(let R=0;R!==h;++R)s[R]=x*l[f+R]+v*l[p+R]+N*l[d+R]+M*l[m+R];return s}}class Cu extends Jn{constructor(t,e,n,r){super(t,e,n,r)}interpolate_(t,e,n,r){const s=this.resultBuffer,l=this.sampleValues,h=this.valueSize,d=t*h,p=d-h,f=(n-e)/(r-e),m=1-f;for(let g=0;g!==h;++g)s[g]=l[p+g]*m+l[d+g]*f;return s}}class ty extends Jn{constructor(t,e,n,r){super(t,e,n,r)}interpolate_(t){return this.copySampleValue_(t-1)}}class un{constructor(t,e,n,r){if(t===void 0)throw new Error("THREE.KeyframeTrack: track name is undefined");if(e===void 0||e.length===0)throw new Error("THREE.KeyframeTrack: no keyframes in track named "+t);this.name=t,this.times=le.convertArray(e,this.TimeBufferType),this.values=le.convertArray(n,this.ValueBufferType),this.setInterpolation(r||this.DefaultInterpolation)}static toJSON(t){const e=t.constructor;let n;if(e.toJSON!==this.toJSON)n=e.toJSON(t);else{n={name:t.name,times:le.convertArray(t.times,Array),values:le.convertArray(t.values,Array)};const r=t.getInterpolation();r!==t.DefaultInterpolation&&(n.interpolation=r)}return n.type=t.ValueTypeName,n}InterpolantFactoryMethodDiscrete(t){return new ty(this.times,this.values,this.getValueSize(),t)}InterpolantFactoryMethodLinear(t){return new Cu(this.times,this.values,this.getValueSize(),t)}InterpolantFactoryMethodSmooth(t){return new Q0(this.times,this.values,this.getValueSize(),t)}setInterpolation(t){let e;switch(t){case Gs:e=this.InterpolantFactoryMethodDiscrete;break;case Ws:e=this.InterpolantFactoryMethodLinear;break;case ko:e=this.InterpolantFactoryMethodSmooth;break}if(e===void 0){const n="unsupported interpolation for "+this.ValueTypeName+" keyframe track named "+this.name;if(this.createInterpolant===void 0)if(t!==this.DefaultInterpolation)this.setInterpolation(this.DefaultInterpolation);else throw new Error(n);return console.warn("THREE.KeyframeTrack:",n),this}return this.createInterpolant=e,this}getInterpolation(){switch(this.createInterpolant){case this.InterpolantFactoryMethodDiscrete:return Gs;case this.InterpolantFactoryMethodLinear:return Ws;case this.InterpolantFactoryMethodSmooth:return ko}}getValueSize(){return this.values.length/this.times.length}shift(t){if(t!==0){const e=this.times;for(let n=0,r=e.length;n!==r;++n)e[n]+=t}return this}scale(t){if(t!==1){const e=this.times;for(let n=0,r=e.length;n!==r;++n)e[n]*=t}return this}trim(t,e){const n=this.times,r=n.length;let s=0,l=r-1;for(;s!==r&&n[s]<t;)++s;for(;l!==-1&&n[l]>e;)--l;if(++l,s!==0||l!==r){s>=l&&(l=Math.max(l,1),s=l-1);const h=this.getValueSize();this.times=le.arraySlice(n,s,l),this.values=le.arraySlice(this.values,s*h,l*h)}return this}validate(){let t=!0;const e=this.getValueSize();e-Math.floor(e)!==0&&(console.error("THREE.KeyframeTrack: Invalid value size in track.",this),t=!1);const n=this.times,r=this.values,s=n.length;s===0&&(console.error("THREE.KeyframeTrack: Track is empty.",this),t=!1);let l=null;for(let h=0;h!==s;h++){const d=n[h];if(typeof d=="number"&&isNaN(d)){console.error("THREE.KeyframeTrack: Time is not a valid number.",this,h,d),t=!1;break}if(l!==null&&l>d){console.error("THREE.KeyframeTrack: Out of order keys.",this,h,d,l),t=!1;break}l=d}if(r!==void 0&&le.isTypedArray(r))for(let h=0,d=r.length;h!==d;++h){const p=r[h];if(isNaN(p)){console.error("THREE.KeyframeTrack: Value is not a valid number.",this,h,p),t=!1;break}}return t}optimize(){const t=le.arraySlice(this.times),e=le.arraySlice(this.values),n=this.getValueSize(),r=this.getInterpolation()===ko,s=t.length-1;let l=1;for(let h=1;h<s;++h){let d=!1;const p=t[h],f=t[h+1];if(p!==f&&(h!==1||p!==t[0]))if(r)d=!0;else{const m=h*n,g=m-n,_=m+n;for(let y=0;y!==n;++y){const w=e[m+y];if(w!==e[g+y]||w!==e[_+y]){d=!0;break}}}if(d){if(h!==l){t[l]=t[h];const m=h*n,g=l*n;for(let _=0;_!==n;++_)e[g+_]=e[m+_]}++l}}if(s>0){t[l]=t[s];for(let h=s*n,d=l*n,p=0;p!==n;++p)e[d+p]=e[h+p];++l}return l!==t.length?(this.times=le.arraySlice(t,0,l),this.values=le.arraySlice(e,0,l*n)):(this.times=t,this.values=e),this}clone(){const t=le.arraySlice(this.times,0),e=le.arraySlice(this.values,0),n=this.constructor,r=new n(this.name,t,e);return r.createInterpolant=this.createInterpolant,r}}un.prototype.TimeBufferType=Float32Array;un.prototype.ValueBufferType=Float32Array;un.prototype.DefaultInterpolation=Ws;class or extends un{}or.prototype.ValueTypeName="bool";or.prototype.ValueBufferType=Array;or.prototype.DefaultInterpolation=Gs;or.prototype.InterpolantFactoryMethodLinear=void 0;or.prototype.InterpolantFactoryMethodSmooth=void 0;class Au extends un{}Au.prototype.ValueTypeName="color";class Ys extends un{}Ys.prototype.ValueTypeName="number";class ey extends Jn{constructor(t,e,n,r){super(t,e,n,r)}interpolate_(t,e,n,r){const s=this.resultBuffer,l=this.sampleValues,h=this.valueSize,d=(n-e)/(r-e);let p=t*h;for(let f=p+h;p!==f;p+=4)Be.slerpFlat(s,0,l,p-h,l,p,d);return s}}class Zr extends un{InterpolantFactoryMethodLinear(t){return new ey(this.times,this.values,this.getValueSize(),t)}}Zr.prototype.ValueTypeName="quaternion";Zr.prototype.DefaultInterpolation=Ws;Zr.prototype.InterpolantFactoryMethodSmooth=void 0;class ar extends un{}ar.prototype.ValueTypeName="string";ar.prototype.ValueBufferType=Array;ar.prototype.DefaultInterpolation=Gs;ar.prototype.InterpolantFactoryMethodLinear=void 0;ar.prototype.InterpolantFactoryMethodSmooth=void 0;class Js extends un{}Js.prototype.ValueTypeName="vector";class Dh{constructor(t,e=-1,n,r=Na){this.name=t,this.tracks=n,this.duration=e,this.blendMode=r,this.uuid=cn(),this.duration<0&&this.resetDuration()}static parse(t){const e=[],n=t.tracks,r=1/(t.fps||1);for(let l=0,h=n.length;l!==h;++l)e.push(iy(n[l]).scale(r));const s=new this(t.name,t.duration,e,t.blendMode);return s.uuid=t.uuid,s}static toJSON(t){const e=[],n=t.tracks,r={name:t.name,duration:t.duration,tracks:e,uuid:t.uuid,blendMode:t.blendMode};for(let s=0,l=n.length;s!==l;++s)e.push(un.toJSON(n[s]));return r}static CreateFromMorphTargetSequence(t,e,n,r){const s=e.length,l=[];for(let h=0;h<s;h++){let d=[],p=[];d.push((h+s-1)%s,h,(h+1)%s),p.push(0,1,0);const f=le.getKeyframeOrder(d);d=le.sortedArray(d,1,f),p=le.sortedArray(p,1,f),!r&&d[0]===0&&(d.push(s),p.push(p[0])),l.push(new Ys(".morphTargetInfluences["+e[h].name+"]",d,p).scale(1/n))}return new this(t,-1,l)}static findByName(t,e){let n=t;if(!Array.isArray(t)){const r=t;n=r.geometry&&r.geometry.animations||r.animations}for(let r=0;r<n.length;r++)if(n[r].name===e)return n[r];return null}static CreateClipsFromMorphTargetSequences(t,e,n){const r={},s=/^([\w-]*?)([\d]+)$/;for(let h=0,d=t.length;h<d;h++){const p=t[h],f=p.name.match(s);if(f&&f.length>1){const m=f[1];let g=r[m];g||(r[m]=g=[]),g.push(p)}}const l=[];for(const h in r)l.push(this.CreateFromMorphTargetSequence(h,r[h],e,n));return l}static parseAnimation(t,e){if(!t)return console.error("THREE.AnimationClip: No animation in JSONLoader data."),null;const n=function(m,g,_,y,w){if(_.length!==0){const S=[],x=[];le.flattenJSON(_,S,x,y),S.length!==0&&w.push(new m(g,S,x))}},r=[],s=t.name||"default",l=t.fps||30,h=t.blendMode;let d=t.length||-1;const p=t.hierarchy||[];for(let m=0;m<p.length;m++){const g=p[m].keys;if(!(!g||g.length===0))if(g[0].morphTargets){const _={};let y;for(y=0;y<g.length;y++)if(g[y].morphTargets)for(let w=0;w<g[y].morphTargets.length;w++)_[g[y].morphTargets[w]]=-1;for(const w in _){const S=[],x=[];for(let v=0;v!==g[y].morphTargets.length;++v){const N=g[y];S.push(N.time),x.push(N.morphTarget===w?1:0)}r.push(new Ys(".morphTargetInfluence["+w+"]",S,x))}d=_.length*(l||1)}else{const _=".bones["+e[m].name+"]";n(Js,_+".position",g,"pos",r),n(Zr,_+".quaternion",g,"rot",r),n(Js,_+".scale",g,"scl",r)}}return r.length===0?null:new this(s,d,r,h)}resetDuration(){const t=this.tracks;let e=0;for(let n=0,r=t.length;n!==r;++n){const s=this.tracks[n];e=Math.max(e,s.times[s.times.length-1])}return this.duration=e,this}trim(){for(let t=0;t<this.tracks.length;t++)this.tracks[t].trim(0,this.duration);return this}validate(){let t=!0;for(let e=0;e<this.tracks.length;e++)t=t&&this.tracks[e].validate();return t}optimize(){for(let t=0;t<this.tracks.length;t++)this.tracks[t].optimize();return this}clone(){const t=[];for(let e=0;e<this.tracks.length;e++)t.push(this.tracks[e].clone());return new this.constructor(this.name,this.duration,t,this.blendMode)}toJSON(){return this.constructor.toJSON(this)}}function ny(o){switch(o.toLowerCase()){case"scalar":case"double":case"float":case"number":case"integer":return Ys;case"vector":case"vector2":case"vector3":case"vector4":return Js;case"color":return Au;case"quaternion":return Zr;case"bool":case"boolean":return or;case"string":return ar}throw new Error("THREE.KeyframeTrack: Unsupported typeName: "+o)}function iy(o){if(o.type===void 0)throw new Error("THREE.KeyframeTrack: track type undefined, can not parse");const t=ny(o.type);if(o.times===void 0){const e=[],n=[];le.flattenJSON(o.keys,e,n,"value"),o.times=e,o.values=n}return t.parse!==void 0?t.parse(o):new t(o.name,o.times,o.values,o.interpolation)}const Zi={enabled:!1,files:{},add:function(o,t){this.enabled!==!1&&(this.files[o]=t)},get:function(o){if(this.enabled!==!1)return this.files[o]},remove:function(o){delete this.files[o]},clear:function(){this.files={}}};class ry{constructor(t,e,n){const r=this;let s=!1,l=0,h=0,d;const p=[];this.onStart=void 0,this.onLoad=t,this.onProgress=e,this.onError=n,this.itemStart=function(f){h++,s===!1&&r.onStart!==void 0&&r.onStart(f,l,h),s=!0},this.itemEnd=function(f){l++,r.onProgress!==void 0&&r.onProgress(f,l,h),l===h&&(s=!1,r.onLoad!==void 0&&r.onLoad())},this.itemError=function(f){r.onError!==void 0&&r.onError(f)},this.resolveURL=function(f){return d?d(f):f},this.setURLModifier=function(f){return d=f,this},this.addHandler=function(f,m){return p.push(f,m),this},this.removeHandler=function(f){const m=p.indexOf(f);return m!==-1&&p.splice(m,2),this},this.getHandler=function(f){for(let m=0,g=p.length;m<g;m+=2){const _=p[m],y=p[m+1];if(_.global&&(_.lastIndex=0),_.test(f))return y}return null}}}const sy=new ry;class Cn{constructor(t){this.manager=t!==void 0?t:sy,this.crossOrigin="anonymous",this.withCredentials=!1,this.path="",this.resourcePath="",this.requestHeader={}}load(){}loadAsync(t,e){const n=this;return new Promise(function(r,s){n.load(t,r,e,s)})}parse(){}setCrossOrigin(t){return this.crossOrigin=t,this}setWithCredentials(t){return this.withCredentials=t,this}setPath(t){return this.path=t,this}setResourcePath(t){return this.resourcePath=t,this}setRequestHeader(t){return this.requestHeader=t,this}}const Mn={};class Pu extends Cn{constructor(t){super(t)}load(t,e,n,r){t===void 0&&(t=""),this.path!==void 0&&(t=this.path+t),t=this.manager.resolveURL(t);const s=Zi.get(t);if(s!==void 0)return this.manager.itemStart(t),setTimeout(()=>{e&&e(s),this.manager.itemEnd(t)},0),s;if(Mn[t]!==void 0){Mn[t].push({onLoad:e,onProgress:n,onError:r});return}Mn[t]=[],Mn[t].push({onLoad:e,onProgress:n,onError:r});const l=new Request(t,{headers:new Headers(this.requestHeader),credentials:this.withCredentials?"include":"same-origin"});fetch(l).then(h=>{if(h.status===200||h.status===0){if(h.status===0&&console.warn("THREE.FileLoader: HTTP Status 0 received."),typeof ReadableStream=="undefined"||h.body.getReader===void 0)return h;const d=Mn[t],p=h.body.getReader(),f=h.headers.get("Content-Length"),m=f?parseInt(f):0,g=m!==0;let _=0;const y=new ReadableStream({start(w){S();function S(){p.read().then(({done:x,value:v})=>{if(x)w.close();else{_+=v.byteLength;const N=new ProgressEvent("progress",{lengthComputable:g,loaded:_,total:m});for(let M=0,R=d.length;M<R;M++){const F=d[M];F.onProgress&&F.onProgress(N)}w.enqueue(v),S()}})}}});return new Response(y)}else throw Error(`fetch for "${h.url}" responded with ${h.status}: ${h.statusText}`)}).then(h=>{switch(this.responseType){case"arraybuffer":return h.arrayBuffer();case"blob":return h.blob();case"document":return h.text().then(d=>new DOMParser().parseFromString(d,this.mimeType));case"json":return h.json();default:return h.text()}}).then(h=>{Zi.add(t,h);const d=Mn[t];delete Mn[t];for(let p=0,f=d.length;p<f;p++){const m=d[p];m.onLoad&&m.onLoad(h)}}).catch(h=>{const d=Mn[t];if(d===void 0)throw this.manager.itemError(t),h;delete Mn[t];for(let p=0,f=d.length;p<f;p++){const m=d[p];m.onError&&m.onError(h)}this.manager.itemError(t)}).finally(()=>{this.manager.itemEnd(t)}),this.manager.itemStart(t)}setResponseType(t){return this.responseType=t,this}setMimeType(t){return this.mimeType=t,this}}class Lu extends Cn{constructor(t){super(t)}load(t,e,n,r){this.path!==void 0&&(t=this.path+t),t=this.manager.resolveURL(t);const s=this,l=Zi.get(t);if(l!==void 0)return s.manager.itemStart(t),setTimeout(function(){e&&e(l),s.manager.itemEnd(t)},0),l;const h=to("img");function d(){f(),Zi.add(t,this),e&&e(this),s.manager.itemEnd(t)}function p(m){f(),r&&r(m),s.manager.itemError(t),s.manager.itemEnd(t)}function f(){h.removeEventListener("load",d,!1),h.removeEventListener("error",p,!1)}return h.addEventListener("load",d,!1),h.addEventListener("error",p,!1),t.substr(0,5)!=="data:"&&this.crossOrigin!==void 0&&(h.crossOrigin=this.crossOrigin),s.manager.itemStart(t),h.src=t,h}}class oy extends Cn{constructor(t){super(t)}load(t,e,n,r){const s=new eo,l=new Lu(this.manager);l.setCrossOrigin(this.crossOrigin),l.setPath(this.path);let h=0;function d(p){l.load(t[p],function(f){s.images[p]=f,h++,h===6&&(s.needsUpdate=!0,e&&e(s))},void 0,r)}for(let p=0;p<t.length;++p)d(p);return s}}class ay extends Cn{constructor(t){super(t)}load(t,e,n,r){const s=new we,l=new Lu(this.manager);return l.setCrossOrigin(this.crossOrigin),l.setPath(this.path),l.load(t,function(h){s.image=h,s.needsUpdate=!0,e!==void 0&&e(s)},n,r),s}}class hn extends te{constructor(t,e=1){super(),this.type="Light",this.color=new Et(t),this.intensity=e}dispose(){}copy(t){return super.copy(t),this.color.copy(t.color),this.intensity=t.intensity,this}toJSON(t){const e=super.toJSON(t);return e.object.color=this.color.getHex(),e.object.intensity=this.intensity,this.groundColor!==void 0&&(e.object.groundColor=this.groundColor.getHex()),this.distance!==void 0&&(e.object.distance=this.distance),this.angle!==void 0&&(e.object.angle=this.angle),this.decay!==void 0&&(e.object.decay=this.decay),this.penumbra!==void 0&&(e.object.penumbra=this.penumbra),this.shadow!==void 0&&(e.object.shadow=this.shadow.toJSON()),e}}hn.prototype.isLight=!0;class ly extends hn{constructor(t,e,n){super(t,n),this.type="HemisphereLight",this.position.copy(te.DefaultUp),this.updateMatrix(),this.groundColor=new Et(e)}copy(t){return hn.prototype.copy.call(this,t),this.groundColor.copy(t.groundColor),this}}ly.prototype.isHemisphereLight=!0;const Ih=new At,Nh=new D,Fh=new D;class Za{constructor(t){this.camera=t,this.bias=0,this.normalBias=0,this.radius=1,this.blurSamples=8,this.mapSize=new st(512,512),this.map=null,this.mapPass=null,this.matrix=new At,this.autoUpdate=!0,this.needsUpdate=!1,this._frustum=new no,this._frameExtents=new st(1,1),this._viewportCount=1,this._viewports=[new re(0,0,1,1)]}getViewportCount(){return this._viewportCount}getFrustum(){return this._frustum}updateMatrices(t){const e=this.camera,n=this.matrix;Nh.setFromMatrixPosition(t.matrixWorld),e.position.copy(Nh),Fh.setFromMatrixPosition(t.target.matrixWorld),e.lookAt(Fh),e.updateMatrixWorld(),Ih.multiplyMatrices(e.projectionMatrix,e.matrixWorldInverse),this._frustum.setFromProjectionMatrix(Ih),n.set(.5,0,0,.5,0,.5,0,.5,0,0,.5,.5,0,0,0,1),n.multiply(e.projectionMatrix),n.multiply(e.matrixWorldInverse)}getViewport(t){return this._viewports[t]}getFrameExtents(){return this._frameExtents}dispose(){this.map&&this.map.dispose(),this.mapPass&&this.mapPass.dispose()}copy(t){return this.camera=t.camera.clone(),this.bias=t.bias,this.radius=t.radius,this.mapSize.copy(t.mapSize),this}clone(){return new this.constructor().copy(this)}toJSON(){const t={};return this.bias!==0&&(t.bias=this.bias),this.normalBias!==0&&(t.normalBias=this.normalBias),this.radius!==1&&(t.radius=this.radius),(this.mapSize.x!==512||this.mapSize.y!==512)&&(t.mapSize=this.mapSize.toArray()),t.camera=this.camera.toJSON(!1).object,delete t.camera.matrix,t}}class Ru extends Za{constructor(){super(new ke(50,1,.5,500)),this.focus=1}updateMatrices(t){const e=this.camera,n=Ea*2*t.angle*this.focus,r=this.mapSize.width/this.mapSize.height,s=t.distance||e.far;(n!==e.fov||r!==e.aspect||s!==e.far)&&(e.fov=n,e.aspect=r,e.far=s,e.updateProjectionMatrix()),super.updateMatrices(t)}copy(t){return super.copy(t),this.focus=t.focus,this}}Ru.prototype.isSpotLightShadow=!0;class cy extends hn{constructor(t,e,n=0,r=Math.PI/3,s=0,l=1){super(t,e),this.type="SpotLight",this.position.copy(te.DefaultUp),this.updateMatrix(),this.target=new te,this.distance=n,this.angle=r,this.penumbra=s,this.decay=l,this.shadow=new Ru}get power(){return this.intensity*Math.PI}set power(t){this.intensity=t/Math.PI}dispose(){this.shadow.dispose()}copy(t){return super.copy(t),this.distance=t.distance,this.angle=t.angle,this.penumbra=t.penumbra,this.decay=t.decay,this.target=t.target.clone(),this.shadow=t.shadow.clone(),this}}cy.prototype.isSpotLight=!0;const kh=new At,Dr=new D,va=new D;class Du extends Za{constructor(){super(new ke(90,1,.5,500)),this._frameExtents=new st(4,2),this._viewportCount=6,this._viewports=[new re(2,1,1,1),new re(0,1,1,1),new re(3,1,1,1),new re(1,1,1,1),new re(3,0,1,1),new re(1,0,1,1)],this._cubeDirections=[new D(1,0,0),new D(-1,0,0),new D(0,0,1),new D(0,0,-1),new D(0,1,0),new D(0,-1,0)],this._cubeUps=[new D(0,1,0),new D(0,1,0),new D(0,1,0),new D(0,1,0),new D(0,0,1),new D(0,0,-1)]}updateMatrices(t,e=0){const n=this.camera,r=this.matrix,s=t.distance||n.far;s!==n.far&&(n.far=s,n.updateProjectionMatrix()),Dr.setFromMatrixPosition(t.matrixWorld),n.position.copy(Dr),va.copy(n.position),va.add(this._cubeDirections[e]),n.up.copy(this._cubeUps[e]),n.lookAt(va),n.updateMatrixWorld(),r.makeTranslation(-Dr.x,-Dr.y,-Dr.z),kh.multiplyMatrices(n.projectionMatrix,n.matrixWorldInverse),this._frustum.setFromProjectionMatrix(kh)}}Du.prototype.isPointLightShadow=!0;class hy extends hn{constructor(t,e,n=0,r=1){super(t,e),this.type="PointLight",this.distance=n,this.decay=r,this.shadow=new Du}get power(){return this.intensity*4*Math.PI}set power(t){this.intensity=t/(4*Math.PI)}dispose(){this.shadow.dispose()}copy(t){return super.copy(t),this.distance=t.distance,this.decay=t.decay,this.shadow=t.shadow.clone(),this}}hy.prototype.isPointLight=!0;class Iu extends Za{constructor(){super(new Oa(-5,5,5,-5,.5,500))}}Iu.prototype.isDirectionalLightShadow=!0;class uy extends hn{constructor(t,e){super(t,e),this.type="DirectionalLight",this.position.copy(te.DefaultUp),this.updateMatrix(),this.target=new te,this.shadow=new Iu}dispose(){this.shadow.dispose()}copy(t){return super.copy(t),this.target=t.target.clone(),this.shadow=t.shadow.clone(),this}}uy.prototype.isDirectionalLight=!0;class dy extends hn{constructor(t,e){super(t,e),this.type="AmbientLight"}}dy.prototype.isAmbientLight=!0;class py extends hn{constructor(t,e,n=10,r=10){super(t,e),this.type="RectAreaLight",this.width=n,this.height=r}get power(){return this.intensity*this.width*this.height*Math.PI}set power(t){this.intensity=t/(this.width*this.height*Math.PI)}copy(t){return super.copy(t),this.width=t.width,this.height=t.height,this}toJSON(t){const e=super.toJSON(t);return e.object.width=this.width,e.object.height=this.height,e}}py.prototype.isRectAreaLight=!0;class Nu{constructor(){this.coefficients=[];for(let t=0;t<9;t++)this.coefficients.push(new D)}set(t){for(let e=0;e<9;e++)this.coefficients[e].copy(t[e]);return this}zero(){for(let t=0;t<9;t++)this.coefficients[t].set(0,0,0);return this}getAt(t,e){const n=t.x,r=t.y,s=t.z,l=this.coefficients;return e.copy(l[0]).multiplyScalar(.282095),e.addScaledVector(l[1],.488603*r),e.addScaledVector(l[2],.488603*s),e.addScaledVector(l[3],.488603*n),e.addScaledVector(l[4],1.092548*(n*r)),e.addScaledVector(l[5],1.092548*(r*s)),e.addScaledVector(l[6],.315392*(3*s*s-1)),e.addScaledVector(l[7],1.092548*(n*s)),e.addScaledVector(l[8],.546274*(n*n-r*r)),e}getIrradianceAt(t,e){const n=t.x,r=t.y,s=t.z,l=this.coefficients;return e.copy(l[0]).multiplyScalar(.886227),e.addScaledVector(l[1],2*.511664*r),e.addScaledVector(l[2],2*.511664*s),e.addScaledVector(l[3],2*.511664*n),e.addScaledVector(l[4],2*.429043*n*r),e.addScaledVector(l[5],2*.429043*r*s),e.addScaledVector(l[6],.743125*s*s-.247708),e.addScaledVector(l[7],2*.429043*n*s),e.addScaledVector(l[8],.429043*(n*n-r*r)),e}add(t){for(let e=0;e<9;e++)this.coefficients[e].add(t.coefficients[e]);return this}addScaledSH(t,e){for(let n=0;n<9;n++)this.coefficients[n].addScaledVector(t.coefficients[n],e);return this}scale(t){for(let e=0;e<9;e++)this.coefficients[e].multiplyScalar(t);return this}lerp(t,e){for(let n=0;n<9;n++)this.coefficients[n].lerp(t.coefficients[n],e);return this}equals(t){for(let e=0;e<9;e++)if(!this.coefficients[e].equals(t.coefficients[e]))return!1;return!0}copy(t){return this.set(t.coefficients)}clone(){return new this.constructor().copy(this)}fromArray(t,e=0){const n=this.coefficients;for(let r=0;r<9;r++)n[r].fromArray(t,e+r*3);return this}toArray(t=[],e=0){const n=this.coefficients;for(let r=0;r<9;r++)n[r].toArray(t,e+r*3);return t}static getBasisAt(t,e){const n=t.x,r=t.y,s=t.z;e[0]=.282095,e[1]=.488603*r,e[2]=.488603*s,e[3]=.488603*n,e[4]=1.092548*n*r,e[5]=1.092548*r*s,e[6]=.315392*(3*s*s-1),e[7]=1.092548*n*s,e[8]=.546274*(n*n-r*r)}}Nu.prototype.isSphericalHarmonics3=!0;class Ka extends hn{constructor(t=new Nu,e=1){super(void 0,e),this.sh=t}copy(t){return super.copy(t),this.sh.copy(t.sh),this}fromJSON(t){return this.intensity=t.intensity,this.sh.fromArray(t.sh),this}toJSON(t){const e=super.toJSON(t);return e.object.sh=this.sh.toArray(),e}}Ka.prototype.isLightProbe=!0;class fy{static decodeText(t){if(typeof TextDecoder!="undefined")return new TextDecoder().decode(t);let e="";for(let n=0,r=t.length;n<r;n++)e+=String.fromCharCode(t[n]);try{return decodeURIComponent(escape(e))}catch{return e}}static extractUrlBase(t){const e=t.lastIndexOf("/");return e===-1?"./":t.substr(0,e+1)}static resolveURL(t,e){return typeof t!="string"||t===""?"":(/^https?:\/\//i.test(e)&&/^\//.test(t)&&(e=e.replace(/(^https?:\/\/[^\/]+).*/i,"$1")),/^(https?:)?\/\//i.test(t)||/^data:.*,.*$/i.test(t)||/^blob:.*$/i.test(t)?t:e+t)}}class my extends ce{constructor(){super(),this.type="InstancedBufferGeometry",this.instanceCount=1/0}copy(t){return super.copy(t),this.instanceCount=t.instanceCount,this}clone(){return new this.constructor().copy(this)}toJSON(){const t=super.toJSON(this);return t.instanceCount=this.instanceCount,t.isInstancedBufferGeometry=!0,t}}my.prototype.isInstancedBufferGeometry=!0;class gy extends Cn{constructor(t){super(t),typeof createImageBitmap=="undefined"&&console.warn("THREE.ImageBitmapLoader: createImageBitmap() not supported."),typeof fetch=="undefined"&&console.warn("THREE.ImageBitmapLoader: fetch() not supported."),this.options={premultiplyAlpha:"none"}}setOptions(t){return this.options=t,this}load(t,e,n,r){t===void 0&&(t=""),this.path!==void 0&&(t=this.path+t),t=this.manager.resolveURL(t);const s=this,l=Zi.get(t);if(l!==void 0)return s.manager.itemStart(t),setTimeout(function(){e&&e(l),s.manager.itemEnd(t)},0),l;const h={};h.credentials=this.crossOrigin==="anonymous"?"same-origin":"include",h.headers=this.requestHeader,fetch(t,h).then(function(d){return d.blob()}).then(function(d){return createImageBitmap(d,Object.assign(s.options,{colorSpaceConversion:"none"}))}).then(function(d){Zi.add(t,d),e&&e(d),s.manager.itemEnd(t)}).catch(function(d){r&&r(d),s.manager.itemError(t),s.manager.itemEnd(t)}),s.manager.itemStart(t)}}gy.prototype.isImageBitmapLoader=!0;let Os;const vy={getContext:function(){return Os===void 0&&(Os=new(window.AudioContext||window.webkitAudioContext)),Os},setContext:function(o){Os=o}};class _y extends Cn{constructor(t){super(t)}load(t,e,n,r){const s=this,l=new Pu(this.manager);l.setResponseType("arraybuffer"),l.setPath(this.path),l.setRequestHeader(this.requestHeader),l.setWithCredentials(this.withCredentials),l.load(t,function(h){try{const d=h.slice(0);vy.getContext().decodeAudioData(d,function(f){e(f)})}catch(d){r?r(d):console.error(d),s.manager.itemError(t)}},n,r)}}class xy extends Ka{constructor(t,e,n=1){super(void 0,n);const r=new Et().set(t),s=new Et().set(e),l=new D(r.r,r.g,r.b),h=new D(s.r,s.g,s.b),d=Math.sqrt(Math.PI),p=d*Math.sqrt(.75);this.sh.coefficients[0].copy(l).add(h).multiplyScalar(d),this.sh.coefficients[1].copy(l).sub(h).multiplyScalar(p)}}xy.prototype.isHemisphereLightProbe=!0;class by extends Ka{constructor(t,e=1){super(void 0,e);const n=new Et().set(t);this.sh.coefficients[0].set(n.r,n.g,n.b).multiplyScalar(2*Math.sqrt(Math.PI))}}by.prototype.isAmbientLightProbe=!0;class yy extends te{constructor(t){super(),this.type="Audio",this.listener=t,this.context=t.context,this.gain=this.context.createGain(),this.gain.connect(t.getInput()),this.autoplay=!1,this.buffer=null,this.detune=0,this.loop=!1,this.loopStart=0,this.loopEnd=0,this.offset=0,this.duration=void 0,this.playbackRate=1,this.isPlaying=!1,this.hasPlaybackControl=!0,this.source=null,this.sourceType="empty",this._startedAt=0,this._progress=0,this._connected=!1,this.filters=[]}getOutput(){return this.gain}setNodeSource(t){return this.hasPlaybackControl=!1,this.sourceType="audioNode",this.source=t,this.connect(),this}setMediaElementSource(t){return this.hasPlaybackControl=!1,this.sourceType="mediaNode",this.source=this.context.createMediaElementSource(t),this.connect(),this}setMediaStreamSource(t){return this.hasPlaybackControl=!1,this.sourceType="mediaStreamNode",this.source=this.context.createMediaStreamSource(t),this.connect(),this}setBuffer(t){return this.buffer=t,this.sourceType="buffer",this.autoplay&&this.play(),this}play(t=0){if(this.isPlaying===!0){console.warn("THREE.Audio: Audio is already playing.");return}if(this.hasPlaybackControl===!1){console.warn("THREE.Audio: this Audio has no playback control.");return}this._startedAt=this.context.currentTime+t;const e=this.context.createBufferSource();return e.buffer=this.buffer,e.loop=this.loop,e.loopStart=this.loopStart,e.loopEnd=this.loopEnd,e.onended=this.onEnded.bind(this),e.start(this._startedAt,this._progress+this.offset,this.duration),this.isPlaying=!0,this.source=e,this.setDetune(this.detune),this.setPlaybackRate(this.playbackRate),this.connect()}pause(){if(this.hasPlaybackControl===!1){console.warn("THREE.Audio: this Audio has no playback control.");return}return this.isPlaying===!0&&(this._progress+=Math.max(this.context.currentTime-this._startedAt,0)*this.playbackRate,this.loop===!0&&(this._progress=this._progress%(this.duration||this.buffer.duration)),this.source.stop(),this.source.onended=null,this.isPlaying=!1),this}stop(){if(this.hasPlaybackControl===!1){console.warn("THREE.Audio: this Audio has no playback control.");return}return this._progress=0,this.source.stop(),this.source.onended=null,this.isPlaying=!1,this}connect(){if(this.filters.length>0){this.source.connect(this.filters[0]);for(let t=1,e=this.filters.length;t<e;t++)this.filters[t-1].connect(this.filters[t]);this.filters[this.filters.length-1].connect(this.getOutput())}else this.source.connect(this.getOutput());return this._connected=!0,this}disconnect(){if(this.filters.length>0){this.source.disconnect(this.filters[0]);for(let t=1,e=this.filters.length;t<e;t++)this.filters[t-1].disconnect(this.filters[t]);this.filters[this.filters.length-1].disconnect(this.getOutput())}else this.source.disconnect(this.getOutput());return this._connected=!1,this}getFilters(){return this.filters}setFilters(t){return t||(t=[]),this._connected===!0?(this.disconnect(),this.filters=t.slice(),this.connect()):this.filters=t.slice(),this}setDetune(t){if(this.detune=t,this.source.detune!==void 0)return this.isPlaying===!0&&this.source.detune.setTargetAtTime(this.detune,this.context.currentTime,.01),this}getDetune(){return this.detune}getFilter(){return this.getFilters()[0]}setFilter(t){return this.setFilters(t?[t]:[])}setPlaybackRate(t){if(this.hasPlaybackControl===!1){console.warn("THREE.Audio: this Audio has no playback control.");return}return this.playbackRate=t,this.isPlaying===!0&&this.source.playbackRate.setTargetAtTime(this.playbackRate,this.context.currentTime,.01),this}getPlaybackRate(){return this.playbackRate}onEnded(){this.isPlaying=!1}getLoop(){return this.hasPlaybackControl===!1?(console.warn("THREE.Audio: this Audio has no playback control."),!1):this.loop}setLoop(t){if(this.hasPlaybackControl===!1){console.warn("THREE.Audio: this Audio has no playback control.");return}return this.loop=t,this.isPlaying===!0&&(this.source.loop=this.loop),this}setLoopStart(t){return this.loopStart=t,this}setLoopEnd(t){return this.loopEnd=t,this}getVolume(){return this.gain.gain.value}setVolume(t){return this.gain.gain.setTargetAtTime(t,this.context.currentTime,.01),this}}class wy{constructor(t,e,n){this.binding=t,this.valueSize=n;let r,s,l;switch(e){case"quaternion":r=this._slerp,s=this._slerpAdditive,l=this._setAdditiveIdentityQuaternion,this.buffer=new Float64Array(n*6),this._workIndex=5;break;case"string":case"bool":r=this._select,s=this._select,l=this._setAdditiveIdentityOther,this.buffer=new Array(n*5);break;default:r=this._lerp,s=this._lerpAdditive,l=this._setAdditiveIdentityNumeric,this.buffer=new Float64Array(n*5)}this._mixBufferRegion=r,this._mixBufferRegionAdditive=s,this._setIdentity=l,this._origIndex=3,this._addIndex=4,this.cumulativeWeight=0,this.cumulativeWeightAdditive=0,this.useCount=0,this.referenceCount=0}accumulate(t,e){const n=this.buffer,r=this.valueSize,s=t*r+r;let l=this.cumulativeWeight;if(l===0){for(let h=0;h!==r;++h)n[s+h]=n[h];l=e}else{l+=e;const h=e/l;this._mixBufferRegion(n,s,0,h,r)}this.cumulativeWeight=l}accumulateAdditive(t){const e=this.buffer,n=this.valueSize,r=n*this._addIndex;this.cumulativeWeightAdditive===0&&this._setIdentity(),this._mixBufferRegionAdditive(e,r,0,t,n),this.cumulativeWeightAdditive+=t}apply(t){const e=this.valueSize,n=this.buffer,r=t*e+e,s=this.cumulativeWeight,l=this.cumulativeWeightAdditive,h=this.binding;if(this.cumulativeWeight=0,this.cumulativeWeightAdditive=0,s<1){const d=e*this._origIndex;this._mixBufferRegion(n,r,d,1-s,e)}l>0&&this._mixBufferRegionAdditive(n,r,this._addIndex*e,1,e);for(let d=e,p=e+e;d!==p;++d)if(n[d]!==n[d+e]){h.setValue(n,r);break}}saveOriginalState(){const t=this.binding,e=this.buffer,n=this.valueSize,r=n*this._origIndex;t.getValue(e,r);for(let s=n,l=r;s!==l;++s)e[s]=e[r+s%n];this._setIdentity(),this.cumulativeWeight=0,this.cumulativeWeightAdditive=0}restoreOriginalState(){const t=this.valueSize*3;this.binding.setValue(this.buffer,t)}_setAdditiveIdentityNumeric(){const t=this._addIndex*this.valueSize,e=t+this.valueSize;for(let n=t;n<e;n++)this.buffer[n]=0}_setAdditiveIdentityQuaternion(){this._setAdditiveIdentityNumeric(),this.buffer[this._addIndex*this.valueSize+3]=1}_setAdditiveIdentityOther(){const t=this._origIndex*this.valueSize,e=this._addIndex*this.valueSize;for(let n=0;n<this.valueSize;n++)this.buffer[e+n]=this.buffer[t+n]}_select(t,e,n,r,s){if(r>=.5)for(let l=0;l!==s;++l)t[e+l]=t[n+l]}_slerp(t,e,n,r){Be.slerpFlat(t,e,t,e,t,n,r)}_slerpAdditive(t,e,n,r,s){const l=this._workIndex*s;Be.multiplyQuaternionsFlat(t,l,t,e,t,n),Be.slerpFlat(t,e,t,e,t,l,r)}_lerp(t,e,n,r,s){const l=1-r;for(let h=0;h!==s;++h){const d=e+h;t[d]=t[d]*l+t[n+h]*r}}_lerpAdditive(t,e,n,r,s){for(let l=0;l!==s;++l){const h=e+l;t[h]=t[h]+t[n+l]*r}}}const Qa="\\[\\]\\.:\\/",My=new RegExp("["+Qa+"]","g"),tl="[^"+Qa+"]",Sy="[^"+Qa.replace("\\.","")+"]",Ey=/((?:WC+[\/:])*)/.source.replace("WC",tl),Ty=/(WCOD+)?/.source.replace("WCOD",Sy),Cy=/(?:\.(WC+)(?:\[(.+)\])?)?/.source.replace("WC",tl),Ay=/\.(WC+)(?:\[(.+)\])?/.source.replace("WC",tl),Py=new RegExp("^"+Ey+Ty+Cy+Ay+"$"),Ly=["material","materials","bones"];class Ry{constructor(t,e,n){const r=n||Qt.parseTrackName(e);this._targetGroup=t,this._bindings=t.subscribe_(e,r)}getValue(t,e){this.bind();const n=this._targetGroup.nCachedObjects_,r=this._bindings[n];r!==void 0&&r.getValue(t,e)}setValue(t,e){const n=this._bindings;for(let r=this._targetGroup.nCachedObjects_,s=n.length;r!==s;++r)n[r].setValue(t,e)}bind(){const t=this._bindings;for(let e=this._targetGroup.nCachedObjects_,n=t.length;e!==n;++e)t[e].bind()}unbind(){const t=this._bindings;for(let e=this._targetGroup.nCachedObjects_,n=t.length;e!==n;++e)t[e].unbind()}}class Qt{constructor(t,e,n){this.path=e,this.parsedPath=n||Qt.parseTrackName(e),this.node=Qt.findNode(t,this.parsedPath.nodeName)||t,this.rootNode=t,this.getValue=this._getValue_unbound,this.setValue=this._setValue_unbound}static create(t,e,n){return t&&t.isAnimationObjectGroup?new Qt.Composite(t,e,n):new Qt(t,e,n)}static sanitizeNodeName(t){return t.replace(/\s/g,"_").replace(My,"")}static parseTrackName(t){const e=Py.exec(t);if(!e)throw new Error("PropertyBinding: Cannot parse trackName: "+t);const n={nodeName:e[2],objectName:e[3],objectIndex:e[4],propertyName:e[5],propertyIndex:e[6]},r=n.nodeName&&n.nodeName.lastIndexOf(".");if(r!==void 0&&r!==-1){const s=n.nodeName.substring(r+1);Ly.indexOf(s)!==-1&&(n.nodeName=n.nodeName.substring(0,r),n.objectName=s)}if(n.propertyName===null||n.propertyName.length===0)throw new Error("PropertyBinding: can not parse propertyName from trackName: "+t);return n}static findNode(t,e){if(!e||e===""||e==="."||e===-1||e===t.name||e===t.uuid)return t;if(t.skeleton){const n=t.skeleton.getBoneByName(e);if(n!==void 0)return n}if(t.children){const n=function(s){for(let l=0;l<s.length;l++){const h=s[l];if(h.name===e||h.uuid===e)return h;const d=n(h.children);if(d)return d}return null},r=n(t.children);if(r)return r}return null}_getValue_unavailable(){}_setValue_unavailable(){}_getValue_direct(t,e){t[e]=this.targetObject[this.propertyName]}_getValue_array(t,e){const n=this.resolvedProperty;for(let r=0,s=n.length;r!==s;++r)t[e++]=n[r]}_getValue_arrayElement(t,e){t[e]=this.resolvedProperty[this.propertyIndex]}_getValue_toArray(t,e){this.resolvedProperty.toArray(t,e)}_setValue_direct(t,e){this.targetObject[this.propertyName]=t[e]}_setValue_direct_setNeedsUpdate(t,e){this.targetObject[this.propertyName]=t[e],this.targetObject.needsUpdate=!0}_setValue_direct_setMatrixWorldNeedsUpdate(t,e){this.targetObject[this.propertyName]=t[e],this.targetObject.matrixWorldNeedsUpdate=!0}_setValue_array(t,e){const n=this.resolvedProperty;for(let r=0,s=n.length;r!==s;++r)n[r]=t[e++]}_setValue_array_setNeedsUpdate(t,e){const n=this.resolvedProperty;for(let r=0,s=n.length;r!==s;++r)n[r]=t[e++];this.targetObject.needsUpdate=!0}_setValue_array_setMatrixWorldNeedsUpdate(t,e){const n=this.resolvedProperty;for(let r=0,s=n.length;r!==s;++r)n[r]=t[e++];this.targetObject.matrixWorldNeedsUpdate=!0}_setValue_arrayElement(t,e){this.resolvedProperty[this.propertyIndex]=t[e]}_setValue_arrayElement_setNeedsUpdate(t,e){this.resolvedProperty[this.propertyIndex]=t[e],this.targetObject.needsUpdate=!0}_setValue_arrayElement_setMatrixWorldNeedsUpdate(t,e){this.resolvedProperty[this.propertyIndex]=t[e],this.targetObject.matrixWorldNeedsUpdate=!0}_setValue_fromArray(t,e){this.resolvedProperty.fromArray(t,e)}_setValue_fromArray_setNeedsUpdate(t,e){this.resolvedProperty.fromArray(t,e),this.targetObject.needsUpdate=!0}_setValue_fromArray_setMatrixWorldNeedsUpdate(t,e){this.resolvedProperty.fromArray(t,e),this.targetObject.matrixWorldNeedsUpdate=!0}_getValue_unbound(t,e){this.bind(),this.getValue(t,e)}_setValue_unbound(t,e){this.bind(),this.setValue(t,e)}bind(){let t=this.node;const e=this.parsedPath,n=e.objectName,r=e.propertyName;let s=e.propertyIndex;if(t||(t=Qt.findNode(this.rootNode,e.nodeName)||this.rootNode,this.node=t),this.getValue=this._getValue_unavailable,this.setValue=this._setValue_unavailable,!t){console.error("THREE.PropertyBinding: Trying to update node for track: "+this.path+" but it wasn't found.");return}if(n){let p=e.objectIndex;switch(n){case"materials":if(!t.material){console.error("THREE.PropertyBinding: Can not bind to material as node does not have a material.",this);return}if(!t.material.materials){console.error("THREE.PropertyBinding: Can not bind to material.materials as node.material does not have a materials array.",this);return}t=t.material.materials;break;case"bones":if(!t.skeleton){console.error("THREE.PropertyBinding: Can not bind to bones as node does not have a skeleton.",this);return}t=t.skeleton.bones;for(let f=0;f<t.length;f++)if(t[f].name===p){p=f;break}break;default:if(t[n]===void 0){console.error("THREE.PropertyBinding: Can not bind to objectName of node undefined.",this);return}t=t[n]}if(p!==void 0){if(t[p]===void 0){console.error("THREE.PropertyBinding: Trying to bind to objectIndex of objectName, but is undefined.",this,t);return}t=t[p]}}const l=t[r];if(l===void 0){const p=e.nodeName;console.error("THREE.PropertyBinding: Trying to update property for track: "+p+"."+r+" but it wasn't found.",t);return}let h=this.Versioning.None;this.targetObject=t,t.needsUpdate!==void 0?h=this.Versioning.NeedsUpdate:t.matrixWorldNeedsUpdate!==void 0&&(h=this.Versioning.MatrixWorldNeedsUpdate);let d=this.BindingType.Direct;if(s!==void 0){if(r==="morphTargetInfluences"){if(!t.geometry){console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.",this);return}if(t.geometry.isBufferGeometry){if(!t.geometry.morphAttributes){console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.morphAttributes.",this);return}t.morphTargetDictionary[s]!==void 0&&(s=t.morphTargetDictionary[s])}else{console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences on THREE.Geometry. Use THREE.BufferGeometry instead.",this);return}}d=this.BindingType.ArrayElement,this.resolvedProperty=l,this.propertyIndex=s}else l.fromArray!==void 0&&l.toArray!==void 0?(d=this.BindingType.HasFromToArray,this.resolvedProperty=l):Array.isArray(l)?(d=this.BindingType.EntireArray,this.resolvedProperty=l):this.propertyName=r;this.getValue=this.GetterByBindingType[d],this.setValue=this.SetterByBindingTypeAndVersioning[d][h]}unbind(){this.node=null,this.getValue=this._getValue_unbound,this.setValue=this._setValue_unbound}}Qt.Composite=Ry;Qt.prototype.BindingType={Direct:0,EntireArray:1,ArrayElement:2,HasFromToArray:3};Qt.prototype.Versioning={None:0,NeedsUpdate:1,MatrixWorldNeedsUpdate:2};Qt.prototype.GetterByBindingType=[Qt.prototype._getValue_direct,Qt.prototype._getValue_array,Qt.prototype._getValue_arrayElement,Qt.prototype._getValue_toArray];Qt.prototype.SetterByBindingTypeAndVersioning=[[Qt.prototype._setValue_direct,Qt.prototype._setValue_direct_setNeedsUpdate,Qt.prototype._setValue_direct_setMatrixWorldNeedsUpdate],[Qt.prototype._setValue_array,Qt.prototype._setValue_array_setNeedsUpdate,Qt.prototype._setValue_array_setMatrixWorldNeedsUpdate],[Qt.prototype._setValue_arrayElement,Qt.prototype._setValue_arrayElement_setNeedsUpdate,Qt.prototype._setValue_arrayElement_setMatrixWorldNeedsUpdate],[Qt.prototype._setValue_fromArray,Qt.prototype._setValue_fromArray_setNeedsUpdate,Qt.prototype._setValue_fromArray_setMatrixWorldNeedsUpdate]];class Dy{constructor(t,e,n=null,r=e.blendMode){this._mixer=t,this._clip=e,this._localRoot=n,this.blendMode=r;const s=e.tracks,l=s.length,h=new Array(l),d={endingStart:Gi,endingEnd:Gi};for(let p=0;p!==l;++p){const f=s[p].createInterpolant(null);h[p]=f,f.settings=d}this._interpolantSettings=d,this._interpolants=h,this._propertyBindings=new Array(l),this._cacheIndex=null,this._byClipCacheIndex=null,this._timeScaleInterpolant=null,this._weightInterpolant=null,this.loop=pg,this._loopCount=-1,this._startTime=null,this.time=0,this.timeScale=1,this._effectiveTimeScale=1,this.weight=1,this._effectiveWeight=1,this.repetitions=1/0,this.paused=!1,this.enabled=!0,this.clampWhenFinished=!1,this.zeroSlopeAtStart=!0,this.zeroSlopeAtEnd=!0}play(){return this._mixer._activateAction(this),this}stop(){return this._mixer._deactivateAction(this),this.reset()}reset(){return this.paused=!1,this.enabled=!0,this.time=0,this._loopCount=-1,this._startTime=null,this.stopFading().stopWarping()}isRunning(){return this.enabled&&!this.paused&&this.timeScale!==0&&this._startTime===null&&this._mixer._isActiveAction(this)}isScheduled(){return this._mixer._isActiveAction(this)}startAt(t){return this._startTime=t,this}setLoop(t,e){return this.loop=t,this.repetitions=e,this}setEffectiveWeight(t){return this.weight=t,this._effectiveWeight=this.enabled?t:0,this.stopFading()}getEffectiveWeight(){return this._effectiveWeight}fadeIn(t){return this._scheduleFading(t,0,1)}fadeOut(t){return this._scheduleFading(t,1,0)}crossFadeFrom(t,e,n){if(t.fadeOut(e),this.fadeIn(e),n){const r=this._clip.duration,s=t._clip.duration,l=s/r,h=r/s;t.warp(1,l,e),this.warp(h,1,e)}return this}crossFadeTo(t,e,n){return t.crossFadeFrom(this,e,n)}stopFading(){const t=this._weightInterpolant;return t!==null&&(this._weightInterpolant=null,this._mixer._takeBackControlInterpolant(t)),this}setEffectiveTimeScale(t){return this.timeScale=t,this._effectiveTimeScale=this.paused?0:t,this.stopWarping()}getEffectiveTimeScale(){return this._effectiveTimeScale}setDuration(t){return this.timeScale=this._clip.duration/t,this.stopWarping()}syncWith(t){return this.time=t.time,this.timeScale=t.timeScale,this.stopWarping()}halt(t){return this.warp(this._effectiveTimeScale,0,t)}warp(t,e,n){const r=this._mixer,s=r.time,l=this.timeScale;let h=this._timeScaleInterpolant;h===null&&(h=r._lendControlInterpolant(),this._timeScaleInterpolant=h);const d=h.parameterPositions,p=h.sampleValues;return d[0]=s,d[1]=s+n,p[0]=t/l,p[1]=e/l,this}stopWarping(){const t=this._timeScaleInterpolant;return t!==null&&(this._timeScaleInterpolant=null,this._mixer._takeBackControlInterpolant(t)),this}getMixer(){return this._mixer}getClip(){return this._clip}getRoot(){return this._localRoot||this._mixer._root}_update(t,e,n,r){if(!this.enabled){this._updateWeight(t);return}const s=this._startTime;if(s!==null){const d=(t-s)*n;if(d<0||n===0)return;this._startTime=null,e=n*d}e*=this._updateTimeScale(t);const l=this._updateTime(e),h=this._updateWeight(t);if(h>0){const d=this._interpolants,p=this._propertyBindings;switch(this.blendMode){case Wh:for(let f=0,m=d.length;f!==m;++f)d[f].evaluate(l),p[f].accumulateAdditive(h);break;case Na:default:for(let f=0,m=d.length;f!==m;++f)d[f].evaluate(l),p[f].accumulate(r,h)}}}_updateWeight(t){let e=0;if(this.enabled){e=this.weight;const n=this._weightInterpolant;if(n!==null){const r=n.evaluate(t)[0];e*=r,t>n.parameterPositions[1]&&(this.stopFading(),r===0&&(this.enabled=!1))}}return this._effectiveWeight=e,e}_updateTimeScale(t){let e=0;if(!this.paused){e=this.timeScale;const n=this._timeScaleInterpolant;n!==null&&(e*=n.evaluate(t)[0],t>n.parameterPositions[1]&&(this.stopWarping(),e===0?this.paused=!0:this.timeScale=e))}return this._effectiveTimeScale=e,e}_updateTime(t){const e=this._clip.duration,n=this.loop;let r=this.time+t,s=this._loopCount;const l=n===fg;if(t===0)return s===-1?r:l&&(s&1)===1?e-r:r;if(n===dg){s===-1&&(this._loopCount=0,this._setEndings(!0,!0,!1));t:{if(r>=e)r=e;else if(r<0)r=0;else{this.time=r;break t}this.clampWhenFinished?this.paused=!0:this.enabled=!1,this.time=r,this._mixer.dispatchEvent({type:"finished",action:this,direction:t<0?-1:1})}}else{if(s===-1&&(t>=0?(s=0,this._setEndings(!0,this.repetitions===0,l)):this._setEndings(this.repetitions===0,!0,l)),r>=e||r<0){const h=Math.floor(r/e);r-=e*h,s+=Math.abs(h);const d=this.repetitions-s;if(d<=0)this.clampWhenFinished?this.paused=!0:this.enabled=!1,r=t>0?e:0,this.time=r,this._mixer.dispatchEvent({type:"finished",action:this,direction:t>0?1:-1});else{if(d===1){const p=t<0;this._setEndings(p,!p,l)}else this._setEndings(!1,!1,l);this._loopCount=s,this.time=r,this._mixer.dispatchEvent({type:"loop",action:this,loopDelta:h})}}else this.time=r;if(l&&(s&1)===1)return e-r}return r}_setEndings(t,e,n){const r=this._interpolantSettings;n?(r.endingStart=Wi,r.endingEnd=Wi):(t?r.endingStart=this.zeroSlopeAtStart?Wi:Gi:r.endingStart=qs,e?r.endingEnd=this.zeroSlopeAtEnd?Wi:Gi:r.endingEnd=qs)}_scheduleFading(t,e,n){const r=this._mixer,s=r.time;let l=this._weightInterpolant;l===null&&(l=r._lendControlInterpolant(),this._weightInterpolant=l);const h=l.parameterPositions,d=l.sampleValues;return h[0]=s,d[0]=e,h[1]=s+t,d[1]=n,this}}class Iy extends pi{constructor(t){super(),this._root=t,this._initMemoryManager(),this._accuIndex=0,this.time=0,this.timeScale=1}_bindAction(t,e){const n=t._localRoot||this._root,r=t._clip.tracks,s=r.length,l=t._propertyBindings,h=t._interpolants,d=n.uuid,p=this._bindingsByRootAndName;let f=p[d];f===void 0&&(f={},p[d]=f);for(let m=0;m!==s;++m){const g=r[m],_=g.name;let y=f[_];if(y!==void 0)l[m]=y;else{if(y=l[m],y!==void 0){y._cacheIndex===null&&(++y.referenceCount,this._addInactiveBinding(y,d,_));continue}const w=e&&e._propertyBindings[m].binding.parsedPath;y=new wy(Qt.create(n,_,w),g.ValueTypeName,g.getValueSize()),++y.referenceCount,this._addInactiveBinding(y,d,_),l[m]=y}h[m].resultBuffer=y.buffer}}_activateAction(t){if(!this._isActiveAction(t)){if(t._cacheIndex===null){const n=(t._localRoot||this._root).uuid,r=t._clip.uuid,s=this._actionsByClip[r];this._bindAction(t,s&&s.knownActions[0]),this._addInactiveAction(t,r,n)}const e=t._propertyBindings;for(let n=0,r=e.length;n!==r;++n){const s=e[n];s.useCount++===0&&(this._lendBinding(s),s.saveOriginalState())}this._lendAction(t)}}_deactivateAction(t){if(this._isActiveAction(t)){const e=t._propertyBindings;for(let n=0,r=e.length;n!==r;++n){const s=e[n];--s.useCount===0&&(s.restoreOriginalState(),this._takeBackBinding(s))}this._takeBackAction(t)}}_initMemoryManager(){this._actions=[],this._nActiveActions=0,this._actionsByClip={},this._bindings=[],this._nActiveBindings=0,this._bindingsByRootAndName={},this._controlInterpolants=[],this._nActiveControlInterpolants=0;const t=this;this.stats={actions:{get total(){return t._actions.length},get inUse(){return t._nActiveActions}},bindings:{get total(){return t._bindings.length},get inUse(){return t._nActiveBindings}},controlInterpolants:{get total(){return t._controlInterpolants.length},get inUse(){return t._nActiveControlInterpolants}}}}_isActiveAction(t){const e=t._cacheIndex;return e!==null&&e<this._nActiveActions}_addInactiveAction(t,e,n){const r=this._actions,s=this._actionsByClip;let l=s[e];if(l===void 0)l={knownActions:[t],actionByRoot:{}},t._byClipCacheIndex=0,s[e]=l;else{const h=l.knownActions;t._byClipCacheIndex=h.length,h.push(t)}t._cacheIndex=r.length,r.push(t),l.actionByRoot[n]=t}_removeInactiveAction(t){const e=this._actions,n=e[e.length-1],r=t._cacheIndex;n._cacheIndex=r,e[r]=n,e.pop(),t._cacheIndex=null;const s=t._clip.uuid,l=this._actionsByClip,h=l[s],d=h.knownActions,p=d[d.length-1],f=t._byClipCacheIndex;p._byClipCacheIndex=f,d[f]=p,d.pop(),t._byClipCacheIndex=null;const m=h.actionByRoot,g=(t._localRoot||this._root).uuid;delete m[g],d.length===0&&delete l[s],this._removeInactiveBindingsForAction(t)}_removeInactiveBindingsForAction(t){const e=t._propertyBindings;for(let n=0,r=e.length;n!==r;++n){const s=e[n];--s.referenceCount===0&&this._removeInactiveBinding(s)}}_lendAction(t){const e=this._actions,n=t._cacheIndex,r=this._nActiveActions++,s=e[r];t._cacheIndex=r,e[r]=t,s._cacheIndex=n,e[n]=s}_takeBackAction(t){const e=this._actions,n=t._cacheIndex,r=--this._nActiveActions,s=e[r];t._cacheIndex=r,e[r]=t,s._cacheIndex=n,e[n]=s}_addInactiveBinding(t,e,n){const r=this._bindingsByRootAndName,s=this._bindings;let l=r[e];l===void 0&&(l={},r[e]=l),l[n]=t,t._cacheIndex=s.length,s.push(t)}_removeInactiveBinding(t){const e=this._bindings,n=t.binding,r=n.rootNode.uuid,s=n.path,l=this._bindingsByRootAndName,h=l[r],d=e[e.length-1],p=t._cacheIndex;d._cacheIndex=p,e[p]=d,e.pop(),delete h[s],Object.keys(h).length===0&&delete l[r]}_lendBinding(t){const e=this._bindings,n=t._cacheIndex,r=this._nActiveBindings++,s=e[r];t._cacheIndex=r,e[r]=t,s._cacheIndex=n,e[n]=s}_takeBackBinding(t){const e=this._bindings,n=t._cacheIndex,r=--this._nActiveBindings,s=e[r];t._cacheIndex=r,e[r]=t,s._cacheIndex=n,e[n]=s}_lendControlInterpolant(){const t=this._controlInterpolants,e=this._nActiveControlInterpolants++;let n=t[e];return n===void 0&&(n=new Cu(new Float32Array(2),new Float32Array(2),1,this._controlInterpolantsResultBuffer),n.__cacheIndex=e,t[e]=n),n}_takeBackControlInterpolant(t){const e=this._controlInterpolants,n=t.__cacheIndex,r=--this._nActiveControlInterpolants,s=e[r];t.__cacheIndex=r,e[r]=t,s.__cacheIndex=n,e[n]=s}clipAction(t,e,n){const r=e||this._root,s=r.uuid;let l=typeof t=="string"?Dh.findByName(r,t):t;const h=l!==null?l.uuid:t,d=this._actionsByClip[h];let p=null;if(n===void 0&&(l!==null?n=l.blendMode:n=Na),d!==void 0){const m=d.actionByRoot[s];if(m!==void 0&&m.blendMode===n)return m;p=d.knownActions[0],l===null&&(l=p._clip)}if(l===null)return null;const f=new Dy(this,l,e,n);return this._bindAction(f,p),this._addInactiveAction(f,h,s),f}existingAction(t,e){const n=e||this._root,r=n.uuid,s=typeof t=="string"?Dh.findByName(n,t):t,l=s?s.uuid:t,h=this._actionsByClip[l];return h!==void 0&&h.actionByRoot[r]||null}stopAllAction(){const t=this._actions,e=this._nActiveActions;for(let n=e-1;n>=0;--n)t[n].stop();return this}update(t){t*=this.timeScale;const e=this._actions,n=this._nActiveActions,r=this.time+=t,s=Math.sign(t),l=this._accuIndex^=1;for(let p=0;p!==n;++p)e[p]._update(r,t,s,l);const h=this._bindings,d=this._nActiveBindings;for(let p=0;p!==d;++p)h[p].apply(l);return this}setTime(t){this.time=0;for(let e=0;e<this._actions.length;e++)this._actions[e].time=0;return this.update(t)}getRoot(){return this._root}uncacheClip(t){const e=this._actions,n=t.uuid,r=this._actionsByClip,s=r[n];if(s!==void 0){const l=s.knownActions;for(let h=0,d=l.length;h!==d;++h){const p=l[h];this._deactivateAction(p);const f=p._cacheIndex,m=e[e.length-1];p._cacheIndex=null,p._byClipCacheIndex=null,m._cacheIndex=f,e[f]=m,e.pop(),this._removeInactiveBindingsForAction(p)}delete r[n]}}uncacheRoot(t){const e=t.uuid,n=this._actionsByClip;for(const l in n){const h=n[l].actionByRoot,d=h[e];d!==void 0&&(this._deactivateAction(d),this._removeInactiveAction(d))}const r=this._bindingsByRootAndName,s=r[e];if(s!==void 0)for(const l in s){const h=s[l];h.restoreOriginalState(),this._removeInactiveBinding(h)}}uncacheAction(t,e){const n=this.existingAction(t,e);n!==null&&(this._deactivateAction(n),this._removeInactiveAction(n))}}Iy.prototype._controlInterpolantsResultBuffer=new Float32Array(1);class Ny extends Yr{constructor(t,e,n=1){super(t,e),this.meshPerAttribute=n}copy(t){return super.copy(t),this.meshPerAttribute=t.meshPerAttribute,this}clone(t){const e=super.clone(t);return e.meshPerAttribute=this.meshPerAttribute,e}toJSON(t){const e=super.toJSON(t);return e.isInstancedInterleavedBuffer=!0,e.meshPerAttribute=this.meshPerAttribute,e}}Ny.prototype.isInstancedInterleavedBuffer=!0;const Hn=new D,Us=new At,_a=new At;class Fy extends qa{constructor(t){const e=Fu(t),n=new ce,r=[],s=[],l=new Et(0,0,1),h=new Et(0,1,0);for(let p=0;p<e.length;p++){const f=e[p];f.parent&&f.parent.isBone&&(r.push(0,0,0),r.push(0,0,0),s.push(l.r,l.g,l.b),s.push(h.r,h.g,h.b))}n.setAttribute("position",new ye(r,3)),n.setAttribute("color",new ye(s,3));const d=new Jr({vertexColors:!0,depthTest:!1,depthWrite:!1,toneMapped:!1,transparent:!0});super(n,d),this.type="SkeletonHelper",this.isSkeletonHelper=!0,this.root=t,this.bones=e,this.matrix=t.matrixWorld,this.matrixAutoUpdate=!1}updateMatrixWorld(t){const e=this.bones,n=this.geometry,r=n.getAttribute("position");_a.copy(this.root.matrixWorld).invert();for(let s=0,l=0;s<e.length;s++){const h=e[s];h.parent&&h.parent.isBone&&(Us.multiplyMatrices(_a,h.matrixWorld),Hn.setFromMatrixPosition(Us),r.setXYZ(l,Hn.x,Hn.y,Hn.z),Us.multiplyMatrices(_a,h.parent.matrixWorld),Hn.setFromMatrixPosition(Us),r.setXYZ(l+1,Hn.x,Hn.y,Hn.z),l+=2)}n.getAttribute("position").needsUpdate=!0,super.updateMatrixWorld(t)}}function Fu(o){const t=[];o&&o.isBone&&t.push(o);for(let e=0;e<o.children.length;e++)t.push.apply(t,Fu(o.children[e]));return t}class ky extends qa{constructor(t=10,e=10,n=4473924,r=8947848){n=new Et(n),r=new Et(r);const s=e/2,l=t/e,h=t/2,d=[],p=[];for(let g=0,_=0,y=-h;g<=e;g++,y+=l){d.push(-h,0,y,h,0,y),d.push(y,0,-h,y,0,h);const w=g===s?n:r;w.toArray(p,_),_+=3,w.toArray(p,_),_+=3,w.toArray(p,_),_+=3,w.toArray(p,_),_+=3}const f=new ce;f.setAttribute("position",new ye(d,3)),f.setAttribute("color",new ye(p,3));const m=new Jr({vertexColors:!0,toneMapped:!1});super(f,m),this.type="GridHelper"}}class Vy{constructor(){this.type="ShapePath",this.color=new Et,this.subPaths=[],this.currentPath=null}moveTo(t,e){return this.currentPath=new $s,this.subPaths.push(this.currentPath),this.currentPath.moveTo(t,e),this}lineTo(t,e){return this.currentPath.lineTo(t,e),this}quadraticCurveTo(t,e,n,r){return this.currentPath.quadraticCurveTo(t,e,n,r),this}bezierCurveTo(t,e,n,r,s,l){return this.currentPath.bezierCurveTo(t,e,n,r,s,l),this}splineThru(t){return this.currentPath.splineThru(t),this}toShapes(t,e){function n(v){const N=[];for(let M=0,R=v.length;M<R;M++){const F=v[M],k=new $n;k.curves=F.curves,N.push(k)}return N}function r(v,N){const M=N.length;let R=!1;for(let F=M-1,k=0;k<M;F=k++){let j=N[F],ot=N[k],Y=ot.x-j.x,V=ot.y-j.y;if(Math.abs(V)>Number.EPSILON){if(V<0&&(j=N[k],Y=-Y,ot=N[F],V=-V),v.y<j.y||v.y>ot.y)continue;if(v.y===j.y){if(v.x===j.x)return!0}else{const C=V*(v.x-j.x)-Y*(v.y-j.y);if(C===0)return!0;if(C<0)continue;R=!R}}else{if(v.y!==j.y)continue;if(ot.x<=v.x&&v.x<=j.x||j.x<=v.x&&v.x<=ot.x)return!0}}return R}const s=Tn.isClockWise,l=this.subPaths;if(l.length===0)return[];if(e===!0)return n(l);let h,d,p;const f=[];if(l.length===1)return d=l[0],p=new $n,p.curves=d.curves,f.push(p),f;let m=!s(l[0].getPoints());m=t?!m:m;const g=[],_=[];let y=[],w=0,S;_[w]=void 0,y[w]=[];for(let v=0,N=l.length;v<N;v++)d=l[v],S=d.getPoints(),h=s(S),h=t?!h:h,h?(!m&&_[w]&&w++,_[w]={s:new $n,p:S},_[w].s.curves=d.curves,m&&w++,y[w]=[]):y[w].push({h:d,p:S[0]});if(!_[0])return n(l);if(_.length>1){let v=!1;const N=[];for(let M=0,R=_.length;M<R;M++)g[M]=[];for(let M=0,R=_.length;M<R;M++){const F=y[M];for(let k=0;k<F.length;k++){const j=F[k];let ot=!0;for(let Y=0;Y<_.length;Y++)r(j.p,_[Y].p)&&(M!==Y&&N.push({froms:M,tos:Y,hole:k}),ot?(ot=!1,g[Y].push(j)):v=!0);ot&&g[M].push(j)}}N.length>0&&(v||(y=g))}let x;for(let v=0,N=_.length;v<N;v++){p=_[v].s,f.push(p),x=y[v];for(let M=0,R=x.length;M<R;M++)p.holes.push(x[M].h)}return f}}const By=new Float32Array(1);new Int32Array(By.buffer);Je.create=function(o,t){return console.log("THREE.Curve.create() has been deprecated"),o.prototype=Object.create(Je.prototype),o.prototype.constructor=o,o.prototype.getPoint=t,o};$s.prototype.fromPoints=function(o){return console.warn("THREE.Path: .fromPoints() has been renamed to .setFromPoints()."),this.setFromPoints(o)};ky.prototype.setColors=function(){console.error("THREE.GridHelper: setColors() has been deprecated, pass them in the constructor instead.")};Fy.prototype.update=function(){console.error("THREE.SkeletonHelper: update() no longer needs to be called.")};Cn.prototype.extractUrlBase=function(o){return console.warn("THREE.Loader: .extractUrlBase() has been deprecated. Use THREE.LoaderUtils.extractUrlBase() instead."),fy.extractUrlBase(o)};Cn.Handlers={add:function(){console.error("THREE.Loader: Handlers.add() has been removed. Use LoadingManager.addHandler() instead.")},get:function(){console.error("THREE.Loader: Handlers.get() has been removed. Use LoadingManager.getHandler() instead.")}};nn.prototype.center=function(o){return console.warn("THREE.Box3: .center() has been renamed to .getCenter()."),this.getCenter(o)};nn.prototype.empty=function(){return console.warn("THREE.Box3: .empty() has been renamed to .isEmpty()."),this.isEmpty()};nn.prototype.isIntersectionBox=function(o){return console.warn("THREE.Box3: .isIntersectionBox() has been renamed to .intersectsBox()."),this.intersectsBox(o)};nn.prototype.isIntersectionSphere=function(o){return console.warn("THREE.Box3: .isIntersectionSphere() has been renamed to .intersectsSphere()."),this.intersectsSphere(o)};nn.prototype.size=function(o){return console.warn("THREE.Box3: .size() has been renamed to .getSize()."),this.getSize(o)};er.prototype.empty=function(){return console.warn("THREE.Sphere: .empty() has been renamed to .isEmpty()."),this.isEmpty()};no.prototype.setFromMatrix=function(o){return console.warn("THREE.Frustum: .setFromMatrix() has been renamed to .setFromProjectionMatrix()."),this.setFromProjectionMatrix(o)};Te.prototype.flattenToArrayOffset=function(o,t){return console.warn("THREE.Matrix3: .flattenToArrayOffset() has been deprecated. Use .toArray() instead."),this.toArray(o,t)};Te.prototype.multiplyVector3=function(o){return console.warn("THREE.Matrix3: .multiplyVector3() has been removed. Use vector.applyMatrix3( matrix ) instead."),o.applyMatrix3(this)};Te.prototype.multiplyVector3Array=function(){console.error("THREE.Matrix3: .multiplyVector3Array() has been removed.")};Te.prototype.applyToBufferAttribute=function(o){return console.warn("THREE.Matrix3: .applyToBufferAttribute() has been removed. Use attribute.applyMatrix3( matrix ) instead."),o.applyMatrix3(this)};Te.prototype.applyToVector3Array=function(){console.error("THREE.Matrix3: .applyToVector3Array() has been removed.")};Te.prototype.getInverse=function(o){return console.warn("THREE.Matrix3: .getInverse() has been removed. Use matrixInv.copy( matrix ).invert(); instead."),this.copy(o).invert()};At.prototype.extractPosition=function(o){return console.warn("THREE.Matrix4: .extractPosition() has been renamed to .copyPosition()."),this.copyPosition(o)};At.prototype.flattenToArrayOffset=function(o,t){return console.warn("THREE.Matrix4: .flattenToArrayOffset() has been deprecated. Use .toArray() instead."),this.toArray(o,t)};At.prototype.getPosition=function(){return console.warn("THREE.Matrix4: .getPosition() has been removed. Use Vector3.setFromMatrixPosition( matrix ) instead."),new D().setFromMatrixColumn(this,3)};At.prototype.setRotationFromQuaternion=function(o){return console.warn("THREE.Matrix4: .setRotationFromQuaternion() has been renamed to .makeRotationFromQuaternion()."),this.makeRotationFromQuaternion(o)};At.prototype.multiplyToArray=function(){console.warn("THREE.Matrix4: .multiplyToArray() has been removed.")};At.prototype.multiplyVector3=function(o){return console.warn("THREE.Matrix4: .multiplyVector3() has been removed. Use vector.applyMatrix4( matrix ) instead."),o.applyMatrix4(this)};At.prototype.multiplyVector4=function(o){return console.warn("THREE.Matrix4: .multiplyVector4() has been removed. Use vector.applyMatrix4( matrix ) instead."),o.applyMatrix4(this)};At.prototype.multiplyVector3Array=function(){console.error("THREE.Matrix4: .multiplyVector3Array() has been removed.")};At.prototype.rotateAxis=function(o){console.warn("THREE.Matrix4: .rotateAxis() has been removed. Use Vector3.transformDirection( matrix ) instead."),o.transformDirection(this)};At.prototype.crossVector=function(o){return console.warn("THREE.Matrix4: .crossVector() has been removed. Use vector.applyMatrix4( matrix ) instead."),o.applyMatrix4(this)};At.prototype.translate=function(){console.error("THREE.Matrix4: .translate() has been removed.")};At.prototype.rotateX=function(){console.error("THREE.Matrix4: .rotateX() has been removed.")};At.prototype.rotateY=function(){console.error("THREE.Matrix4: .rotateY() has been removed.")};At.prototype.rotateZ=function(){console.error("THREE.Matrix4: .rotateZ() has been removed.")};At.prototype.rotateByAxis=function(){console.error("THREE.Matrix4: .rotateByAxis() has been removed.")};At.prototype.applyToBufferAttribute=function(o){return console.warn("THREE.Matrix4: .applyToBufferAttribute() has been removed. Use attribute.applyMatrix4( matrix ) instead."),o.applyMatrix4(this)};At.prototype.applyToVector3Array=function(){console.error("THREE.Matrix4: .applyToVector3Array() has been removed.")};At.prototype.makeFrustum=function(o,t,e,n,r,s){return console.warn("THREE.Matrix4: .makeFrustum() has been removed. Use .makePerspective( left, right, top, bottom, near, far ) instead."),this.makePerspective(o,t,n,e,r,s)};At.prototype.getInverse=function(o){return console.warn("THREE.Matrix4: .getInverse() has been removed. Use matrixInv.copy( matrix ).invert(); instead."),this.copy(o).invert()};Sn.prototype.isIntersectionLine=function(o){return console.warn("THREE.Plane: .isIntersectionLine() has been renamed to .intersectsLine()."),this.intersectsLine(o)};Be.prototype.multiplyVector3=function(o){return console.warn("THREE.Quaternion: .multiplyVector3() has been removed. Use is now vector.applyQuaternion( quaternion ) instead."),o.applyQuaternion(this)};Be.prototype.inverse=function(){return console.warn("THREE.Quaternion: .inverse() has been renamed to invert()."),this.invert()};nr.prototype.isIntersectionBox=function(o){return console.warn("THREE.Ray: .isIntersectionBox() has been renamed to .intersectsBox()."),this.intersectsBox(o)};nr.prototype.isIntersectionPlane=function(o){return console.warn("THREE.Ray: .isIntersectionPlane() has been renamed to .intersectsPlane()."),this.intersectsPlane(o)};nr.prototype.isIntersectionSphere=function(o){return console.warn("THREE.Ray: .isIntersectionSphere() has been renamed to .intersectsSphere()."),this.intersectsSphere(o)};fe.prototype.area=function(){return console.warn("THREE.Triangle: .area() has been renamed to .getArea()."),this.getArea()};fe.prototype.barycoordFromPoint=function(o,t){return console.warn("THREE.Triangle: .barycoordFromPoint() has been renamed to .getBarycoord()."),this.getBarycoord(o,t)};fe.prototype.midpoint=function(o){return console.warn("THREE.Triangle: .midpoint() has been renamed to .getMidpoint()."),this.getMidpoint(o)};fe.prototypenormal=function(o){return console.warn("THREE.Triangle: .normal() has been renamed to .getNormal()."),this.getNormal(o)};fe.prototype.plane=function(o){return console.warn("THREE.Triangle: .plane() has been renamed to .getPlane()."),this.getPlane(o)};fe.barycoordFromPoint=function(o,t,e,n,r){return console.warn("THREE.Triangle: .barycoordFromPoint() has been renamed to .getBarycoord()."),fe.getBarycoord(o,t,e,n,r)};fe.normal=function(o,t,e,n){return console.warn("THREE.Triangle: .normal() has been renamed to .getNormal()."),fe.getNormal(o,t,e,n)};$n.prototype.extractAllPoints=function(o){return console.warn("THREE.Shape: .extractAllPoints() has been removed. Use .extractPoints() instead."),this.extractPoints(o)};$n.prototype.extrude=function(o){return console.warn("THREE.Shape: .extrude() has been removed. Use ExtrudeGeometry() instead."),new sr(this,o)};$n.prototype.makeGeometry=function(o){return console.warn("THREE.Shape: .makeGeometry() has been removed. Use ShapeGeometry() instead."),new Ja(this,o)};st.prototype.fromAttribute=function(o,t,e){return console.warn("THREE.Vector2: .fromAttribute() has been renamed to .fromBufferAttribute()."),this.fromBufferAttribute(o,t,e)};st.prototype.distanceToManhattan=function(o){return console.warn("THREE.Vector2: .distanceToManhattan() has been renamed to .manhattanDistanceTo()."),this.manhattanDistanceTo(o)};st.prototype.lengthManhattan=function(){return console.warn("THREE.Vector2: .lengthManhattan() has been renamed to .manhattanLength()."),this.manhattanLength()};D.prototype.setEulerFromRotationMatrix=function(){console.error("THREE.Vector3: .setEulerFromRotationMatrix() has been removed. Use Euler.setFromRotationMatrix() instead.")};D.prototype.setEulerFromQuaternion=function(){console.error("THREE.Vector3: .setEulerFromQuaternion() has been removed. Use Euler.setFromQuaternion() instead.")};D.prototype.getPositionFromMatrix=function(o){return console.warn("THREE.Vector3: .getPositionFromMatrix() has been renamed to .setFromMatrixPosition()."),this.setFromMatrixPosition(o)};D.prototype.getScaleFromMatrix=function(o){return console.warn("THREE.Vector3: .getScaleFromMatrix() has been renamed to .setFromMatrixScale()."),this.setFromMatrixScale(o)};D.prototype.getColumnFromMatrix=function(o,t){return console.warn("THREE.Vector3: .getColumnFromMatrix() has been renamed to .setFromMatrixColumn()."),this.setFromMatrixColumn(t,o)};D.prototype.applyProjection=function(o){return console.warn("THREE.Vector3: .applyProjection() has been removed. Use .applyMatrix4( m ) instead."),this.applyMatrix4(o)};D.prototype.fromAttribute=function(o,t,e){return console.warn("THREE.Vector3: .fromAttribute() has been renamed to .fromBufferAttribute()."),this.fromBufferAttribute(o,t,e)};D.prototype.distanceToManhattan=function(o){return console.warn("THREE.Vector3: .distanceToManhattan() has been renamed to .manhattanDistanceTo()."),this.manhattanDistanceTo(o)};D.prototype.lengthManhattan=function(){return console.warn("THREE.Vector3: .lengthManhattan() has been renamed to .manhattanLength()."),this.manhattanLength()};re.prototype.fromAttribute=function(o,t,e){return console.warn("THREE.Vector4: .fromAttribute() has been renamed to .fromBufferAttribute()."),this.fromBufferAttribute(o,t,e)};re.prototype.lengthManhattan=function(){return console.warn("THREE.Vector4: .lengthManhattan() has been renamed to .manhattanLength()."),this.manhattanLength()};te.prototype.getChildByName=function(o){return console.warn("THREE.Object3D: .getChildByName() has been renamed to .getObjectByName()."),this.getObjectByName(o)};te.prototype.renderDepth=function(){console.warn("THREE.Object3D: .renderDepth has been removed. Use .renderOrder, instead.")};te.prototype.translate=function(o,t){return console.warn("THREE.Object3D: .translate() has been removed. Use .translateOnAxis( axis, distance ) instead."),this.translateOnAxis(t,o)};te.prototype.getWorldRotation=function(){console.error("THREE.Object3D: .getWorldRotation() has been removed. Use THREE.Object3D.getWorldQuaternion( target ) instead.")};te.prototype.applyMatrix=function(o){return console.warn("THREE.Object3D: .applyMatrix() has been renamed to .applyMatrix4()."),this.applyMatrix4(o)};Object.defineProperties(te.prototype,{eulerOrder:{get:function(){return console.warn("THREE.Object3D: .eulerOrder is now .rotation.order."),this.rotation.order},set:function(o){console.warn("THREE.Object3D: .eulerOrder is now .rotation.order."),this.rotation.order=o}},useQuaternion:{get:function(){console.warn("THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default.")},set:function(){console.warn("THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default.")}}});Ve.prototype.setDrawMode=function(){console.error("THREE.Mesh: .setDrawMode() has been removed. The renderer now always assumes THREE.TrianglesDrawMode. Transform your geometry via BufferGeometryUtils.toTrianglesDrawMode() if necessary.")};Object.defineProperties(Ve.prototype,{drawMode:{get:function(){return console.error("THREE.Mesh: .drawMode has been removed. The renderer now always assumes THREE.TrianglesDrawMode."),mg},set:function(){console.error("THREE.Mesh: .drawMode has been removed. The renderer now always assumes THREE.TrianglesDrawMode. Transform your geometry via BufferGeometryUtils.toTrianglesDrawMode() if necessary.")}}});gu.prototype.initBones=function(){console.error("THREE.SkinnedMesh: initBones() has been removed.")};ke.prototype.setLens=function(o,t){console.warn("THREE.PerspectiveCamera.setLens is deprecated. Use .setFocalLength and .filmGauge for a photographic setup."),t!==void 0&&(this.filmGauge=t),this.setFocalLength(o)};Object.defineProperties(hn.prototype,{onlyShadow:{set:function(){console.warn("THREE.Light: .onlyShadow has been removed.")}},shadowCameraFov:{set:function(o){console.warn("THREE.Light: .shadowCameraFov is now .shadow.camera.fov."),this.shadow.camera.fov=o}},shadowCameraLeft:{set:function(o){console.warn("THREE.Light: .shadowCameraLeft is now .shadow.camera.left."),this.shadow.camera.left=o}},shadowCameraRight:{set:function(o){console.warn("THREE.Light: .shadowCameraRight is now .shadow.camera.right."),this.shadow.camera.right=o}},shadowCameraTop:{set:function(o){console.warn("THREE.Light: .shadowCameraTop is now .shadow.camera.top."),this.shadow.camera.top=o}},shadowCameraBottom:{set:function(o){console.warn("THREE.Light: .shadowCameraBottom is now .shadow.camera.bottom."),this.shadow.camera.bottom=o}},shadowCameraNear:{set:function(o){console.warn("THREE.Light: .shadowCameraNear is now .shadow.camera.near."),this.shadow.camera.near=o}},shadowCameraFar:{set:function(o){console.warn("THREE.Light: .shadowCameraFar is now .shadow.camera.far."),this.shadow.camera.far=o}},shadowCameraVisible:{set:function(){console.warn("THREE.Light: .shadowCameraVisible has been removed. Use new THREE.CameraHelper( light.shadow.camera ) instead.")}},shadowBias:{set:function(o){console.warn("THREE.Light: .shadowBias is now .shadow.bias."),this.shadow.bias=o}},shadowDarkness:{set:function(){console.warn("THREE.Light: .shadowDarkness has been removed.")}},shadowMapWidth:{set:function(o){console.warn("THREE.Light: .shadowMapWidth is now .shadow.mapSize.width."),this.shadow.mapSize.width=o}},shadowMapHeight:{set:function(o){console.warn("THREE.Light: .shadowMapHeight is now .shadow.mapSize.height."),this.shadow.mapSize.height=o}}});Object.defineProperties(_e.prototype,{length:{get:function(){return console.warn("THREE.BufferAttribute: .length has been deprecated. Use .count instead."),this.array.length}},dynamic:{get:function(){return console.warn("THREE.BufferAttribute: .dynamic has been deprecated. Use .usage instead."),this.usage===js},set:function(){console.warn("THREE.BufferAttribute: .dynamic has been deprecated. Use .usage instead."),this.setUsage(js)}}});_e.prototype.setDynamic=function(o){return console.warn("THREE.BufferAttribute: .setDynamic() has been deprecated. Use .setUsage() instead."),this.setUsage(o===!0?js:Ur),this};_e.prototype.copyIndicesArray=function(){console.error("THREE.BufferAttribute: .copyIndicesArray() has been removed.")},_e.prototype.setArray=function(){console.error("THREE.BufferAttribute: .setArray has been removed. Use BufferGeometry .setAttribute to replace/resize attribute buffers")};ce.prototype.addIndex=function(o){console.warn("THREE.BufferGeometry: .addIndex() has been renamed to .setIndex()."),this.setIndex(o)};ce.prototype.addAttribute=function(o,t){return console.warn("THREE.BufferGeometry: .addAttribute() has been renamed to .setAttribute()."),!(t&&t.isBufferAttribute)&&!(t&&t.isInterleavedBufferAttribute)?(console.warn("THREE.BufferGeometry: .addAttribute() now expects ( name, attribute )."),this.setAttribute(o,new _e(arguments[1],arguments[2]))):o==="index"?(console.warn("THREE.BufferGeometry.addAttribute: Use .setIndex() for index attribute."),this.setIndex(t),this):this.setAttribute(o,t)};ce.prototype.addDrawCall=function(o,t,e){e!==void 0&&console.warn("THREE.BufferGeometry: .addDrawCall() no longer supports indexOffset."),console.warn("THREE.BufferGeometry: .addDrawCall() is now .addGroup()."),this.addGroup(o,t)};ce.prototype.clearDrawCalls=function(){console.warn("THREE.BufferGeometry: .clearDrawCalls() is now .clearGroups()."),this.clearGroups()};ce.prototype.computeOffsets=function(){console.warn("THREE.BufferGeometry: .computeOffsets() has been removed.")};ce.prototype.removeAttribute=function(o){return console.warn("THREE.BufferGeometry: .removeAttribute() has been renamed to .deleteAttribute()."),this.deleteAttribute(o)};ce.prototype.applyMatrix=function(o){return console.warn("THREE.BufferGeometry: .applyMatrix() has been renamed to .applyMatrix4()."),this.applyMatrix4(o)};Object.defineProperties(ce.prototype,{drawcalls:{get:function(){return console.error("THREE.BufferGeometry: .drawcalls has been renamed to .groups."),this.groups}},offsets:{get:function(){return console.warn("THREE.BufferGeometry: .offsets has been renamed to .groups."),this.groups}}});Yr.prototype.setDynamic=function(o){return console.warn("THREE.InterleavedBuffer: .setDynamic() has been deprecated. Use .setUsage() instead."),this.setUsage(o===!0?js:Ur),this};Yr.prototype.setArray=function(){console.error("THREE.InterleavedBuffer: .setArray has been removed. Use BufferGeometry .setAttribute to replace/resize attribute buffers")};sr.prototype.getArrays=function(){console.error("THREE.ExtrudeGeometry: .getArrays() has been removed.")};sr.prototype.addShapeList=function(){console.error("THREE.ExtrudeGeometry: .addShapeList() has been removed.")};sr.prototype.addShape=function(){console.error("THREE.ExtrudeGeometry: .addShape() has been removed.")};pu.prototype.dispose=function(){console.error("THREE.Scene: .dispose() has been removed.")};Object.defineProperties(Pe.prototype,{wrapAround:{get:function(){console.warn("THREE.Material: .wrapAround has been removed.")},set:function(){console.warn("THREE.Material: .wrapAround has been removed.")}},overdraw:{get:function(){console.warn("THREE.Material: .overdraw has been removed.")},set:function(){console.warn("THREE.Material: .overdraw has been removed.")}},wrapRGB:{get:function(){return console.warn("THREE.Material: .wrapRGB has been removed."),new Et}},shading:{get:function(){console.error("THREE."+this.type+": .shading has been removed. Use the boolean .flatShading instead.")},set:function(o){console.warn("THREE."+this.type+": .shading has been removed. Use the boolean .flatShading instead."),this.flatShading=o===Oh}},stencilMask:{get:function(){return console.warn("THREE."+this.type+": .stencilMask has been removed. Use .stencilFuncMask instead."),this.stencilFuncMask},set:function(o){console.warn("THREE."+this.type+": .stencilMask has been removed. Use .stencilFuncMask instead."),this.stencilFuncMask=o}},vertexTangents:{get:function(){console.warn("THREE."+this.type+": .vertexTangents has been removed.")},set:function(){console.warn("THREE."+this.type+": .vertexTangents has been removed.")}}});Object.defineProperties(di.prototype,{derivatives:{get:function(){return console.warn("THREE.ShaderMaterial: .derivatives has been moved to .extensions.derivatives."),this.extensions.derivatives},set:function(o){console.warn("THREE. ShaderMaterial: .derivatives has been moved to .extensions.derivatives."),this.extensions.derivatives=o}}});ne.prototype.clearTarget=function(o,t,e,n){console.warn("THREE.WebGLRenderer: .clearTarget() has been deprecated. Use .setRenderTarget() and .clear() instead."),this.setRenderTarget(o),this.clear(t,e,n)};ne.prototype.animate=function(o){console.warn("THREE.WebGLRenderer: .animate() is now .setAnimationLoop()."),this.setAnimationLoop(o)};ne.prototype.getCurrentRenderTarget=function(){return console.warn("THREE.WebGLRenderer: .getCurrentRenderTarget() is now .getRenderTarget()."),this.getRenderTarget()};ne.prototype.getMaxAnisotropy=function(){return console.warn("THREE.WebGLRenderer: .getMaxAnisotropy() is now .capabilities.getMaxAnisotropy()."),this.capabilities.getMaxAnisotropy()};ne.prototype.getPrecision=function(){return console.warn("THREE.WebGLRenderer: .getPrecision() is now .capabilities.precision."),this.capabilities.precision};ne.prototype.resetGLState=function(){return console.warn("THREE.WebGLRenderer: .resetGLState() is now .state.reset()."),this.state.reset()};ne.prototype.supportsFloatTextures=function(){return console.warn("THREE.WebGLRenderer: .supportsFloatTextures() is now .extensions.get( 'OES_texture_float' )."),this.extensions.get("OES_texture_float")};ne.prototype.supportsHalfFloatTextures=function(){return console.warn("THREE.WebGLRenderer: .supportsHalfFloatTextures() is now .extensions.get( 'OES_texture_half_float' )."),this.extensions.get("OES_texture_half_float")};ne.prototype.supportsStandardDerivatives=function(){return console.warn("THREE.WebGLRenderer: .supportsStandardDerivatives() is now .extensions.get( 'OES_standard_derivatives' )."),this.extensions.get("OES_standard_derivatives")};ne.prototype.supportsCompressedTextureS3TC=function(){return console.warn("THREE.WebGLRenderer: .supportsCompressedTextureS3TC() is now .extensions.get( 'WEBGL_compressed_texture_s3tc' )."),this.extensions.get("WEBGL_compressed_texture_s3tc")};ne.prototype.supportsCompressedTexturePVRTC=function(){return console.warn("THREE.WebGLRenderer: .supportsCompressedTexturePVRTC() is now .extensions.get( 'WEBGL_compressed_texture_pvrtc' )."),this.extensions.get("WEBGL_compressed_texture_pvrtc")};ne.prototype.supportsBlendMinMax=function(){return console.warn("THREE.WebGLRenderer: .supportsBlendMinMax() is now .extensions.get( 'EXT_blend_minmax' )."),this.extensions.get("EXT_blend_minmax")};ne.prototype.supportsVertexTextures=function(){return console.warn("THREE.WebGLRenderer: .supportsVertexTextures() is now .capabilities.vertexTextures."),this.capabilities.vertexTextures};ne.prototype.supportsInstancedArrays=function(){return console.warn("THREE.WebGLRenderer: .supportsInstancedArrays() is now .extensions.get( 'ANGLE_instanced_arrays' )."),this.extensions.get("ANGLE_instanced_arrays")};ne.prototype.enableScissorTest=function(o){console.warn("THREE.WebGLRenderer: .enableScissorTest() is now .setScissorTest()."),this.setScissorTest(o)};ne.prototype.initMaterial=function(){console.warn("THREE.WebGLRenderer: .initMaterial() has been removed.")};ne.prototype.addPrePlugin=function(){console.warn("THREE.WebGLRenderer: .addPrePlugin() has been removed.")};ne.prototype.addPostPlugin=function(){console.warn("THREE.WebGLRenderer: .addPostPlugin() has been removed.")};ne.prototype.updateShadowMap=function(){console.warn("THREE.WebGLRenderer: .updateShadowMap() has been removed.")};ne.prototype.setFaceCulling=function(){console.warn("THREE.WebGLRenderer: .setFaceCulling() has been removed.")};ne.prototype.allocTextureUnit=function(){console.warn("THREE.WebGLRenderer: .allocTextureUnit() has been removed.")};ne.prototype.setTexture=function(){console.warn("THREE.WebGLRenderer: .setTexture() has been removed.")};ne.prototype.setTexture2D=function(){console.warn("THREE.WebGLRenderer: .setTexture2D() has been removed.")};ne.prototype.setTextureCube=function(){console.warn("THREE.WebGLRenderer: .setTextureCube() has been removed.")};ne.prototype.getActiveMipMapLevel=function(){return console.warn("THREE.WebGLRenderer: .getActiveMipMapLevel() is now .getActiveMipmapLevel()."),this.getActiveMipmapLevel()};Object.defineProperties(ne.prototype,{shadowMapEnabled:{get:function(){return this.shadowMap.enabled},set:function(o){console.warn("THREE.WebGLRenderer: .shadowMapEnabled is now .shadowMap.enabled."),this.shadowMap.enabled=o}},shadowMapType:{get:function(){return this.shadowMap.type},set:function(o){console.warn("THREE.WebGLRenderer: .shadowMapType is now .shadowMap.type."),this.shadowMap.type=o}},shadowMapCullFace:{get:function(){console.warn("THREE.WebGLRenderer: .shadowMapCullFace has been removed. Set Material.shadowSide instead.")},set:function(){console.warn("THREE.WebGLRenderer: .shadowMapCullFace has been removed. Set Material.shadowSide instead.")}},context:{get:function(){return console.warn("THREE.WebGLRenderer: .context has been removed. Use .getContext() instead."),this.getContext()}},vr:{get:function(){return console.warn("THREE.WebGLRenderer: .vr has been renamed to .xr"),this.xr}},gammaInput:{get:function(){return console.warn("THREE.WebGLRenderer: .gammaInput has been removed. Set the encoding for textures via Texture.encoding instead."),!1},set:function(){console.warn("THREE.WebGLRenderer: .gammaInput has been removed. Set the encoding for textures via Texture.encoding instead.")}},gammaOutput:{get:function(){return console.warn("THREE.WebGLRenderer: .gammaOutput has been removed. Set WebGLRenderer.outputEncoding instead."),!1},set:function(o){console.warn("THREE.WebGLRenderer: .gammaOutput has been removed. Set WebGLRenderer.outputEncoding instead."),this.outputEncoding=o===!0?Ki:en}},toneMappingWhitePoint:{get:function(){return console.warn("THREE.WebGLRenderer: .toneMappingWhitePoint has been removed."),1},set:function(){console.warn("THREE.WebGLRenderer: .toneMappingWhitePoint has been removed.")}},gammaFactor:{get:function(){return console.warn("THREE.WebGLRenderer: .gammaFactor has been removed."),2},set:function(){console.warn("THREE.WebGLRenderer: .gammaFactor has been removed.")}}});Object.defineProperties(uu.prototype,{cullFace:{get:function(){console.warn("THREE.WebGLRenderer: .shadowMap.cullFace has been removed. Set Material.shadowSide instead.")},set:function(){console.warn("THREE.WebGLRenderer: .shadowMap.cullFace has been removed. Set Material.shadowSide instead.")}},renderReverseSided:{get:function(){console.warn("THREE.WebGLRenderer: .shadowMap.renderReverseSided has been removed. Set Material.shadowSide instead.")},set:function(){console.warn("THREE.WebGLRenderer: .shadowMap.renderReverseSided has been removed. Set Material.shadowSide instead.")}},renderSingleSided:{get:function(){console.warn("THREE.WebGLRenderer: .shadowMap.renderSingleSided has been removed. Set Material.shadowSide instead.")},set:function(){console.warn("THREE.WebGLRenderer: .shadowMap.renderSingleSided has been removed. Set Material.shadowSide instead.")}}});Object.defineProperties(Ye.prototype,{wrapS:{get:function(){return console.warn("THREE.WebGLRenderTarget: .wrapS is now .texture.wrapS."),this.texture.wrapS},set:function(o){console.warn("THREE.WebGLRenderTarget: .wrapS is now .texture.wrapS."),this.texture.wrapS=o}},wrapT:{get:function(){return console.warn("THREE.WebGLRenderTarget: .wrapT is now .texture.wrapT."),this.texture.wrapT},set:function(o){console.warn("THREE.WebGLRenderTarget: .wrapT is now .texture.wrapT."),this.texture.wrapT=o}},magFilter:{get:function(){return console.warn("THREE.WebGLRenderTarget: .magFilter is now .texture.magFilter."),this.texture.magFilter},set:function(o){console.warn("THREE.WebGLRenderTarget: .magFilter is now .texture.magFilter."),this.texture.magFilter=o}},minFilter:{get:function(){return console.warn("THREE.WebGLRenderTarget: .minFilter is now .texture.minFilter."),this.texture.minFilter},set:function(o){console.warn("THREE.WebGLRenderTarget: .minFilter is now .texture.minFilter."),this.texture.minFilter=o}},anisotropy:{get:function(){return console.warn("THREE.WebGLRenderTarget: .anisotropy is now .texture.anisotropy."),this.texture.anisotropy},set:function(o){console.warn("THREE.WebGLRenderTarget: .anisotropy is now .texture.anisotropy."),this.texture.anisotropy=o}},offset:{get:function(){return console.warn("THREE.WebGLRenderTarget: .offset is now .texture.offset."),this.texture.offset},set:function(o){console.warn("THREE.WebGLRenderTarget: .offset is now .texture.offset."),this.texture.offset=o}},repeat:{get:function(){return console.warn("THREE.WebGLRenderTarget: .repeat is now .texture.repeat."),this.texture.repeat},set:function(o){console.warn("THREE.WebGLRenderTarget: .repeat is now .texture.repeat."),this.texture.repeat=o}},format:{get:function(){return console.warn("THREE.WebGLRenderTarget: .format is now .texture.format."),this.texture.format},set:function(o){console.warn("THREE.WebGLRenderTarget: .format is now .texture.format."),this.texture.format=o}},type:{get:function(){return console.warn("THREE.WebGLRenderTarget: .type is now .texture.type."),this.texture.type},set:function(o){console.warn("THREE.WebGLRenderTarget: .type is now .texture.type."),this.texture.type=o}},generateMipmaps:{get:function(){return console.warn("THREE.WebGLRenderTarget: .generateMipmaps is now .texture.generateMipmaps."),this.texture.generateMipmaps},set:function(o){console.warn("THREE.WebGLRenderTarget: .generateMipmaps is now .texture.generateMipmaps."),this.texture.generateMipmaps=o}}});yy.prototype.load=function(o){console.warn("THREE.Audio: .load has been deprecated. Use THREE.AudioLoader instead.");const t=this;return new _y().load(o,function(n){t.setBuffer(n)}),this};Ba.prototype.updateCubeMap=function(o,t){return console.warn("THREE.CubeCamera: .updateCubeMap() is now .update()."),this.update(o,t)};Ba.prototype.clear=function(o,t,e,n){return console.warn("THREE.CubeCamera: .clear() is now .renderTarget.clear()."),this.renderTarget.clear(o,t,e,n)};tr.crossOrigin=void 0;tr.loadTexture=function(o,t,e,n){console.warn("THREE.ImageUtils.loadTexture has been deprecated. Use THREE.TextureLoader() instead.");const r=new ay;r.setCrossOrigin(this.crossOrigin);const s=r.load(o,e,void 0,n);return t&&(s.mapping=t),s};tr.loadTextureCube=function(o,t,e,n){console.warn("THREE.ImageUtils.loadTextureCube has been deprecated. Use THREE.CubeTextureLoader() instead.");const r=new oy;r.setCrossOrigin(this.crossOrigin);const s=r.load(o,e,void 0,n);return t&&(s.mapping=t),s};tr.loadCompressedTexture=function(){console.error("THREE.ImageUtils.loadCompressedTexture has been removed. Use THREE.DDSLoader instead.")};tr.loadCompressedTextureCube=function(){console.error("THREE.ImageUtils.loadCompressedTextureCube has been removed. Use THREE.DDSLoader instead.")};typeof __THREE_DEVTOOLS__!="undefined"&&__THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("register",{detail:{revision:Da}}));typeof window!="undefined"&&(window.__THREE__?console.warn("WARNING: Multiple instances of Three.js being imported."):window.__THREE__=Da);class zy extends Cn{constructor(t){super(t)}load(t,e,n,r){const s=this,l=new Pu(this.manager);l.setPath(this.path),l.setRequestHeader(this.requestHeader),l.setWithCredentials(s.withCredentials),l.load(t,function(h){let d;try{d=JSON.parse(h)}catch{console.warn("THREE.FontLoader: typeface.js support is being deprecated. Use typeface.json instead."),d=JSON.parse(h.substring(65,h.length-2))}const p=s.parse(d);e&&e(p)},n,r)}parse(t){return new ku(t)}}class ku{constructor(t){this.type="Font",this.data=t}generateShapes(t,e=100){const n=[],r=Oy(t,e,this.data);for(let s=0,l=r.length;s<l;s++)Array.prototype.push.apply(n,r[s].toShapes());return n}}function Oy(o,t,e){const n=Array.from(o),r=t/e.resolution,s=(e.boundingBox.yMax-e.boundingBox.yMin+e.underlineThickness)*r,l=[];let h=0,d=0;for(let p=0;p<n.length;p++){const f=n[p];if(f===`
`)h=0,d-=s;else{const m=Uy(f,r,h,d,e);h+=m.offsetX,l.push(m.path)}}return l}function Uy(o,t,e,n,r){const s=r.glyphs[o]||r.glyphs["?"];if(!s){console.error('THREE.Font: character "'+o+'" does not exists in font family '+r.familyName+".");return}const l=new Vy;let h,d,p,f,m,g,_,y;if(s.o){const w=s._cachedOutline||(s._cachedOutline=s.o.split(" "));for(let S=0,x=w.length;S<x;)switch(w[S++]){case"m":h=w[S++]*t+e,d=w[S++]*t+n,l.moveTo(h,d);break;case"l":h=w[S++]*t+e,d=w[S++]*t+n,l.lineTo(h,d);break;case"q":p=w[S++]*t+e,f=w[S++]*t+n,m=w[S++]*t+e,g=w[S++]*t+n,l.quadraticCurveTo(m,g,p,f);break;case"b":p=w[S++]*t+e,f=w[S++]*t+n,m=w[S++]*t+e,g=w[S++]*t+n,_=w[S++]*t+e,y=w[S++]*t+n,l.bezierCurveTo(m,g,_,y,p,f);break}}return{offsetX:s.ha*t,path:l}}ku.prototype.isFont=!0;var Vh="/demo-react-1/assets/4681780_0.b8723e2b.jpg",xa="/demo-react-1/assets/bg.419f015b.jpg",Hy="/demo-react-1/assets/bg3.66d0699b.jpg",Bh={exports:{}};/*! Tweakpane 3.1.7 (c) 2016 cocopon, licensed under the MIT license. */(function(o,t){(function(e,n){n(t)})(Uf,function(e){class n{constructor(i){const[a,u]=i.split("-"),b=a.split(".");this.major=parseInt(b[0],10),this.minor=parseInt(b[1],10),this.patch=parseInt(b[2],10),this.prerelease=u!=null?u:null}toString(){const i=[this.major,this.minor,this.patch].join(".");return this.prerelease!==null?[i,this.prerelease].join("-"):i}}class r{constructor(i){this.controller_=i}get element(){return this.controller_.view.element}get disabled(){return this.controller_.viewProps.get("disabled")}set disabled(i){this.controller_.viewProps.set("disabled",i)}get hidden(){return this.controller_.viewProps.get("hidden")}set hidden(i){this.controller_.viewProps.set("hidden",i)}dispose(){this.controller_.viewProps.set("disposed",!0)}}class s{constructor(i){this.target=i}}class l extends s{constructor(i,a,u,b){super(i),this.value=a,this.presetKey=u,this.last=b!=null?b:!0}}class h extends s{constructor(i,a,u){super(i),this.value=a,this.presetKey=u}}class d extends s{constructor(i,a){super(i),this.expanded=a}}class p extends s{constructor(i,a){super(i),this.index=a}}function f(c){return c}function m(c){return c==null}function g(c,i){if(c.length!==i.length)return!1;for(let a=0;a<c.length;a++)if(c[a]!==i[a])return!1;return!0}function _(c,i){let a=c;do{const u=Object.getOwnPropertyDescriptor(a,i);if(u&&(u.set!==void 0||u.writable===!0))return!0;a=Object.getPrototypeOf(a)}while(a!==null);return!1}const y={alreadydisposed:()=>"View has been already disposed",invalidparams:c=>`Invalid parameters for '${c.name}'`,nomatchingcontroller:c=>`No matching controller for '${c.key}'`,nomatchingview:c=>`No matching view for '${JSON.stringify(c.params)}'`,notbindable:()=>"Value is not bindable",propertynotfound:c=>`Property '${c.name}' not found`,shouldneverhappen:()=>"This error should never happen"};class w{static alreadyDisposed(){return new w({type:"alreadydisposed"})}static notBindable(){return new w({type:"notbindable"})}static propertyNotFound(i){return new w({type:"propertynotfound",context:{name:i}})}static shouldNeverHappen(){return new w({type:"shouldneverhappen"})}constructor(i){var a;this.message=(a=y[i.type](i.context))!==null&&a!==void 0?a:"Unexpected error",this.name=this.constructor.name,this.stack=new Error(this.message).stack,this.type=i.type}}class S{constructor(i,a,u){this.obj_=i,this.key_=a,this.presetKey_=u!=null?u:a}static isBindable(i){return!(i===null||typeof i!="object")}get key(){return this.key_}get presetKey(){return this.presetKey_}read(){return this.obj_[this.key_]}write(i){this.obj_[this.key_]=i}writeProperty(i,a){const u=this.read();if(!S.isBindable(u))throw w.notBindable();if(!(i in u))throw w.propertyNotFound(i);u[i]=a}}class x extends r{get label(){return this.controller_.props.get("label")}set label(i){this.controller_.props.set("label",i)}get title(){var i;return(i=this.controller_.valueController.props.get("title"))!==null&&i!==void 0?i:""}set title(i){this.controller_.valueController.props.set("title",i)}on(i,a){const u=a.bind(this);return this.controller_.valueController.emitter.on(i,()=>{u(new s(this))}),this}}class v{constructor(){this.observers_={}}on(i,a){let u=this.observers_[i];return u||(u=this.observers_[i]=[]),u.push({handler:a}),this}off(i,a){const u=this.observers_[i];return u&&(this.observers_[i]=u.filter(b=>b.handler!==a)),this}emit(i,a){const u=this.observers_[i];!u||u.forEach(b=>{b.handler(a)})}}const N="tp";function M(c){return(a,u)=>[N,"-",c,"v",a?`_${a}`:"",u?`-${u}`:""].join("")}function R(c,i){return a=>i(c(a))}function F(c){return c.rawValue}function k(c,i){c.emitter.on("change",R(F,i)),i(c.rawValue)}function j(c,i,a){k(c.value(i),a)}function ot(c,i,a){a?c.classList.add(i):c.classList.remove(i)}function Y(c,i){return a=>{ot(c,i,a)}}function V(c,i){k(c,a=>{i.textContent=a!=null?a:""})}const C=M("btn");class A{constructor(i,a){this.element=i.createElement("div"),this.element.classList.add(C()),a.viewProps.bindClassModifiers(this.element);const u=i.createElement("button");u.classList.add(C("b")),a.viewProps.bindDisabled(u),this.element.appendChild(u),this.buttonElement=u;const b=i.createElement("div");b.classList.add(C("t")),V(a.props.value("title"),b),this.buttonElement.appendChild(b)}}class H{constructor(i,a){this.emitter=new v,this.onClick_=this.onClick_.bind(this),this.props=a.props,this.viewProps=a.viewProps,this.view=new A(i,{props:this.props,viewProps:this.viewProps}),this.view.buttonElement.addEventListener("click",this.onClick_)}onClick_(){this.emitter.emit("click",{sender:this})}}class q{constructor(i,a){var u;this.constraint_=a==null?void 0:a.constraint,this.equals_=(u=a==null?void 0:a.equals)!==null&&u!==void 0?u:(b,P)=>b===P,this.emitter=new v,this.rawValue_=i}get constraint(){return this.constraint_}get rawValue(){return this.rawValue_}set rawValue(i){this.setRawValue(i,{forceEmit:!1,last:!0})}setRawValue(i,a){const u=a!=null?a:{forceEmit:!1,last:!0},b=this.constraint_?this.constraint_.constrain(i):i,P=this.rawValue_;!!this.equals_(P,b)&&!u.forceEmit||(this.emitter.emit("beforechange",{sender:this}),this.rawValue_=b,this.emitter.emit("change",{options:u,previousRawValue:P,rawValue:b,sender:this}))}}class O{constructor(i){this.emitter=new v,this.value_=i}get rawValue(){return this.value_}set rawValue(i){this.setRawValue(i,{forceEmit:!1,last:!0})}setRawValue(i,a){const u=a!=null?a:{forceEmit:!1,last:!0},b=this.value_;b===i&&!u.forceEmit||(this.emitter.emit("beforechange",{sender:this}),this.value_=i,this.emitter.emit("change",{options:u,previousRawValue:b,rawValue:this.value_,sender:this}))}}function U(c,i){const a=i==null?void 0:i.constraint,u=i==null?void 0:i.equals;return!a&&!u?new O(c):new q(c,i)}class X{constructor(i){this.emitter=new v,this.valMap_=i;for(const a in this.valMap_)this.valMap_[a].emitter.on("change",()=>{this.emitter.emit("change",{key:a,sender:this})})}static createCore(i){return Object.keys(i).reduce((u,b)=>Object.assign(u,{[b]:U(i[b])}),{})}static fromObject(i){const a=this.createCore(i);return new X(a)}get(i){return this.valMap_[i].rawValue}set(i,a){this.valMap_[i].rawValue=a}value(i){return this.valMap_[i]}}function _t(c,i){const u=Object.keys(i).reduce((b,P)=>{if(b===void 0)return;const it=i[P](c[P]);return it.succeeded?Object.assign(Object.assign({},b),{[P]:it.value}):void 0},{});return u}function J(c,i){return c.reduce((a,u)=>{if(a===void 0)return;const b=i(u);if(!(!b.succeeded||b.value===void 0))return[...a,b.value]},[])}function Z(c){return c===null?!1:typeof c=="object"}function pt(c){return i=>a=>{if(!i&&a===void 0)return{succeeded:!1,value:void 0};if(i&&a===void 0)return{succeeded:!0,value:void 0};const u=c(a);return u!==void 0?{succeeded:!0,value:u}:{succeeded:!1,value:void 0}}}function vt(c){return{custom:i=>pt(i)(c),boolean:pt(i=>typeof i=="boolean"?i:void 0)(c),number:pt(i=>typeof i=="number"?i:void 0)(c),string:pt(i=>typeof i=="string"?i:void 0)(c),function:pt(i=>typeof i=="function"?i:void 0)(c),constant:i=>pt(a=>a===i?i:void 0)(c),raw:pt(i=>i)(c),object:i=>pt(a=>{if(!!Z(a))return _t(a,i)})(c),array:i=>pt(a=>{if(!!Array.isArray(a))return J(a,i)})(c)}}const at={optional:vt(!0),required:vt(!1)};function Tt(c,i){const a=at.required.object(i)(c);return a.succeeded?a.value:void 0}function Q(c){console.warn([`Missing '${c.key}' of ${c.target} in ${c.place}.`,"Please rebuild plugins with the latest core package."].join(" "))}function zt(c){return c&&c.parentElement&&c.parentElement.removeChild(c),null}class wt{constructor(i){this.value_=i}static create(i){return[new wt(i),(a,u)=>{i.setRawValue(a,u)}]}get emitter(){return this.value_.emitter}get rawValue(){return this.value_.rawValue}}const yt=M("");function Mt(c,i){return Y(c,yt(void 0,i))}class Ot extends X{constructor(i){var a;super(i),this.onDisabledChange_=this.onDisabledChange_.bind(this),this.onParentChange_=this.onParentChange_.bind(this),this.onParentGlobalDisabledChange_=this.onParentGlobalDisabledChange_.bind(this),[this.globalDisabled_,this.setGlobalDisabled_]=wt.create(U(this.getGlobalDisabled_())),this.value("disabled").emitter.on("change",this.onDisabledChange_),this.value("parent").emitter.on("change",this.onParentChange_),(a=this.get("parent"))===null||a===void 0||a.globalDisabled.emitter.on("change",this.onParentGlobalDisabledChange_)}static create(i){var a,u,b;const P=i!=null?i:{};return new Ot(X.createCore({disabled:(a=P.disabled)!==null&&a!==void 0?a:!1,disposed:!1,hidden:(u=P.hidden)!==null&&u!==void 0?u:!1,parent:(b=P.parent)!==null&&b!==void 0?b:null}))}get globalDisabled(){return this.globalDisabled_}bindClassModifiers(i){k(this.globalDisabled_,Mt(i,"disabled")),j(this,"hidden",Mt(i,"hidden"))}bindDisabled(i){k(this.globalDisabled_,a=>{i.disabled=a})}bindTabIndex(i){k(this.globalDisabled_,a=>{i.tabIndex=a?-1:0})}handleDispose(i){this.value("disposed").emitter.on("change",a=>{a&&i()})}getGlobalDisabled_(){const i=this.get("parent");return(i?i.globalDisabled.rawValue:!1)||this.get("disabled")}updateGlobalDisabled_(){this.setGlobalDisabled_(this.getGlobalDisabled_())}onDisabledChange_(){this.updateGlobalDisabled_()}onParentGlobalDisabledChange_(){this.updateGlobalDisabled_()}onParentChange_(i){var a;const u=i.previousRawValue;u==null||u.globalDisabled.emitter.off("change",this.onParentGlobalDisabledChange_),(a=this.get("parent"))===null||a===void 0||a.globalDisabled.emitter.on("change",this.onParentGlobalDisabledChange_),this.updateGlobalDisabled_()}}function $(){return["veryfirst","first","last","verylast"]}const rt=M(""),ct={veryfirst:"vfst",first:"fst",last:"lst",verylast:"vlst"};class xt{constructor(i){this.parent_=null,this.blade=i.blade,this.view=i.view,this.viewProps=i.viewProps;const a=this.view.element;this.blade.value("positions").emitter.on("change",()=>{$().forEach(u=>{a.classList.remove(rt(void 0,ct[u]))}),this.blade.get("positions").forEach(u=>{a.classList.add(rt(void 0,ct[u]))})}),this.viewProps.handleDispose(()=>{zt(a)})}get parent(){return this.parent_}set parent(i){if(this.parent_=i,!("parent"in this.viewProps.valMap_)){Q({key:"parent",target:Ot.name,place:"BladeController.parent"});return}this.viewProps.set("parent",this.parent_?this.parent_.viewProps:null)}}const ht="http://www.w3.org/2000/svg";function Pt(c){c.offsetHeight}function Vt(c,i){const a=c.style.transition;c.style.transition="none",i(),c.style.transition=a}function Ut(c){return c.ontouchstart!==void 0}function ie(){return globalThis}function L(){return ie().document}function T(c){const i=c.ownerDocument.defaultView;return i&&"document"in i?c.getContext("2d",{willReadFrequently:!0}):null}const tt={check:'<path d="M2 8l4 4l8 -8"/>',dropdown:'<path d="M5 7h6l-3 3 z"/>',p2dpad:'<path d="M8 4v8"/><path d="M4 8h8"/><circle cx="12" cy="12" r="1.2"/>'};function et(c,i){const a=c.createElementNS(ht,"svg");return a.innerHTML=tt[i],a}function mt(c,i,a){c.insertBefore(i,c.children[a])}function nt(c){c.parentElement&&c.parentElement.removeChild(c)}function It(c){for(;c.children.length>0;)c.removeChild(c.children[0])}function Ct(c){for(;c.childNodes.length>0;)c.removeChild(c.childNodes[0])}function ut(c){return c.relatedTarget?c.relatedTarget:"explicitOriginalTarget"in c?c.explicitOriginalTarget:null}const I=M("lbl");function dt(c,i){const a=c.createDocumentFragment();return i.split(`
`).map(b=>c.createTextNode(b)).forEach((b,P)=>{P>0&&a.appendChild(c.createElement("br")),a.appendChild(b)}),a}class lt{constructor(i,a){this.element=i.createElement("div"),this.element.classList.add(I()),a.viewProps.bindClassModifiers(this.element);const u=i.createElement("div");u.classList.add(I("l")),j(a.props,"label",P=>{m(P)?this.element.classList.add(I(void 0,"nol")):(this.element.classList.remove(I(void 0,"nol")),Ct(u),u.appendChild(dt(i,P)))}),this.element.appendChild(u),this.labelElement=u;const b=i.createElement("div");b.classList.add(I("v")),this.element.appendChild(b),this.valueElement=b}}class Lt extends xt{constructor(i,a){const u=a.valueController.viewProps;super(Object.assign(Object.assign({},a),{view:new lt(i,{props:a.props,viewProps:u}),viewProps:u})),this.props=a.props,this.valueController=a.valueController,this.view.valueElement.appendChild(this.valueController.view.element)}}const bt={id:"button",type:"blade",accept(c){const i=at,a=Tt(c,{title:i.required.string,view:i.required.constant("button"),label:i.optional.string});return a?{params:a}:null},controller(c){return new Lt(c.document,{blade:c.blade,props:X.fromObject({label:c.params.label}),valueController:new H(c.document,{props:X.fromObject({title:c.params.title}),viewProps:c.viewProps})})},api(c){return!(c.controller instanceof Lt)||!(c.controller.valueController instanceof H)?null:new x(c.controller)}};class Ft extends xt{constructor(i){super(i),this.value=i.value}}function ft(){return new X({positions:U([],{equals:g})})}class Nt extends X{constructor(i){super(i)}static create(i){const a={completed:!0,expanded:i,expandedHeight:null,shouldFixHeight:!1,temporaryExpanded:null},u=X.createCore(a);return new Nt(u)}get styleExpanded(){var i;return(i=this.get("temporaryExpanded"))!==null&&i!==void 0?i:this.get("expanded")}get styleHeight(){if(!this.styleExpanded)return"0";const i=this.get("expandedHeight");return this.get("shouldFixHeight")&&!m(i)?`${i}px`:"auto"}bindExpandedClass(i,a){const u=()=>{this.styleExpanded?i.classList.add(a):i.classList.remove(a)};j(this,"expanded",u),j(this,"temporaryExpanded",u)}cleanUpTransition(){this.set("shouldFixHeight",!1),this.set("expandedHeight",null),this.set("completed",!0)}}function ee(c,i){let a=0;return Vt(i,()=>{c.set("expandedHeight",null),c.set("temporaryExpanded",!0),Pt(i),a=i.clientHeight,c.set("temporaryExpanded",null),Pt(i)}),a}function Zt(c,i){i.style.height=c.styleHeight}function De(c,i){c.value("expanded").emitter.on("beforechange",()=>{if(c.set("completed",!1),m(c.get("expandedHeight"))){const a=ee(c,i);a>0&&c.set("expandedHeight",a)}c.set("shouldFixHeight",!0),Pt(i)}),c.emitter.on("change",()=>{Zt(c,i)}),Zt(c,i),i.addEventListener("transitionend",a=>{a.propertyName==="height"&&c.cleanUpTransition()})}class Ie extends r{constructor(i,a){super(i),this.rackApi_=a}}function dn(c,i){return c.addBlade(Object.assign(Object.assign({},i),{view:"button"}))}function Kr(c,i){return c.addBlade(Object.assign(Object.assign({},i),{view:"folder"}))}function Qr(c,i){const a=i!=null?i:{};return c.addBlade(Object.assign(Object.assign({},a),{view:"separator"}))}function lo(c,i){return c.addBlade(Object.assign(Object.assign({},i),{view:"tab"}))}class An{constructor(i){this.emitter=new v,this.items_=[],this.cache_=new Set,this.onSubListAdd_=this.onSubListAdd_.bind(this),this.onSubListRemove_=this.onSubListRemove_.bind(this),this.extract_=i}get items(){return this.items_}allItems(){return Array.from(this.cache_)}find(i){for(const a of this.allItems())if(i(a))return a;return null}includes(i){return this.cache_.has(i)}add(i,a){if(this.includes(i))throw w.shouldNeverHappen();const u=a!==void 0?a:this.items_.length;this.items_.splice(u,0,i),this.cache_.add(i);const b=this.extract_(i);b&&(b.emitter.on("add",this.onSubListAdd_),b.emitter.on("remove",this.onSubListRemove_),b.allItems().forEach(P=>{this.cache_.add(P)})),this.emitter.emit("add",{index:u,item:i,root:this,target:this})}remove(i){const a=this.items_.indexOf(i);if(a<0)return;this.items_.splice(a,1),this.cache_.delete(i);const u=this.extract_(i);u&&(u.emitter.off("add",this.onSubListAdd_),u.emitter.off("remove",this.onSubListRemove_)),this.emitter.emit("remove",{index:a,item:i,root:this,target:this})}onSubListAdd_(i){this.cache_.add(i.item),this.emitter.emit("add",{index:i.index,item:i.item,root:this,target:i.target})}onSubListRemove_(i){this.cache_.delete(i.item),this.emitter.emit("remove",{index:i.index,item:i.item,root:this,target:i.target})}}class lr extends r{constructor(i){super(i),this.onBindingChange_=this.onBindingChange_.bind(this),this.emitter_=new v,this.controller_.binding.emitter.on("change",this.onBindingChange_)}get label(){return this.controller_.props.get("label")}set label(i){this.controller_.props.set("label",i)}on(i,a){const u=a.bind(this);return this.emitter_.on(i,b=>{u(b.event)}),this}refresh(){this.controller_.binding.read()}onBindingChange_(i){const a=i.sender.target.read();this.emitter_.emit("change",{event:new l(this,a,this.controller_.binding.target.presetKey,i.options.last)})}}class Ne extends Lt{constructor(i,a){super(i,a),this.binding=a.binding}}class fi extends r{constructor(i){super(i),this.onBindingUpdate_=this.onBindingUpdate_.bind(this),this.emitter_=new v,this.controller_.binding.emitter.on("update",this.onBindingUpdate_)}get label(){return this.controller_.props.get("label")}set label(i){this.controller_.props.set("label",i)}on(i,a){const u=a.bind(this);return this.emitter_.on(i,b=>{u(b.event)}),this}refresh(){this.controller_.binding.read()}onBindingUpdate_(i){const a=i.sender.target.read();this.emitter_.emit("update",{event:new h(this,a,this.controller_.binding.target.presetKey)})}}class rn extends Lt{constructor(i,a){super(i,a),this.binding=a.binding,this.viewProps.bindDisabled(this.binding.ticker),this.viewProps.handleDispose(()=>{this.binding.dispose()})}}function co(c){return c instanceof z?c.apiSet_:c instanceof Ie?c.rackApi_.apiSet_:null}function Zn(c,i){const a=c.find(u=>u.controller_===i);if(!a)throw w.shouldNeverHappen();return a}function E(c,i,a){if(!S.isBindable(c))throw w.notBindable();return new S(c,i,a)}class z extends r{constructor(i,a){super(i),this.onRackAdd_=this.onRackAdd_.bind(this),this.onRackRemove_=this.onRackRemove_.bind(this),this.onRackInputChange_=this.onRackInputChange_.bind(this),this.onRackMonitorUpdate_=this.onRackMonitorUpdate_.bind(this),this.emitter_=new v,this.apiSet_=new An(co),this.pool_=a;const u=this.controller_.rack;u.emitter.on("add",this.onRackAdd_),u.emitter.on("remove",this.onRackRemove_),u.emitter.on("inputchange",this.onRackInputChange_),u.emitter.on("monitorupdate",this.onRackMonitorUpdate_),u.children.forEach(b=>{this.setUpApi_(b)})}get children(){return this.controller_.rack.children.map(i=>Zn(this.apiSet_,i))}addInput(i,a,u){const b=u!=null?u:{},P=this.controller_.view.element.ownerDocument,B=this.pool_.createInput(P,E(i,a,b.presetKey),b),it=new lr(B);return this.add(it,b.index)}addMonitor(i,a,u){const b=u!=null?u:{},P=this.controller_.view.element.ownerDocument,B=this.pool_.createMonitor(P,E(i,a),b),it=new fi(B);return this.add(it,b.index)}addFolder(i){return Kr(this,i)}addButton(i){return dn(this,i)}addSeparator(i){return Qr(this,i)}addTab(i){return lo(this,i)}add(i,a){this.controller_.rack.add(i.controller_,a);const u=this.apiSet_.find(b=>b.controller_===i.controller_);return u&&this.apiSet_.remove(u),this.apiSet_.add(i),i}remove(i){this.controller_.rack.remove(i.controller_)}addBlade(i){const a=this.controller_.view.element.ownerDocument,u=this.pool_.createBlade(a,i),b=this.pool_.createBladeApi(u);return this.add(b,i.index)}on(i,a){const u=a.bind(this);return this.emitter_.on(i,b=>{u(b.event)}),this}setUpApi_(i){this.apiSet_.find(u=>u.controller_===i)||this.apiSet_.add(this.pool_.createBladeApi(i))}onRackAdd_(i){this.setUpApi_(i.bladeController)}onRackRemove_(i){if(i.isRoot){const a=Zn(this.apiSet_,i.bladeController);this.apiSet_.remove(a)}}onRackInputChange_(i){const a=i.bladeController;if(a instanceof Ne){const u=Zn(this.apiSet_,a),b=a.binding;this.emitter_.emit("change",{event:new l(u,b.target.read(),b.target.presetKey,i.options.last)})}else if(a instanceof Ft){const u=Zn(this.apiSet_,a);this.emitter_.emit("change",{event:new l(u,a.value.rawValue,void 0,i.options.last)})}}onRackMonitorUpdate_(i){if(!(i.bladeController instanceof rn))throw w.shouldNeverHappen();const a=Zn(this.apiSet_,i.bladeController),u=i.bladeController.binding;this.emitter_.emit("update",{event:new h(a,u.target.read(),u.target.presetKey)})}}class W extends Ie{constructor(i,a){super(i,new z(i.rackController,a)),this.emitter_=new v,this.controller_.foldable.value("expanded").emitter.on("change",u=>{this.emitter_.emit("fold",{event:new d(this,u.sender.rawValue)})}),this.rackApi_.on("change",u=>{this.emitter_.emit("change",{event:u})}),this.rackApi_.on("update",u=>{this.emitter_.emit("update",{event:u})})}get expanded(){return this.controller_.foldable.get("expanded")}set expanded(i){this.controller_.foldable.set("expanded",i)}get title(){return this.controller_.props.get("title")}set title(i){this.controller_.props.set("title",i)}get children(){return this.rackApi_.children}addInput(i,a,u){return this.rackApi_.addInput(i,a,u)}addMonitor(i,a,u){return this.rackApi_.addMonitor(i,a,u)}addFolder(i){return this.rackApi_.addFolder(i)}addButton(i){return this.rackApi_.addButton(i)}addSeparator(i){return this.rackApi_.addSeparator(i)}addTab(i){return this.rackApi_.addTab(i)}add(i,a){return this.rackApi_.add(i,a)}remove(i){this.rackApi_.remove(i)}addBlade(i){return this.rackApi_.addBlade(i)}on(i,a){const u=a.bind(this);return this.emitter_.on(i,b=>{u(b.event)}),this}}class G extends xt{constructor(i){super({blade:i.blade,view:i.view,viewProps:i.rackController.viewProps}),this.rackController=i.rackController}}class K{constructor(i,a){const u=M(a.viewName);this.element=i.createElement("div"),this.element.classList.add(u()),a.viewProps.bindClassModifiers(this.element)}}function kt(c,i){for(let a=0;a<c.length;a++){const u=c[a];if(u instanceof Ne&&u.binding===i)return u}return null}function Bt(c,i){for(let a=0;a<c.length;a++){const u=c[a];if(u instanceof rn&&u.binding===i)return u}return null}function Ht(c,i){for(let a=0;a<c.length;a++){const u=c[a];if(u instanceof Ft&&u.value===i)return u}return null}function Rt(c){return c instanceof Wt?c.rack:c instanceof G?c.rackController.rack:null}function Xt(c){const i=Rt(c);return i?i.bcSet_:null}class Gt{constructor(i){var a,u;this.onBladePositionsChange_=this.onBladePositionsChange_.bind(this),this.onSetAdd_=this.onSetAdd_.bind(this),this.onSetRemove_=this.onSetRemove_.bind(this),this.onChildDispose_=this.onChildDispose_.bind(this),this.onChildPositionsChange_=this.onChildPositionsChange_.bind(this),this.onChildInputChange_=this.onChildInputChange_.bind(this),this.onChildMonitorUpdate_=this.onChildMonitorUpdate_.bind(this),this.onChildValueChange_=this.onChildValueChange_.bind(this),this.onChildViewPropsChange_=this.onChildViewPropsChange_.bind(this),this.onDescendantLayout_=this.onDescendantLayout_.bind(this),this.onDescendantInputChange_=this.onDescendantInputChange_.bind(this),this.onDescendantMonitorUpdate_=this.onDescendantMonitorUpdate_.bind(this),this.emitter=new v,this.blade_=(a=i.blade)!==null&&a!==void 0?a:null,(u=this.blade_)===null||u===void 0||u.value("positions").emitter.on("change",this.onBladePositionsChange_),this.viewProps=i.viewProps,this.bcSet_=new An(Xt),this.bcSet_.emitter.on("add",this.onSetAdd_),this.bcSet_.emitter.on("remove",this.onSetRemove_)}get children(){return this.bcSet_.items}add(i,a){var u;(u=i.parent)===null||u===void 0||u.remove(i),_(i,"parent")?i.parent=this:(i.parent_=this,Q({key:"parent",target:"BladeController",place:"BladeRack.add"})),this.bcSet_.add(i,a)}remove(i){_(i,"parent")?i.parent=null:(i.parent_=null,Q({key:"parent",target:"BladeController",place:"BladeRack.remove"})),this.bcSet_.remove(i)}find(i){return this.bcSet_.allItems().filter(a=>a instanceof i)}onSetAdd_(i){this.updatePositions_();const a=i.target===i.root;if(this.emitter.emit("add",{bladeController:i.item,index:i.index,isRoot:a,sender:this}),!a)return;const u=i.item;if(u.viewProps.emitter.on("change",this.onChildViewPropsChange_),u.blade.value("positions").emitter.on("change",this.onChildPositionsChange_),u.viewProps.handleDispose(this.onChildDispose_),u instanceof Ne)u.binding.emitter.on("change",this.onChildInputChange_);else if(u instanceof rn)u.binding.emitter.on("update",this.onChildMonitorUpdate_);else if(u instanceof Ft)u.value.emitter.on("change",this.onChildValueChange_);else{const b=Rt(u);if(b){const P=b.emitter;P.on("layout",this.onDescendantLayout_),P.on("inputchange",this.onDescendantInputChange_),P.on("monitorupdate",this.onDescendantMonitorUpdate_)}}}onSetRemove_(i){this.updatePositions_();const a=i.target===i.root;if(this.emitter.emit("remove",{bladeController:i.item,isRoot:a,sender:this}),!a)return;const u=i.item;if(u instanceof Ne)u.binding.emitter.off("change",this.onChildInputChange_);else if(u instanceof rn)u.binding.emitter.off("update",this.onChildMonitorUpdate_);else if(u instanceof Ft)u.value.emitter.off("change",this.onChildValueChange_);else{const b=Rt(u);if(b){const P=b.emitter;P.off("layout",this.onDescendantLayout_),P.off("inputchange",this.onDescendantInputChange_),P.off("monitorupdate",this.onDescendantMonitorUpdate_)}}}updatePositions_(){const i=this.bcSet_.items.filter(b=>!b.viewProps.get("hidden")),a=i[0],u=i[i.length-1];this.bcSet_.items.forEach(b=>{const P=[];b===a&&(P.push("first"),(!this.blade_||this.blade_.get("positions").includes("veryfirst"))&&P.push("veryfirst")),b===u&&(P.push("last"),(!this.blade_||this.blade_.get("positions").includes("verylast"))&&P.push("verylast")),b.blade.set("positions",P)})}onChildPositionsChange_(){this.updatePositions_(),this.emitter.emit("layout",{sender:this})}onChildViewPropsChange_(i){this.updatePositions_(),this.emitter.emit("layout",{sender:this})}onChildDispose_(){this.bcSet_.items.filter(a=>a.viewProps.get("disposed")).forEach(a=>{this.bcSet_.remove(a)})}onChildInputChange_(i){const a=kt(this.find(Ne),i.sender);if(!a)throw w.alreadyDisposed();this.emitter.emit("inputchange",{bladeController:a,options:i.options,sender:this})}onChildMonitorUpdate_(i){const a=Bt(this.find(rn),i.sender);if(!a)throw w.alreadyDisposed();this.emitter.emit("monitorupdate",{bladeController:a,sender:this})}onChildValueChange_(i){const a=Ht(this.find(Ft),i.sender);if(!a)throw w.alreadyDisposed();this.emitter.emit("inputchange",{bladeController:a,options:i.options,sender:this})}onDescendantLayout_(i){this.updatePositions_(),this.emitter.emit("layout",{sender:this})}onDescendantInputChange_(i){this.emitter.emit("inputchange",{bladeController:i.bladeController,options:i.options,sender:this})}onDescendantMonitorUpdate_(i){this.emitter.emit("monitorupdate",{bladeController:i.bladeController,sender:this})}onBladePositionsChange_(){this.updatePositions_()}}class Wt extends xt{constructor(i,a){super(Object.assign(Object.assign({},a),{view:new K(i,{viewName:"brk",viewProps:a.viewProps})})),this.onRackAdd_=this.onRackAdd_.bind(this),this.onRackRemove_=this.onRackRemove_.bind(this);const u=new Gt({blade:a.root?void 0:a.blade,viewProps:a.viewProps});u.emitter.on("add",this.onRackAdd_),u.emitter.on("remove",this.onRackRemove_),this.rack=u,this.viewProps.handleDispose(()=>{for(let b=this.rack.children.length-1;b>=0;b--)this.rack.children[b].viewProps.set("disposed",!0)})}onRackAdd_(i){!i.isRoot||mt(this.view.element,i.bladeController.view.element,i.index)}onRackRemove_(i){!i.isRoot||nt(i.bladeController.view.element)}}const oe=M("cnt");class pn{constructor(i,a){var u;this.className_=M((u=a.viewName)!==null&&u!==void 0?u:"fld"),this.element=i.createElement("div"),this.element.classList.add(this.className_(),oe()),a.viewProps.bindClassModifiers(this.element),this.foldable_=a.foldable,this.foldable_.bindExpandedClass(this.element,this.className_(void 0,"expanded")),j(this.foldable_,"completed",Y(this.element,this.className_(void 0,"cpl")));const b=i.createElement("button");b.classList.add(this.className_("b")),j(a.props,"title",Dt=>{m(Dt)?this.element.classList.add(this.className_(void 0,"not")):this.element.classList.remove(this.className_(void 0,"not"))}),a.viewProps.bindDisabled(b),this.element.appendChild(b),this.buttonElement=b;const P=i.createElement("div");P.classList.add(this.className_("i")),this.element.appendChild(P);const B=i.createElement("div");B.classList.add(this.className_("t")),V(a.props.value("title"),B),this.buttonElement.appendChild(B),this.titleElement=B;const it=i.createElement("div");it.classList.add(this.className_("m")),this.buttonElement.appendChild(it);const St=a.containerElement;St.classList.add(this.className_("c")),this.element.appendChild(St),this.containerElement=St}}class sn extends G{constructor(i,a){var u;const b=Nt.create((u=a.expanded)!==null&&u!==void 0?u:!0),P=new Wt(i,{blade:a.blade,root:a.root,viewProps:a.viewProps});super(Object.assign(Object.assign({},a),{rackController:P,view:new pn(i,{containerElement:P.view.element,foldable:b,props:a.props,viewName:a.root?"rot":void 0,viewProps:a.viewProps})})),this.onTitleClick_=this.onTitleClick_.bind(this),this.props=a.props,this.foldable=b,De(this.foldable,this.view.containerElement),this.rackController.rack.emitter.on("add",()=>{this.foldable.cleanUpTransition()}),this.rackController.rack.emitter.on("remove",()=>{this.foldable.cleanUpTransition()}),this.view.buttonElement.addEventListener("click",this.onTitleClick_)}get document(){return this.view.element.ownerDocument}onTitleClick_(){this.foldable.set("expanded",!this.foldable.get("expanded"))}}const Yt={id:"folder",type:"blade",accept(c){const i=at,a=Tt(c,{title:i.required.string,view:i.required.constant("folder"),expanded:i.optional.boolean});return a?{params:a}:null},controller(c){return new sn(c.document,{blade:c.blade,expanded:c.params.expanded,props:X.fromObject({title:c.params.title}),viewProps:c.viewProps})},api(c){return c.controller instanceof sn?new W(c.controller,c.pool):null}};class Me extends Ft{constructor(i,a){const u=a.valueController.viewProps;super(Object.assign(Object.assign({},a),{value:a.valueController.value,view:new lt(i,{props:a.props,viewProps:u}),viewProps:u})),this.props=a.props,this.valueController=a.valueController,this.view.valueElement.appendChild(this.valueController.view.element)}}class ue extends r{}const ze=M("spr");class mi{constructor(i,a){this.element=i.createElement("div"),this.element.classList.add(ze()),a.viewProps.bindClassModifiers(this.element);const u=i.createElement("hr");u.classList.add(ze("r")),this.element.appendChild(u)}}class Oe extends xt{constructor(i,a){super(Object.assign(Object.assign({},a),{view:new mi(i,{viewProps:a.viewProps})}))}}const Ze={id:"separator",type:"blade",accept(c){const a=Tt(c,{view:at.required.constant("separator")});return a?{params:a}:null},controller(c){return new Oe(c.document,{blade:c.blade,viewProps:c.viewProps})},api(c){return c.controller instanceof Oe?new ue(c.controller):null}},de=M("tbi");class Kn{constructor(i,a){this.element=i.createElement("div"),this.element.classList.add(de()),a.viewProps.bindClassModifiers(this.element),j(a.props,"selected",P=>{P?this.element.classList.add(de(void 0,"sel")):this.element.classList.remove(de(void 0,"sel"))});const u=i.createElement("button");u.classList.add(de("b")),a.viewProps.bindDisabled(u),this.element.appendChild(u),this.buttonElement=u;const b=i.createElement("div");b.classList.add(de("t")),V(a.props.value("title"),b),this.buttonElement.appendChild(b),this.titleElement=b}}class Ue{constructor(i,a){this.emitter=new v,this.onClick_=this.onClick_.bind(this),this.props=a.props,this.viewProps=a.viewProps,this.view=new Kn(i,{props:a.props,viewProps:a.viewProps}),this.view.buttonElement.addEventListener("click",this.onClick_)}onClick_(){this.emitter.emit("click",{sender:this})}}class el{constructor(i,a){this.onItemClick_=this.onItemClick_.bind(this),this.ic_=new Ue(i,{props:a.itemProps,viewProps:Ot.create()}),this.ic_.emitter.on("click",this.onItemClick_),this.cc_=new Wt(i,{blade:ft(),viewProps:Ot.create()}),this.props=a.props,j(this.props,"selected",u=>{this.itemController.props.set("selected",u),this.contentController.viewProps.set("hidden",!u)})}get itemController(){return this.ic_}get contentController(){return this.cc_}onItemClick_(){this.props.set("selected",!0)}}class nl{constructor(i,a){this.controller_=i,this.rackApi_=a}get title(){var i;return(i=this.controller_.itemController.props.get("title"))!==null&&i!==void 0?i:""}set title(i){this.controller_.itemController.props.set("title",i)}get selected(){return this.controller_.props.get("selected")}set selected(i){this.controller_.props.set("selected",i)}get children(){return this.rackApi_.children}addButton(i){return this.rackApi_.addButton(i)}addFolder(i){return this.rackApi_.addFolder(i)}addSeparator(i){return this.rackApi_.addSeparator(i)}addTab(i){return this.rackApi_.addTab(i)}add(i,a){this.rackApi_.add(i,a)}remove(i){this.rackApi_.remove(i)}addInput(i,a,u){return this.rackApi_.addInput(i,a,u)}addMonitor(i,a,u){return this.rackApi_.addMonitor(i,a,u)}addBlade(i){return this.rackApi_.addBlade(i)}}class il extends Ie{constructor(i,a){super(i,new z(i.rackController,a)),this.onPageAdd_=this.onPageAdd_.bind(this),this.onPageRemove_=this.onPageRemove_.bind(this),this.onSelect_=this.onSelect_.bind(this),this.emitter_=new v,this.pageApiMap_=new Map,this.rackApi_.on("change",u=>{this.emitter_.emit("change",{event:u})}),this.rackApi_.on("update",u=>{this.emitter_.emit("update",{event:u})}),this.controller_.tab.selectedIndex.emitter.on("change",this.onSelect_),this.controller_.pageSet.emitter.on("add",this.onPageAdd_),this.controller_.pageSet.emitter.on("remove",this.onPageRemove_),this.controller_.pageSet.items.forEach(u=>{this.setUpPageApi_(u)})}get pages(){return this.controller_.pageSet.items.map(i=>{const a=this.pageApiMap_.get(i);if(!a)throw w.shouldNeverHappen();return a})}addPage(i){const a=this.controller_.view.element.ownerDocument,u=new el(a,{itemProps:X.fromObject({selected:!1,title:i.title}),props:X.fromObject({selected:!1})});this.controller_.add(u,i.index);const b=this.pageApiMap_.get(u);if(!b)throw w.shouldNeverHappen();return b}removePage(i){this.controller_.remove(i)}on(i,a){const u=a.bind(this);return this.emitter_.on(i,b=>{u(b.event)}),this}setUpPageApi_(i){const a=this.rackApi_.apiSet_.find(b=>b.controller_===i.contentController);if(!a)throw w.shouldNeverHappen();const u=new nl(i,a);this.pageApiMap_.set(i,u)}onPageAdd_(i){this.setUpPageApi_(i.item)}onPageRemove_(i){if(!this.pageApiMap_.get(i.item))throw w.shouldNeverHappen();this.pageApiMap_.delete(i.item)}onSelect_(i){this.emitter_.emit("select",{event:new p(this,i.rawValue)})}}const rl=-1;class Vu{constructor(){this.onItemSelectedChange_=this.onItemSelectedChange_.bind(this),this.empty=U(!0),this.selectedIndex=U(rl),this.items_=[]}add(i,a){const u=a!=null?a:this.items_.length;this.items_.splice(u,0,i),i.emitter.on("change",this.onItemSelectedChange_),this.keepSelection_()}remove(i){const a=this.items_.indexOf(i);a<0||(this.items_.splice(a,1),i.emitter.off("change",this.onItemSelectedChange_),this.keepSelection_())}keepSelection_(){if(this.items_.length===0){this.selectedIndex.rawValue=rl,this.empty.rawValue=!0;return}const i=this.items_.findIndex(a=>a.rawValue);i<0?(this.items_.forEach((a,u)=>{a.rawValue=u===0}),this.selectedIndex.rawValue=0):(this.items_.forEach((a,u)=>{a.rawValue=u===i}),this.selectedIndex.rawValue=i),this.empty.rawValue=!1}onItemSelectedChange_(i){if(i.rawValue){const a=this.items_.findIndex(u=>u===i.sender);this.items_.forEach((u,b)=>{u.rawValue=b===a}),this.selectedIndex.rawValue=a}else this.keepSelection_()}}const cr=M("tab");class Bu{constructor(i,a){this.element=i.createElement("div"),this.element.classList.add(cr(),oe()),a.viewProps.bindClassModifiers(this.element),k(a.empty,Y(this.element,cr(void 0,"nop")));const u=i.createElement("div");u.classList.add(cr("t")),this.element.appendChild(u),this.itemsElement=u;const b=i.createElement("div");b.classList.add(cr("i")),this.element.appendChild(b);const P=a.contentsElement;P.classList.add(cr("c")),this.element.appendChild(P),this.contentsElement=P}}class sl extends G{constructor(i,a){const u=new Wt(i,{blade:a.blade,viewProps:a.viewProps}),b=new Vu;super({blade:a.blade,rackController:u,view:new Bu(i,{contentsElement:u.view.element,empty:b.empty,viewProps:a.viewProps})}),this.onPageAdd_=this.onPageAdd_.bind(this),this.onPageRemove_=this.onPageRemove_.bind(this),this.pageSet_=new An(()=>null),this.pageSet_.emitter.on("add",this.onPageAdd_),this.pageSet_.emitter.on("remove",this.onPageRemove_),this.tab=b}get pageSet(){return this.pageSet_}add(i,a){this.pageSet_.add(i,a)}remove(i){this.pageSet_.remove(this.pageSet_.items[i])}onPageAdd_(i){const a=i.item;mt(this.view.itemsElement,a.itemController.view.element,i.index),a.itemController.viewProps.set("parent",this.viewProps),this.rackController.rack.add(a.contentController,i.index),this.tab.add(a.props.value("selected"))}onPageRemove_(i){const a=i.item;nt(a.itemController.view.element),a.itemController.viewProps.set("parent",null),this.rackController.rack.remove(a.contentController),this.tab.remove(a.props.value("selected"))}}const ol={id:"tab",type:"blade",accept(c){const i=at,a=Tt(c,{pages:i.required.array(i.required.object({title:i.required.string})),view:i.required.constant("tab")});return!a||a.pages.length===0?null:{params:a}},controller(c){const i=new sl(c.document,{blade:c.blade,viewProps:c.viewProps});return c.params.pages.forEach(a=>{const u=new el(c.document,{itemProps:X.fromObject({selected:!1,title:a.title}),props:X.fromObject({selected:!1})});i.add(u)}),i},api(c){return c.controller instanceof sl?new il(c.controller,c.pool):null}};function zu(c,i){const a=c.accept(i.params);if(!a)return null;const u=at.optional.boolean(i.params.disabled).value,b=at.optional.boolean(i.params.hidden).value;return c.controller({blade:ft(),document:i.document,params:Object.assign(Object.assign({},a.params),{disabled:u,hidden:b}),viewProps:Ot.create({disabled:u,hidden:b})})}class Ou{constructor(){this.disabled=!1,this.emitter=new v}dispose(){}tick(){this.disabled||this.emitter.emit("tick",{sender:this})}}class Uu{constructor(i,a){this.disabled_=!1,this.timerId_=null,this.onTick_=this.onTick_.bind(this),this.doc_=i,this.emitter=new v,this.interval_=a,this.setTimer_()}get disabled(){return this.disabled_}set disabled(i){this.disabled_=i,this.disabled_?this.clearTimer_():this.setTimer_()}dispose(){this.clearTimer_()}clearTimer_(){if(this.timerId_===null)return;const i=this.doc_.defaultView;i&&i.clearInterval(this.timerId_),this.timerId_=null}setTimer_(){if(this.clearTimer_(),this.interval_<=0)return;const i=this.doc_.defaultView;i&&(this.timerId_=i.setInterval(this.onTick_,this.interval_))}onTick_(){this.disabled_||this.emitter.emit("tick",{sender:this})}}class Hu{constructor(i){this.onValueChange_=this.onValueChange_.bind(this),this.reader=i.reader,this.writer=i.writer,this.emitter=new v,this.value=i.value,this.value.emitter.on("change",this.onValueChange_),this.target=i.target,this.read()}read(){const i=this.target.read();i!==void 0&&(this.value.rawValue=this.reader(i))}write_(i){this.writer(this.target,i)}onValueChange_(i){this.write_(i.rawValue),this.emitter.emit("change",{options:i.options,rawValue:i.rawValue,sender:this})}}function al(c,i){for(;c.length<i;)c.push(void 0)}function Gu(c){const i=[];return al(i,c),U(i)}function Wu(c){const i=c.indexOf(void 0);return i<0?c:c.slice(0,i)}function qu(c,i){const a=[...Wu(c),i];return a.length>c.length?a.splice(0,a.length-c.length):al(a,c.length),a}class ju{constructor(i){this.onTick_=this.onTick_.bind(this),this.reader_=i.reader,this.target=i.target,this.emitter=new v,this.value=i.value,this.ticker=i.ticker,this.ticker.emitter.on("tick",this.onTick_),this.read()}dispose(){this.ticker.dispose()}read(){const i=this.target.read();if(i===void 0)return;const a=this.value.rawValue,u=this.reader_(i);this.value.rawValue=qu(a,u),this.emitter.emit("update",{rawValue:u,sender:this})}onTick_(i){this.read()}}class hr{constructor(i){this.constraints=i}constrain(i){return this.constraints.reduce((a,u)=>u.constrain(a),i)}}function fn(c,i){if(c instanceof i)return c;if(c instanceof hr){const a=c.constraints.reduce((u,b)=>u||(b instanceof i?b:null),null);if(a)return a}return null}class gi{constructor(i){this.values=X.fromObject({max:i.max,min:i.min})}constrain(i){const a=this.values.get("max"),u=this.values.get("min");return Math.min(Math.max(i,u),a)}}class ur{constructor(i){this.values=X.fromObject({options:i})}get options(){return this.values.get("options")}constrain(i){const a=this.values.get("options");return a.length===0||a.filter(b=>b.value===i).length>0?i:a[0].value}}class ll{constructor(i){this.values=X.fromObject({max:i.max,min:i.min})}get maxValue(){return this.values.get("max")}get minValue(){return this.values.get("min")}constrain(i){const a=this.values.get("max"),u=this.values.get("min");let b=i;return m(u)||(b=Math.max(b,u)),m(a)||(b=Math.min(b,a)),b}}class ts{constructor(i,a=0){this.step=i,this.origin=a}constrain(i){const a=this.origin%this.step,u=Math.round((i-a)/this.step);return a+u*this.step}}const ho=M("lst");class Xu{constructor(i,a){this.onValueChange_=this.onValueChange_.bind(this),this.props_=a.props,this.element=i.createElement("div"),this.element.classList.add(ho()),a.viewProps.bindClassModifiers(this.element);const u=i.createElement("select");u.classList.add(ho("s")),j(this.props_,"options",P=>{It(u),P.forEach((B,it)=>{const St=i.createElement("option");St.dataset.index=String(it),St.textContent=B.text,St.value=String(B.value),u.appendChild(St)})}),a.viewProps.bindDisabled(u),this.element.appendChild(u),this.selectElement=u;const b=i.createElement("div");b.classList.add(ho("m")),b.appendChild(et(i,"dropdown")),this.element.appendChild(b),a.value.emitter.on("change",this.onValueChange_),this.value_=a.value,this.update_()}update_(){this.selectElement.value=String(this.value_.rawValue)}onValueChange_(){this.update_()}}class dr{constructor(i,a){this.onSelectChange_=this.onSelectChange_.bind(this),this.props=a.props,this.value=a.value,this.viewProps=a.viewProps,this.view=new Xu(i,{props:this.props,value:this.value,viewProps:this.viewProps}),this.view.selectElement.addEventListener("change",this.onSelectChange_)}onSelectChange_(i){const u=i.currentTarget.selectedOptions.item(0);if(!u)return;const b=Number(u.dataset.index);this.value.rawValue=this.props.get("options")[b].value}}const cl=M("pop");class $u{constructor(i,a){this.element=i.createElement("div"),this.element.classList.add(cl()),a.viewProps.bindClassModifiers(this.element),k(a.shows,Y(this.element,cl(void 0,"v")))}}class hl{constructor(i,a){this.shows=U(!1),this.viewProps=a.viewProps,this.view=new $u(i,{shows:this.shows,viewProps:this.viewProps})}}const ul=M("txt");class Yu{constructor(i,a){this.onChange_=this.onChange_.bind(this),this.element=i.createElement("div"),this.element.classList.add(ul()),a.viewProps.bindClassModifiers(this.element),this.props_=a.props,this.props_.emitter.on("change",this.onChange_);const u=i.createElement("input");u.classList.add(ul("i")),u.type="text",a.viewProps.bindDisabled(u),this.element.appendChild(u),this.inputElement=u,a.value.emitter.on("change",this.onChange_),this.value_=a.value,this.refresh()}refresh(){const i=this.props_.get("formatter");this.inputElement.value=i(this.value_.rawValue)}onChange_(){this.refresh()}}class es{constructor(i,a){this.onInputChange_=this.onInputChange_.bind(this),this.parser_=a.parser,this.props=a.props,this.value=a.value,this.viewProps=a.viewProps,this.view=new Yu(i,{props:a.props,value:this.value,viewProps:this.viewProps}),this.view.inputElement.addEventListener("change",this.onInputChange_)}onInputChange_(i){const u=i.currentTarget.value,b=this.parser_(u);m(b)||(this.value.rawValue=b),this.view.refresh()}}function Ju(c){return String(c)}function dl(c){return c==="false"?!1:!!c}function pl(c){return Ju(c)}class Zu{constructor(i){this.text=i}evaluate(){return Number(this.text)}toString(){return this.text}}const Ku={"**":(c,i)=>Math.pow(c,i),"*":(c,i)=>c*i,"/":(c,i)=>c/i,"%":(c,i)=>c%i,"+":(c,i)=>c+i,"-":(c,i)=>c-i,"<<":(c,i)=>c<<i,">>":(c,i)=>c>>i,">>>":(c,i)=>c>>>i,"&":(c,i)=>c&i,"^":(c,i)=>c^i,"|":(c,i)=>c|i};class Qu{constructor(i,a,u){this.left=a,this.operator=i,this.right=u}evaluate(){const i=Ku[this.operator];if(!i)throw new Error(`unexpected binary operator: '${this.operator}`);return i(this.left.evaluate(),this.right.evaluate())}toString(){return["b(",this.left.toString(),this.operator,this.right.toString(),")"].join(" ")}}const td={"+":c=>c,"-":c=>-c,"~":c=>~c};class ed{constructor(i,a){this.operator=i,this.expression=a}evaluate(){const i=td[this.operator];if(!i)throw new Error(`unexpected unary operator: '${this.operator}`);return i(this.expression.evaluate())}toString(){return["u(",this.operator,this.expression.toString(),")"].join(" ")}}function uo(c){return(i,a)=>{for(let u=0;u<c.length;u++){const b=c[u](i,a);if(b!=="")return b}return""}}function pr(c,i){var a;const u=c.substr(i).match(/^\s+/);return(a=u&&u[0])!==null&&a!==void 0?a:""}function nd(c,i){const a=c.substr(i,1);return a.match(/^[1-9]$/)?a:""}function fr(c,i){var a;const u=c.substr(i).match(/^[0-9]+/);return(a=u&&u[0])!==null&&a!==void 0?a:""}function id(c,i){const a=fr(c,i);if(a!=="")return a;const u=c.substr(i,1);if(i+=1,u!=="-"&&u!=="+")return"";const b=fr(c,i);return b===""?"":u+b}function po(c,i){const a=c.substr(i,1);if(i+=1,a.toLowerCase()!=="e")return"";const u=id(c,i);return u===""?"":a+u}function fl(c,i){const a=c.substr(i,1);if(a==="0")return a;const u=nd(c,i);return i+=u.length,u===""?"":u+fr(c,i)}function rd(c,i){const a=fl(c,i);if(i+=a.length,a==="")return"";const u=c.substr(i,1);if(i+=u.length,u!==".")return"";const b=fr(c,i);return i+=b.length,a+u+b+po(c,i)}function sd(c,i){const a=c.substr(i,1);if(i+=a.length,a!==".")return"";const u=fr(c,i);return i+=u.length,u===""?"":a+u+po(c,i)}function od(c,i){const a=fl(c,i);return i+=a.length,a===""?"":a+po(c,i)}const ad=uo([rd,sd,od]);function ld(c,i){var a;const u=c.substr(i).match(/^[01]+/);return(a=u&&u[0])!==null&&a!==void 0?a:""}function cd(c,i){const a=c.substr(i,2);if(i+=a.length,a.toLowerCase()!=="0b")return"";const u=ld(c,i);return u===""?"":a+u}function hd(c,i){var a;const u=c.substr(i).match(/^[0-7]+/);return(a=u&&u[0])!==null&&a!==void 0?a:""}function ud(c,i){const a=c.substr(i,2);if(i+=a.length,a.toLowerCase()!=="0o")return"";const u=hd(c,i);return u===""?"":a+u}function dd(c,i){var a;const u=c.substr(i).match(/^[0-9a-f]+/i);return(a=u&&u[0])!==null&&a!==void 0?a:""}function pd(c,i){const a=c.substr(i,2);if(i+=a.length,a.toLowerCase()!=="0x")return"";const u=dd(c,i);return u===""?"":a+u}const fd=uo([cd,ud,pd]),md=uo([fd,ad]);function gd(c,i){const a=md(c,i);return i+=a.length,a===""?null:{evaluable:new Zu(a),cursor:i}}function vd(c,i){const a=c.substr(i,1);if(i+=a.length,a!=="(")return null;const u=gl(c,i);if(!u)return null;i=u.cursor,i+=pr(c,i).length;const b=c.substr(i,1);return i+=b.length,b!==")"?null:{evaluable:u.evaluable,cursor:i}}function _d(c,i){var a;return(a=gd(c,i))!==null&&a!==void 0?a:vd(c,i)}function ml(c,i){const a=_d(c,i);if(a)return a;const u=c.substr(i,1);if(i+=u.length,u!=="+"&&u!=="-"&&u!=="~")return null;const b=ml(c,i);return b?(i=b.cursor,{cursor:i,evaluable:new ed(u,b.evaluable)}):null}function xd(c,i,a){a+=pr(i,a).length;const u=c.filter(b=>i.startsWith(b,a))[0];return u?(a+=u.length,a+=pr(i,a).length,{cursor:a,operator:u}):null}function bd(c,i){return(a,u)=>{const b=c(a,u);if(!b)return null;u=b.cursor;let P=b.evaluable;for(;;){const B=xd(i,a,u);if(!B)break;u=B.cursor;const it=c(a,u);if(!it)return null;u=it.cursor,P=new Qu(B.operator,P,it.evaluable)}return P?{cursor:u,evaluable:P}:null}}const yd=[["**"],["*","/","%"],["+","-"],["<<",">>>",">>"],["&"],["^"],["|"]].reduce((c,i)=>bd(c,i),ml);function gl(c,i){return i+=pr(c,i).length,yd(c,i)}function wd(c){const i=gl(c,0);return!i||i.cursor+pr(c,i.cursor).length!==c.length?null:i.evaluable}function mn(c){var i;const a=wd(c);return(i=a==null?void 0:a.evaluate())!==null&&i!==void 0?i:null}function vl(c){if(typeof c=="number")return c;if(typeof c=="string"){const i=mn(c);if(!m(i))return i}return 0}function Md(c){return String(c)}function Se(c){return i=>i.toFixed(Math.max(Math.min(c,20),0))}const Sd=Se(0);function ns(c){return Sd(c)+"%"}function _l(c){return String(c)}function fo(c){return c}function mr({primary:c,secondary:i,forward:a,backward:u}){let b=!1;function P(B){b||(b=!0,B(),b=!1)}c.emitter.on("change",B=>{P(()=>{i.setRawValue(a(c,i),B.options)})}),i.emitter.on("change",B=>{P(()=>{c.setRawValue(u(c,i),B.options)}),P(()=>{i.setRawValue(a(c,i),B.options)})}),P(()=>{i.setRawValue(a(c,i),{forceEmit:!1,last:!0})})}function Fe(c,i){const a=c*(i.altKey?.1:1)*(i.shiftKey?10:1);return i.upKey?+a:i.downKey?-a:0}function gr(c){return{altKey:c.altKey,downKey:c.key==="ArrowDown",shiftKey:c.shiftKey,upKey:c.key==="ArrowUp"}}function gn(c){return{altKey:c.altKey,downKey:c.key==="ArrowLeft",shiftKey:c.shiftKey,upKey:c.key==="ArrowRight"}}function Ed(c){return c==="ArrowUp"||c==="ArrowDown"}function xl(c){return Ed(c)||c==="ArrowLeft"||c==="ArrowRight"}function mo(c,i){var a,u;const b=i.ownerDocument.defaultView,P=i.getBoundingClientRect();return{x:c.pageX-(((a=b&&b.scrollX)!==null&&a!==void 0?a:0)+P.left),y:c.pageY-(((u=b&&b.scrollY)!==null&&u!==void 0?u:0)+P.top)}}class Qn{constructor(i){this.lastTouch_=null,this.onDocumentMouseMove_=this.onDocumentMouseMove_.bind(this),this.onDocumentMouseUp_=this.onDocumentMouseUp_.bind(this),this.onMouseDown_=this.onMouseDown_.bind(this),this.onTouchEnd_=this.onTouchEnd_.bind(this),this.onTouchMove_=this.onTouchMove_.bind(this),this.onTouchStart_=this.onTouchStart_.bind(this),this.elem_=i,this.emitter=new v,i.addEventListener("touchstart",this.onTouchStart_,{passive:!1}),i.addEventListener("touchmove",this.onTouchMove_,{passive:!0}),i.addEventListener("touchend",this.onTouchEnd_),i.addEventListener("mousedown",this.onMouseDown_)}computePosition_(i){const a=this.elem_.getBoundingClientRect();return{bounds:{width:a.width,height:a.height},point:i?{x:i.x,y:i.y}:null}}onMouseDown_(i){var a;i.preventDefault(),(a=i.currentTarget)===null||a===void 0||a.focus();const u=this.elem_.ownerDocument;u.addEventListener("mousemove",this.onDocumentMouseMove_),u.addEventListener("mouseup",this.onDocumentMouseUp_),this.emitter.emit("down",{altKey:i.altKey,data:this.computePosition_(mo(i,this.elem_)),sender:this,shiftKey:i.shiftKey})}onDocumentMouseMove_(i){this.emitter.emit("move",{altKey:i.altKey,data:this.computePosition_(mo(i,this.elem_)),sender:this,shiftKey:i.shiftKey})}onDocumentMouseUp_(i){const a=this.elem_.ownerDocument;a.removeEventListener("mousemove",this.onDocumentMouseMove_),a.removeEventListener("mouseup",this.onDocumentMouseUp_),this.emitter.emit("up",{altKey:i.altKey,data:this.computePosition_(mo(i,this.elem_)),sender:this,shiftKey:i.shiftKey})}onTouchStart_(i){i.preventDefault();const a=i.targetTouches.item(0),u=this.elem_.getBoundingClientRect();this.emitter.emit("down",{altKey:i.altKey,data:this.computePosition_(a?{x:a.clientX-u.left,y:a.clientY-u.top}:void 0),sender:this,shiftKey:i.shiftKey}),this.lastTouch_=a}onTouchMove_(i){const a=i.targetTouches.item(0),u=this.elem_.getBoundingClientRect();this.emitter.emit("move",{altKey:i.altKey,data:this.computePosition_(a?{x:a.clientX-u.left,y:a.clientY-u.top}:void 0),sender:this,shiftKey:i.shiftKey}),this.lastTouch_=a}onTouchEnd_(i){var a;const u=(a=i.targetTouches.item(0))!==null&&a!==void 0?a:this.lastTouch_,b=this.elem_.getBoundingClientRect();this.emitter.emit("up",{altKey:i.altKey,data:this.computePosition_(u?{x:u.clientX-b.left,y:u.clientY-b.top}:void 0),sender:this,shiftKey:i.shiftKey})}}function ae(c,i,a,u,b){const P=(c-i)/(a-i);return u+P*(b-u)}function bl(c){return String(c.toFixed(10)).split(".")[1].replace(/0+$/,"").length}function me(c,i,a){return Math.min(Math.max(c,i),a)}function yl(c,i){return(c%i+i)%i}const je=M("txt");class Td{constructor(i,a){this.onChange_=this.onChange_.bind(this),this.props_=a.props,this.props_.emitter.on("change",this.onChange_),this.element=i.createElement("div"),this.element.classList.add(je(),je(void 0,"num")),a.arrayPosition&&this.element.classList.add(je(void 0,a.arrayPosition)),a.viewProps.bindClassModifiers(this.element);const u=i.createElement("input");u.classList.add(je("i")),u.type="text",a.viewProps.bindDisabled(u),this.element.appendChild(u),this.inputElement=u,this.onDraggingChange_=this.onDraggingChange_.bind(this),this.dragging_=a.dragging,this.dragging_.emitter.on("change",this.onDraggingChange_),this.element.classList.add(je()),this.inputElement.classList.add(je("i"));const b=i.createElement("div");b.classList.add(je("k")),this.element.appendChild(b),this.knobElement=b;const P=i.createElementNS(ht,"svg");P.classList.add(je("g")),this.knobElement.appendChild(P);const B=i.createElementNS(ht,"path");B.classList.add(je("gb")),P.appendChild(B),this.guideBodyElem_=B;const it=i.createElementNS(ht,"path");it.classList.add(je("gh")),P.appendChild(it),this.guideHeadElem_=it;const St=i.createElement("div");St.classList.add(M("tt")()),this.knobElement.appendChild(St),this.tooltipElem_=St,a.value.emitter.on("change",this.onChange_),this.value=a.value,this.refresh()}onDraggingChange_(i){if(i.rawValue===null){this.element.classList.remove(je(void 0,"drg"));return}this.element.classList.add(je(void 0,"drg"));const a=i.rawValue/this.props_.get("draggingScale"),u=a+(a>0?-1:a<0?1:0),b=me(-u,-4,4);this.guideHeadElem_.setAttributeNS(null,"d",[`M ${u+b},0 L${u},4 L${u+b},8`,`M ${a},-1 L${a},9`].join(" ")),this.guideBodyElem_.setAttributeNS(null,"d",`M 0,4 L${a},4`);const P=this.props_.get("formatter");this.tooltipElem_.textContent=P(this.value.rawValue),this.tooltipElem_.style.left=`${a}px`}refresh(){const i=this.props_.get("formatter");this.inputElement.value=i(this.value.rawValue)}onChange_(){this.refresh()}}class vr{constructor(i,a){var u;this.originRawValue_=0,this.onInputChange_=this.onInputChange_.bind(this),this.onInputKeyDown_=this.onInputKeyDown_.bind(this),this.onInputKeyUp_=this.onInputKeyUp_.bind(this),this.onPointerDown_=this.onPointerDown_.bind(this),this.onPointerMove_=this.onPointerMove_.bind(this),this.onPointerUp_=this.onPointerUp_.bind(this),this.baseStep_=a.baseStep,this.parser_=a.parser,this.props=a.props,this.sliderProps_=(u=a.sliderProps)!==null&&u!==void 0?u:null,this.value=a.value,this.viewProps=a.viewProps,this.dragging_=U(null),this.view=new Td(i,{arrayPosition:a.arrayPosition,dragging:this.dragging_,props:this.props,value:this.value,viewProps:this.viewProps}),this.view.inputElement.addEventListener("change",this.onInputChange_),this.view.inputElement.addEventListener("keydown",this.onInputKeyDown_),this.view.inputElement.addEventListener("keyup",this.onInputKeyUp_);const b=new Qn(this.view.knobElement);b.emitter.on("down",this.onPointerDown_),b.emitter.on("move",this.onPointerMove_),b.emitter.on("up",this.onPointerUp_)}constrainValue_(i){var a,u;const b=(a=this.sliderProps_)===null||a===void 0?void 0:a.get("minValue"),P=(u=this.sliderProps_)===null||u===void 0?void 0:u.get("maxValue");let B=i;return b!==void 0&&(B=Math.max(B,b)),P!==void 0&&(B=Math.min(B,P)),B}onInputChange_(i){const u=i.currentTarget.value,b=this.parser_(u);m(b)||(this.value.rawValue=this.constrainValue_(b)),this.view.refresh()}onInputKeyDown_(i){const a=Fe(this.baseStep_,gr(i));a!==0&&this.value.setRawValue(this.constrainValue_(this.value.rawValue+a),{forceEmit:!1,last:!1})}onInputKeyUp_(i){Fe(this.baseStep_,gr(i))!==0&&this.value.setRawValue(this.value.rawValue,{forceEmit:!0,last:!0})}onPointerDown_(){this.originRawValue_=this.value.rawValue,this.dragging_.rawValue=0}computeDraggingValue_(i){if(!i.point)return null;const a=i.point.x-i.bounds.width/2;return this.constrainValue_(this.originRawValue_+a*this.props.get("draggingScale"))}onPointerMove_(i){const a=this.computeDraggingValue_(i.data);a!==null&&(this.value.setRawValue(a,{forceEmit:!1,last:!1}),this.dragging_.rawValue=this.value.rawValue-this.originRawValue_)}onPointerUp_(i){const a=this.computeDraggingValue_(i.data);a!==null&&(this.value.setRawValue(a,{forceEmit:!0,last:!0}),this.dragging_.rawValue=null)}}const go=M("sld");class Cd{constructor(i,a){this.onChange_=this.onChange_.bind(this),this.props_=a.props,this.props_.emitter.on("change",this.onChange_),this.element=i.createElement("div"),this.element.classList.add(go()),a.viewProps.bindClassModifiers(this.element);const u=i.createElement("div");u.classList.add(go("t")),a.viewProps.bindTabIndex(u),this.element.appendChild(u),this.trackElement=u;const b=i.createElement("div");b.classList.add(go("k")),this.trackElement.appendChild(b),this.knobElement=b,a.value.emitter.on("change",this.onChange_),this.value=a.value,this.update_()}update_(){const i=me(ae(this.value.rawValue,this.props_.get("minValue"),this.props_.get("maxValue"),0,100),0,100);this.knobElement.style.width=`${i}%`}onChange_(){this.update_()}}class Ad{constructor(i,a){this.onKeyDown_=this.onKeyDown_.bind(this),this.onKeyUp_=this.onKeyUp_.bind(this),this.onPointerDownOrMove_=this.onPointerDownOrMove_.bind(this),this.onPointerUp_=this.onPointerUp_.bind(this),this.baseStep_=a.baseStep,this.value=a.value,this.viewProps=a.viewProps,this.props=a.props,this.view=new Cd(i,{props:this.props,value:this.value,viewProps:this.viewProps}),this.ptHandler_=new Qn(this.view.trackElement),this.ptHandler_.emitter.on("down",this.onPointerDownOrMove_),this.ptHandler_.emitter.on("move",this.onPointerDownOrMove_),this.ptHandler_.emitter.on("up",this.onPointerUp_),this.view.trackElement.addEventListener("keydown",this.onKeyDown_),this.view.trackElement.addEventListener("keyup",this.onKeyUp_)}handlePointerEvent_(i,a){!i.point||this.value.setRawValue(ae(me(i.point.x,0,i.bounds.width),0,i.bounds.width,this.props.get("minValue"),this.props.get("maxValue")),a)}onPointerDownOrMove_(i){this.handlePointerEvent_(i.data,{forceEmit:!1,last:!1})}onPointerUp_(i){this.handlePointerEvent_(i.data,{forceEmit:!0,last:!0})}onKeyDown_(i){const a=Fe(this.baseStep_,gn(i));a!==0&&this.value.setRawValue(this.value.rawValue+a,{forceEmit:!1,last:!1})}onKeyUp_(i){Fe(this.baseStep_,gn(i))!==0&&this.value.setRawValue(this.value.rawValue,{forceEmit:!0,last:!0})}}const vo=M("sldtxt");class Pd{constructor(i,a){this.element=i.createElement("div"),this.element.classList.add(vo());const u=i.createElement("div");u.classList.add(vo("s")),this.sliderView_=a.sliderView,u.appendChild(this.sliderView_.element),this.element.appendChild(u);const b=i.createElement("div");b.classList.add(vo("t")),this.textView_=a.textView,b.appendChild(this.textView_.element),this.element.appendChild(b)}}class _o{constructor(i,a){this.value=a.value,this.viewProps=a.viewProps,this.sliderC_=new Ad(i,{baseStep:a.baseStep,props:a.sliderProps,value:a.value,viewProps:this.viewProps}),this.textC_=new vr(i,{baseStep:a.baseStep,parser:a.parser,props:a.textProps,sliderProps:a.sliderProps,value:a.value,viewProps:a.viewProps}),this.view=new Pd(i,{sliderView:this.sliderC_.view,textView:this.textC_.view})}get sliderController(){return this.sliderC_}get textController(){return this.textC_}}function _r(c,i){c.write(i)}function is(c){const i=at;if(Array.isArray(c))return i.required.array(i.required.object({text:i.required.string,value:i.required.raw}))(c).value;if(typeof c=="object")return i.required.raw(c).value}function wl(c){if(c==="inline"||c==="popup")return c}function Pn(c){const i=at;return i.required.object({max:i.optional.number,min:i.optional.number,step:i.optional.number})(c).value}function Ml(c){if(Array.isArray(c))return c;const i=[];return Object.keys(c).forEach(a=>{i.push({text:a,value:c[a]})}),i}function xo(c){return m(c)?null:new ur(Ml(c))}function Ld(c){const i=c?fn(c,ts):null;return i?i.step:null}function rs(c,i){const a=c&&fn(c,ts);return a?bl(a.step):Math.max(bl(i),2)}function vi(c){const i=Ld(c);return i!=null?i:1}function _i(c,i){var a;const u=c&&fn(c,ts),b=Math.abs((a=u==null?void 0:u.step)!==null&&a!==void 0?a:i);return b===0?.1:Math.pow(10,Math.floor(Math.log10(b))-1)}const ss=M("ckb");class Rd{constructor(i,a){this.onValueChange_=this.onValueChange_.bind(this),this.element=i.createElement("div"),this.element.classList.add(ss()),a.viewProps.bindClassModifiers(this.element);const u=i.createElement("label");u.classList.add(ss("l")),this.element.appendChild(u);const b=i.createElement("input");b.classList.add(ss("i")),b.type="checkbox",u.appendChild(b),this.inputElement=b,a.viewProps.bindDisabled(this.inputElement);const P=i.createElement("div");P.classList.add(ss("w")),u.appendChild(P);const B=et(i,"check");P.appendChild(B),a.value.emitter.on("change",this.onValueChange_),this.value=a.value,this.update_()}update_(){this.inputElement.checked=this.value.rawValue}onValueChange_(){this.update_()}}class Dd{constructor(i,a){this.onInputChange_=this.onInputChange_.bind(this),this.value=a.value,this.viewProps=a.viewProps,this.view=new Rd(i,{value:this.value,viewProps:this.viewProps}),this.view.inputElement.addEventListener("change",this.onInputChange_)}onInputChange_(i){const a=i.currentTarget;this.value.rawValue=a.checked}}function Id(c){const i=[],a=xo(c.options);return a&&i.push(a),new hr(i)}const Nd={id:"input-bool",type:"input",accept:(c,i)=>{if(typeof c!="boolean")return null;const u=Tt(i,{options:at.optional.custom(is)});return u?{initialValue:c,params:u}:null},binding:{reader:c=>dl,constraint:c=>Id(c.params),writer:c=>_r},controller:c=>{const i=c.document,a=c.value,u=c.constraint,b=u&&fn(u,ur);return b?new dr(i,{props:new X({options:b.values.value("options")}),value:a,viewProps:c.viewProps}):new Dd(i,{value:a,viewProps:c.viewProps})}},ti=M("col");class Fd{constructor(i,a){this.element=i.createElement("div"),this.element.classList.add(ti()),a.foldable.bindExpandedClass(this.element,ti(void 0,"expanded")),j(a.foldable,"completed",Y(this.element,ti(void 0,"cpl")));const u=i.createElement("div");u.classList.add(ti("h")),this.element.appendChild(u);const b=i.createElement("div");b.classList.add(ti("s")),u.appendChild(b),this.swatchElement=b;const P=i.createElement("div");if(P.classList.add(ti("t")),u.appendChild(P),this.textElement=P,a.pickerLayout==="inline"){const B=i.createElement("div");B.classList.add(ti("p")),this.element.appendChild(B),this.pickerElement=B}else this.pickerElement=null}}function kd(c,i,a){const u=me(c/255,0,1),b=me(i/255,0,1),P=me(a/255,0,1),B=Math.max(u,b,P),it=Math.min(u,b,P),St=B-it;let Dt=0,Jt=0;const Kt=(it+B)/2;return St!==0&&(Jt=St/(1-Math.abs(B+it-1)),u===B?Dt=(b-P)/St:b===B?Dt=2+(P-u)/St:Dt=4+(u-b)/St,Dt=Dt/6+(Dt<0?1:0)),[Dt*360,Jt*100,Kt*100]}function Vd(c,i,a){const u=(c%360+360)%360,b=me(i/100,0,1),P=me(a/100,0,1),B=(1-Math.abs(2*P-1))*b,it=B*(1-Math.abs(u/60%2-1)),St=P-B/2;let Dt,Jt,Kt;return u>=0&&u<60?[Dt,Jt,Kt]=[B,it,0]:u>=60&&u<120?[Dt,Jt,Kt]=[it,B,0]:u>=120&&u<180?[Dt,Jt,Kt]=[0,B,it]:u>=180&&u<240?[Dt,Jt,Kt]=[0,it,B]:u>=240&&u<300?[Dt,Jt,Kt]=[it,0,B]:[Dt,Jt,Kt]=[B,0,it],[(Dt+St)*255,(Jt+St)*255,(Kt+St)*255]}function Bd(c,i,a){const u=me(c/255,0,1),b=me(i/255,0,1),P=me(a/255,0,1),B=Math.max(u,b,P),it=Math.min(u,b,P),St=B-it;let Dt;St===0?Dt=0:B===u?Dt=60*(((b-P)/St%6+6)%6):B===b?Dt=60*((P-u)/St+2):Dt=60*((u-b)/St+4);const Jt=B===0?0:St/B,Kt=B;return[Dt,Jt*100,Kt*100]}function Sl(c,i,a){const u=yl(c,360),b=me(i/100,0,1),P=me(a/100,0,1),B=P*b,it=B*(1-Math.abs(u/60%2-1)),St=P-B;let Dt,Jt,Kt;return u>=0&&u<60?[Dt,Jt,Kt]=[B,it,0]:u>=60&&u<120?[Dt,Jt,Kt]=[it,B,0]:u>=120&&u<180?[Dt,Jt,Kt]=[0,B,it]:u>=180&&u<240?[Dt,Jt,Kt]=[0,it,B]:u>=240&&u<300?[Dt,Jt,Kt]=[it,0,B]:[Dt,Jt,Kt]=[B,0,it],[(Dt+St)*255,(Jt+St)*255,(Kt+St)*255]}function zd(c,i,a){const u=a+i*(100-Math.abs(2*a-100))/200;return[c,u!==0?i*(100-Math.abs(2*a-100))/u:0,a+i*(100-Math.abs(2*a-100))/(2*100)]}function Od(c,i,a){const u=100-Math.abs(a*(200-i)/100-100);return[c,u!==0?i*a/u:0,a*(200-i)/(2*100)]}function ei(c){return[c[0],c[1],c[2]]}function El(c,i){return[c[0],c[1],c[2],i]}const Ud={hsl:{hsl:(c,i,a)=>[c,i,a],hsv:zd,rgb:Vd},hsv:{hsl:Od,hsv:(c,i,a)=>[c,i,a],rgb:Sl},rgb:{hsl:kd,hsv:Bd,rgb:(c,i,a)=>[c,i,a]}};function os(c,i){return[i==="float"?1:c==="rgb"?255:360,i==="float"?1:c==="rgb"?255:100,i==="float"?1:c==="rgb"?255:100]}function Hd(c,i){return c===i?i:yl(c,i)}function Gd(c,i,a){var u;const b=os(i,a);return[i==="rgb"?me(c[0],0,b[0]):Hd(c[0],b[0]),me(c[1],0,b[1]),me(c[2],0,b[2]),me((u=c[3])!==null&&u!==void 0?u:1,0,1)]}function Tl(c,i,a,u){const b=os(i,a),P=os(i,u);return c.map((B,it)=>B/b[it]*P[it])}function Wd(c,i,a){const u=Tl(c,i.mode,i.type,"int"),b=Ud[i.mode][a.mode](...u);return Tl(b,a.mode,"int",a.type)}function as(c,i){return typeof c!="object"||m(c)?!1:i in c&&typeof c[i]=="number"}class qt{static black(i="int"){return new qt([0,0,0],"rgb",i)}static fromObject(i,a="int"){const u="a"in i?[i.r,i.g,i.b,i.a]:[i.r,i.g,i.b];return new qt(u,"rgb",a)}static toRgbaObject(i,a="int"){return i.toRgbaObject(a)}static isRgbColorObject(i){return as(i,"r")&&as(i,"g")&&as(i,"b")}static isRgbaColorObject(i){return this.isRgbColorObject(i)&&as(i,"a")}static isColorObject(i){return this.isRgbColorObject(i)}static equals(i,a){if(i.mode!==a.mode)return!1;const u=i.comps_,b=a.comps_;for(let P=0;P<u.length;P++)if(u[P]!==b[P])return!1;return!0}constructor(i,a,u="int"){this.mode=a,this.type=u,this.comps_=Gd(i,a,u)}getComponents(i,a="int"){return El(Wd(ei(this.comps_),{mode:this.mode,type:this.type},{mode:i!=null?i:this.mode,type:a}),this.comps_[3])}toRgbaObject(i="int"){const a=this.getComponents("rgb",i);return{r:a[0],g:a[1],b:a[2],a:a[3]}}}const Ln=M("colp");class qd{constructor(i,a){this.alphaViews_=null,this.element=i.createElement("div"),this.element.classList.add(Ln()),a.viewProps.bindClassModifiers(this.element);const u=i.createElement("div");u.classList.add(Ln("hsv"));const b=i.createElement("div");b.classList.add(Ln("sv")),this.svPaletteView_=a.svPaletteView,b.appendChild(this.svPaletteView_.element),u.appendChild(b);const P=i.createElement("div");P.classList.add(Ln("h")),this.hPaletteView_=a.hPaletteView,P.appendChild(this.hPaletteView_.element),u.appendChild(P),this.element.appendChild(u);const B=i.createElement("div");if(B.classList.add(Ln("rgb")),this.textView_=a.textView,B.appendChild(this.textView_.element),this.element.appendChild(B),a.alphaViews){this.alphaViews_={palette:a.alphaViews.palette,text:a.alphaViews.text};const it=i.createElement("div");it.classList.add(Ln("a"));const St=i.createElement("div");St.classList.add(Ln("ap")),St.appendChild(this.alphaViews_.palette.element),it.appendChild(St);const Dt=i.createElement("div");Dt.classList.add(Ln("at")),Dt.appendChild(this.alphaViews_.text.element),it.appendChild(Dt),this.element.appendChild(it)}}get allFocusableElements(){const i=[this.svPaletteView_.element,this.hPaletteView_.element,this.textView_.modeSelectElement,...this.textView_.textViews.map(a=>a.inputElement)];return this.alphaViews_&&i.push(this.alphaViews_.palette.element,this.alphaViews_.text.inputElement),i}}function jd(c){return c==="int"?"int":c==="float"?"float":void 0}function bo(c){const i=at;return Tt(c,{alpha:i.optional.boolean,color:i.optional.object({alpha:i.optional.boolean,type:i.optional.custom(jd)}),expanded:i.optional.boolean,picker:i.optional.custom(wl)})}function ni(c){return c?.1:1}function ii(c){var i;return(i=c.color)===null||i===void 0?void 0:i.type}function Xd(c,i){return c.alpha===i.alpha&&c.mode===i.mode&&c.notation===i.notation&&c.type===i.type}function Xe(c,i){const a=c.match(/^(.+)%$/);return Math.min(a?parseFloat(a[1])*.01*i:parseFloat(c),i)}const $d={deg:c=>c,grad:c=>c*360/400,rad:c=>c*360/(2*Math.PI),turn:c=>c*360};function Cl(c){const i=c.match(/^([0-9.]+?)(deg|grad|rad|turn)$/);if(!i)return parseFloat(c);const a=parseFloat(i[1]),u=i[2];return $d[u](a)}function Al(c){const i=c.match(/^rgb\(\s*([0-9A-Fa-f.]+%?)\s*,\s*([0-9A-Fa-f.]+%?)\s*,\s*([0-9A-Fa-f.]+%?)\s*\)$/);if(!i)return null;const a=[Xe(i[1],255),Xe(i[2],255),Xe(i[3],255)];return isNaN(a[0])||isNaN(a[1])||isNaN(a[2])?null:a}function Pl(c){return i=>{const a=Al(i);return a?new qt(a,"rgb",c):null}}function Ll(c){const i=c.match(/^rgba\(\s*([0-9A-Fa-f.]+%?)\s*,\s*([0-9A-Fa-f.]+%?)\s*,\s*([0-9A-Fa-f.]+%?)\s*,\s*([0-9A-Fa-f.]+%?)\s*\)$/);if(!i)return null;const a=[Xe(i[1],255),Xe(i[2],255),Xe(i[3],255),Xe(i[4],1)];return isNaN(a[0])||isNaN(a[1])||isNaN(a[2])||isNaN(a[3])?null:a}function Rl(c){return i=>{const a=Ll(i);return a?new qt(a,"rgb",c):null}}function Dl(c){const i=c.match(/^hsl\(\s*([0-9A-Fa-f.]+(?:deg|grad|rad|turn)?)\s*,\s*([0-9A-Fa-f.]+%?)\s*,\s*([0-9A-Fa-f.]+%?)\s*\)$/);if(!i)return null;const a=[Cl(i[1]),Xe(i[2],100),Xe(i[3],100)];return isNaN(a[0])||isNaN(a[1])||isNaN(a[2])?null:a}function Il(c){return i=>{const a=Dl(i);return a?new qt(a,"hsl",c):null}}function Nl(c){const i=c.match(/^hsla\(\s*([0-9A-Fa-f.]+(?:deg|grad|rad|turn)?)\s*,\s*([0-9A-Fa-f.]+%?)\s*,\s*([0-9A-Fa-f.]+%?)\s*,\s*([0-9A-Fa-f.]+%?)\s*\)$/);if(!i)return null;const a=[Cl(i[1]),Xe(i[2],100),Xe(i[3],100),Xe(i[4],1)];return isNaN(a[0])||isNaN(a[1])||isNaN(a[2])||isNaN(a[3])?null:a}function Fl(c){return i=>{const a=Nl(i);return a?new qt(a,"hsl",c):null}}function kl(c){const i=c.match(/^#([0-9A-Fa-f])([0-9A-Fa-f])([0-9A-Fa-f])$/);if(i)return[parseInt(i[1]+i[1],16),parseInt(i[2]+i[2],16),parseInt(i[3]+i[3],16)];const a=c.match(/^(?:#|0x)([0-9A-Fa-f]{2})([0-9A-Fa-f]{2})([0-9A-Fa-f]{2})$/);return a?[parseInt(a[1],16),parseInt(a[2],16),parseInt(a[3],16)]:null}function Yd(c){const i=kl(c);return i?new qt(i,"rgb","int"):null}function Vl(c){const i=c.match(/^#?([0-9A-Fa-f])([0-9A-Fa-f])([0-9A-Fa-f])([0-9A-Fa-f])$/);if(i)return[parseInt(i[1]+i[1],16),parseInt(i[2]+i[2],16),parseInt(i[3]+i[3],16),ae(parseInt(i[4]+i[4],16),0,255,0,1)];const a=c.match(/^(?:#|0x)?([0-9A-Fa-f]{2})([0-9A-Fa-f]{2})([0-9A-Fa-f]{2})([0-9A-Fa-f]{2})$/);return a?[parseInt(a[1],16),parseInt(a[2],16),parseInt(a[3],16),ae(parseInt(a[4],16),0,255,0,1)]:null}function Jd(c){const i=Vl(c);return i?new qt(i,"rgb","int"):null}function Bl(c){const i=c.match(/^\{\s*r\s*:\s*([0-9A-Fa-f.]+%?)\s*,\s*g\s*:\s*([0-9A-Fa-f.]+%?)\s*,\s*b\s*:\s*([0-9A-Fa-f.]+%?)\s*\}$/);if(!i)return null;const a=[parseFloat(i[1]),parseFloat(i[2]),parseFloat(i[3])];return isNaN(a[0])||isNaN(a[1])||isNaN(a[2])?null:a}function zl(c){return i=>{const a=Bl(i);return a?new qt(a,"rgb",c):null}}function Ol(c){const i=c.match(/^\{\s*r\s*:\s*([0-9A-Fa-f.]+%?)\s*,\s*g\s*:\s*([0-9A-Fa-f.]+%?)\s*,\s*b\s*:\s*([0-9A-Fa-f.]+%?)\s*,\s*a\s*:\s*([0-9A-Fa-f.]+%?)\s*\}$/);if(!i)return null;const a=[parseFloat(i[1]),parseFloat(i[2]),parseFloat(i[3]),parseFloat(i[4])];return isNaN(a[0])||isNaN(a[1])||isNaN(a[2])||isNaN(a[3])?null:a}function Ul(c){return i=>{const a=Ol(i);return a?new qt(a,"rgb",c):null}}const Zd=[{parser:kl,result:{alpha:!1,mode:"rgb",notation:"hex"}},{parser:Vl,result:{alpha:!0,mode:"rgb",notation:"hex"}},{parser:Al,result:{alpha:!1,mode:"rgb",notation:"func"}},{parser:Ll,result:{alpha:!0,mode:"rgb",notation:"func"}},{parser:Dl,result:{alpha:!1,mode:"hsl",notation:"func"}},{parser:Nl,result:{alpha:!0,mode:"hsl",notation:"func"}},{parser:Bl,result:{alpha:!1,mode:"rgb",notation:"object"}},{parser:Ol,result:{alpha:!0,mode:"rgb",notation:"object"}}];function Kd(c){return Zd.reduce((i,{parser:a,result:u})=>i||(a(c)?u:null),null)}function yo(c,i="int"){const a=Kd(c);return a?a.notation==="hex"&&i!=="float"?Object.assign(Object.assign({},a),{type:"int"}):a.notation==="func"?Object.assign(Object.assign({},a),{type:i}):null:null}const Hl={int:[Yd,Jd,Pl("int"),Rl("int"),Il("int"),Fl("int"),zl("int"),Ul("int")],float:[Pl("float"),Rl("float"),Il("float"),Fl("float"),zl("float"),Ul("float")]};function Qd(c){const i=Hl[c];return a=>{if(typeof a!="string")return qt.black(c);const u=i.reduce((b,P)=>b||P(a),null);return u!=null?u:qt.black(c)}}function wo(c){const i=Hl[c];return a=>i.reduce((u,b)=>u||b(a),null)}function Gl(c){const i=me(Math.floor(c),0,255).toString(16);return i.length===1?`0${i}`:i}function Wl(c,i="#"){const a=ei(c.getComponents("rgb")).map(Gl).join("");return`${i}${a}`}function Mo(c,i="#"){const a=c.getComponents("rgb"),u=[a[0],a[1],a[2],a[3]*255].map(Gl).join("");return`${i}${u}`}function ql(c,i){const a=Se(i==="float"?2:0);return`rgb(${ei(c.getComponents("rgb",i)).map(b=>a(b)).join(", ")})`}function tp(c){return i=>ql(i,c)}function ls(c,i){const a=Se(2),u=Se(i==="float"?2:0);return`rgba(${c.getComponents("rgb",i).map((P,B)=>(B===3?a:u)(P)).join(", ")})`}function ep(c){return i=>ls(i,c)}function np(c){const i=[Se(0),ns,ns];return`hsl(${ei(c.getComponents("hsl")).map((u,b)=>i[b](u)).join(", ")})`}function ip(c){const i=[Se(0),ns,ns,Se(2)];return`hsla(${c.getComponents("hsl").map((u,b)=>i[b](u)).join(", ")})`}function jl(c,i){const a=Se(i==="float"?2:0),u=["r","g","b"];return`{${ei(c.getComponents("rgb",i)).map((P,B)=>`${u[B]}: ${a(P)}`).join(", ")}}`}function rp(c){return i=>jl(i,c)}function Xl(c,i){const a=Se(2),u=Se(i==="float"?2:0),b=["r","g","b","a"];return`{${c.getComponents("rgb",i).map((B,it)=>{const St=it===3?a:u;return`${b[it]}: ${St(B)}`}).join(", ")}}`}function sp(c){return i=>Xl(i,c)}const op=[{format:{alpha:!1,mode:"rgb",notation:"hex",type:"int"},stringifier:Wl},{format:{alpha:!0,mode:"rgb",notation:"hex",type:"int"},stringifier:Mo},{format:{alpha:!1,mode:"hsl",notation:"func",type:"int"},stringifier:np},{format:{alpha:!0,mode:"hsl",notation:"func",type:"int"},stringifier:ip},...["int","float"].reduce((c,i)=>[...c,{format:{alpha:!1,mode:"rgb",notation:"func",type:i},stringifier:tp(i)},{format:{alpha:!0,mode:"rgb",notation:"func",type:i},stringifier:ep(i)},{format:{alpha:!1,mode:"rgb",notation:"object",type:i},stringifier:rp(i)},{format:{alpha:!0,mode:"rgb",notation:"object",type:i},stringifier:sp(i)}],[])];function So(c){return op.reduce((i,a)=>i||(Xd(a.format,c)?a.stringifier:null),null)}const xr=M("apl");class ap{constructor(i,a){this.onValueChange_=this.onValueChange_.bind(this),this.value=a.value,this.value.emitter.on("change",this.onValueChange_),this.element=i.createElement("div"),this.element.classList.add(xr()),a.viewProps.bindClassModifiers(this.element),a.viewProps.bindTabIndex(this.element);const u=i.createElement("div");u.classList.add(xr("b")),this.element.appendChild(u);const b=i.createElement("div");b.classList.add(xr("c")),u.appendChild(b),this.colorElem_=b;const P=i.createElement("div");P.classList.add(xr("m")),this.element.appendChild(P),this.markerElem_=P;const B=i.createElement("div");B.classList.add(xr("p")),this.markerElem_.appendChild(B),this.previewElem_=B,this.update_()}update_(){const i=this.value.rawValue,a=i.getComponents("rgb"),u=new qt([a[0],a[1],a[2],0],"rgb"),b=new qt([a[0],a[1],a[2],255],"rgb"),P=["to right",ls(u),ls(b)];this.colorElem_.style.background=`linear-gradient(${P.join(",")})`,this.previewElem_.style.backgroundColor=ls(i);const B=ae(a[3],0,1,0,100);this.markerElem_.style.left=`${B}%`}onValueChange_(){this.update_()}}class lp{constructor(i,a){this.onKeyDown_=this.onKeyDown_.bind(this),this.onKeyUp_=this.onKeyUp_.bind(this),this.onPointerDown_=this.onPointerDown_.bind(this),this.onPointerMove_=this.onPointerMove_.bind(this),this.onPointerUp_=this.onPointerUp_.bind(this),this.value=a.value,this.viewProps=a.viewProps,this.view=new ap(i,{value:this.value,viewProps:this.viewProps}),this.ptHandler_=new Qn(this.view.element),this.ptHandler_.emitter.on("down",this.onPointerDown_),this.ptHandler_.emitter.on("move",this.onPointerMove_),this.ptHandler_.emitter.on("up",this.onPointerUp_),this.view.element.addEventListener("keydown",this.onKeyDown_),this.view.element.addEventListener("keyup",this.onKeyUp_)}handlePointerEvent_(i,a){if(!i.point)return;const u=i.point.x/i.bounds.width,b=this.value.rawValue,[P,B,it]=b.getComponents("hsv");this.value.setRawValue(new qt([P,B,it,u],"hsv"),a)}onPointerDown_(i){this.handlePointerEvent_(i.data,{forceEmit:!1,last:!1})}onPointerMove_(i){this.handlePointerEvent_(i.data,{forceEmit:!1,last:!1})}onPointerUp_(i){this.handlePointerEvent_(i.data,{forceEmit:!0,last:!0})}onKeyDown_(i){const a=Fe(ni(!0),gn(i));if(a===0)return;const u=this.value.rawValue,[b,P,B,it]=u.getComponents("hsv");this.value.setRawValue(new qt([b,P,B,it+a],"hsv"),{forceEmit:!1,last:!1})}onKeyUp_(i){Fe(ni(!0),gn(i))!==0&&this.value.setRawValue(this.value.rawValue,{forceEmit:!0,last:!0})}}const xi=M("coltxt");function cp(c){const i=c.createElement("select"),a=[{text:"RGB",value:"rgb"},{text:"HSL",value:"hsl"},{text:"HSV",value:"hsv"}];return i.appendChild(a.reduce((u,b)=>{const P=c.createElement("option");return P.textContent=b.text,P.value=b.value,u.appendChild(P),u},c.createDocumentFragment())),i}class hp{constructor(i,a){this.element=i.createElement("div"),this.element.classList.add(xi()),a.viewProps.bindClassModifiers(this.element);const u=i.createElement("div");u.classList.add(xi("m")),this.modeElem_=cp(i),this.modeElem_.classList.add(xi("ms")),u.appendChild(this.modeSelectElement),a.viewProps.bindDisabled(this.modeElem_);const b=i.createElement("div");b.classList.add(xi("mm")),b.appendChild(et(i,"dropdown")),u.appendChild(b),this.element.appendChild(u);const P=i.createElement("div");P.classList.add(xi("w")),this.element.appendChild(P),this.textsElem_=P,this.textViews_=a.textViews,this.applyTextViews_(),k(a.colorMode,B=>{this.modeElem_.value=B})}get modeSelectElement(){return this.modeElem_}get textViews(){return this.textViews_}set textViews(i){this.textViews_=i,this.applyTextViews_()}applyTextViews_(){It(this.textsElem_);const i=this.element.ownerDocument;this.textViews_.forEach(a=>{const u=i.createElement("div");u.classList.add(xi("c")),u.appendChild(a.element),this.textsElem_.appendChild(u)})}}function up(c){return Se(c==="float"?2:0)}function dp(c,i,a){const u=os(c,i)[a];return new gi({min:0,max:u})}function Eo(c,i,a){return new vr(c,{arrayPosition:a===0?"fst":a===3-1?"lst":"mid",baseStep:ni(!1),parser:i.parser,props:X.fromObject({draggingScale:i.colorType==="float"?.01:1,formatter:up(i.colorType)}),value:U(0,{constraint:dp(i.colorMode,i.colorType,a)}),viewProps:i.viewProps})}class pp{constructor(i,a){this.onModeSelectChange_=this.onModeSelectChange_.bind(this),this.colorType_=a.colorType,this.parser_=a.parser,this.value=a.value,this.viewProps=a.viewProps,this.colorMode=U(this.value.rawValue.mode),this.ccs_=this.createComponentControllers_(i),this.view=new hp(i,{colorMode:this.colorMode,textViews:[this.ccs_[0].view,this.ccs_[1].view,this.ccs_[2].view],viewProps:this.viewProps}),this.view.modeSelectElement.addEventListener("change",this.onModeSelectChange_)}createComponentControllers_(i){const a={colorMode:this.colorMode.rawValue,colorType:this.colorType_,parser:this.parser_,viewProps:this.viewProps},u=[Eo(i,a,0),Eo(i,a,1),Eo(i,a,2)];return u.forEach((b,P)=>{mr({primary:this.value,secondary:b.value,forward:B=>B.rawValue.getComponents(this.colorMode.rawValue,this.colorType_)[P],backward:(B,it)=>{const St=this.colorMode.rawValue,Dt=B.rawValue.getComponents(St,this.colorType_);return Dt[P]=it.rawValue,new qt(El(ei(Dt),Dt[3]),St,this.colorType_)}})}),u}onModeSelectChange_(i){const a=i.currentTarget;this.colorMode.rawValue=a.value,this.ccs_=this.createComponentControllers_(this.view.element.ownerDocument),this.view.textViews=[this.ccs_[0].view,this.ccs_[1].view,this.ccs_[2].view]}}const To=M("hpl");class fp{constructor(i,a){this.onValueChange_=this.onValueChange_.bind(this),this.value=a.value,this.value.emitter.on("change",this.onValueChange_),this.element=i.createElement("div"),this.element.classList.add(To()),a.viewProps.bindClassModifiers(this.element),a.viewProps.bindTabIndex(this.element);const u=i.createElement("div");u.classList.add(To("c")),this.element.appendChild(u);const b=i.createElement("div");b.classList.add(To("m")),this.element.appendChild(b),this.markerElem_=b,this.update_()}update_(){const i=this.value.rawValue,[a]=i.getComponents("hsv");this.markerElem_.style.backgroundColor=ql(new qt([a,100,100],"hsv"));const u=ae(a,0,360,0,100);this.markerElem_.style.left=`${u}%`}onValueChange_(){this.update_()}}class mp{constructor(i,a){this.onKeyDown_=this.onKeyDown_.bind(this),this.onKeyUp_=this.onKeyUp_.bind(this),this.onPointerDown_=this.onPointerDown_.bind(this),this.onPointerMove_=this.onPointerMove_.bind(this),this.onPointerUp_=this.onPointerUp_.bind(this),this.value=a.value,this.viewProps=a.viewProps,this.view=new fp(i,{value:this.value,viewProps:this.viewProps}),this.ptHandler_=new Qn(this.view.element),this.ptHandler_.emitter.on("down",this.onPointerDown_),this.ptHandler_.emitter.on("move",this.onPointerMove_),this.ptHandler_.emitter.on("up",this.onPointerUp_),this.view.element.addEventListener("keydown",this.onKeyDown_),this.view.element.addEventListener("keyup",this.onKeyUp_)}handlePointerEvent_(i,a){if(!i.point)return;const u=ae(me(i.point.x,0,i.bounds.width),0,i.bounds.width,0,360),b=this.value.rawValue,[,P,B,it]=b.getComponents("hsv");this.value.setRawValue(new qt([u,P,B,it],"hsv"),a)}onPointerDown_(i){this.handlePointerEvent_(i.data,{forceEmit:!1,last:!1})}onPointerMove_(i){this.handlePointerEvent_(i.data,{forceEmit:!1,last:!1})}onPointerUp_(i){this.handlePointerEvent_(i.data,{forceEmit:!0,last:!0})}onKeyDown_(i){const a=Fe(ni(!1),gn(i));if(a===0)return;const u=this.value.rawValue,[b,P,B,it]=u.getComponents("hsv");this.value.setRawValue(new qt([b+a,P,B,it],"hsv"),{forceEmit:!1,last:!1})}onKeyUp_(i){Fe(ni(!1),gn(i))!==0&&this.value.setRawValue(this.value.rawValue,{forceEmit:!0,last:!0})}}const Co=M("svp"),$l=64;class gp{constructor(i,a){this.onValueChange_=this.onValueChange_.bind(this),this.value=a.value,this.value.emitter.on("change",this.onValueChange_),this.element=i.createElement("div"),this.element.classList.add(Co()),a.viewProps.bindClassModifiers(this.element),a.viewProps.bindTabIndex(this.element);const u=i.createElement("canvas");u.height=$l,u.width=$l,u.classList.add(Co("c")),this.element.appendChild(u),this.canvasElement=u;const b=i.createElement("div");b.classList.add(Co("m")),this.element.appendChild(b),this.markerElem_=b,this.update_()}update_(){const i=T(this.canvasElement);if(!i)return;const u=this.value.rawValue.getComponents("hsv"),b=this.canvasElement.width,P=this.canvasElement.height,B=i.getImageData(0,0,b,P),it=B.data;for(let Jt=0;Jt<P;Jt++)for(let Kt=0;Kt<b;Kt++){const ri=ae(Kt,0,b,0,100),yr=ae(Jt,0,P,100,0),wr=Sl(u[0],ri,yr),cs=(Jt*b+Kt)*4;it[cs]=wr[0],it[cs+1]=wr[1],it[cs+2]=wr[2],it[cs+3]=255}i.putImageData(B,0,0);const St=ae(u[1],0,100,0,100);this.markerElem_.style.left=`${St}%`;const Dt=ae(u[2],0,100,100,0);this.markerElem_.style.top=`${Dt}%`}onValueChange_(){this.update_()}}class vp{constructor(i,a){this.onKeyDown_=this.onKeyDown_.bind(this),this.onKeyUp_=this.onKeyUp_.bind(this),this.onPointerDown_=this.onPointerDown_.bind(this),this.onPointerMove_=this.onPointerMove_.bind(this),this.onPointerUp_=this.onPointerUp_.bind(this),this.value=a.value,this.viewProps=a.viewProps,this.view=new gp(i,{value:this.value,viewProps:this.viewProps}),this.ptHandler_=new Qn(this.view.element),this.ptHandler_.emitter.on("down",this.onPointerDown_),this.ptHandler_.emitter.on("move",this.onPointerMove_),this.ptHandler_.emitter.on("up",this.onPointerUp_),this.view.element.addEventListener("keydown",this.onKeyDown_),this.view.element.addEventListener("keyup",this.onKeyUp_)}handlePointerEvent_(i,a){if(!i.point)return;const u=ae(i.point.x,0,i.bounds.width,0,100),b=ae(i.point.y,0,i.bounds.height,100,0),[P,,,B]=this.value.rawValue.getComponents("hsv");this.value.setRawValue(new qt([P,u,b,B],"hsv"),a)}onPointerDown_(i){this.handlePointerEvent_(i.data,{forceEmit:!1,last:!1})}onPointerMove_(i){this.handlePointerEvent_(i.data,{forceEmit:!1,last:!1})}onPointerUp_(i){this.handlePointerEvent_(i.data,{forceEmit:!0,last:!0})}onKeyDown_(i){xl(i.key)&&i.preventDefault();const[a,u,b,P]=this.value.rawValue.getComponents("hsv"),B=ni(!1),it=Fe(B,gn(i)),St=Fe(B,gr(i));it===0&&St===0||this.value.setRawValue(new qt([a,u+it,b+St,P],"hsv"),{forceEmit:!1,last:!1})}onKeyUp_(i){const a=ni(!1),u=Fe(a,gn(i)),b=Fe(a,gr(i));u===0&&b===0||this.value.setRawValue(this.value.rawValue,{forceEmit:!0,last:!0})}}class _p{constructor(i,a){this.value=a.value,this.viewProps=a.viewProps,this.hPaletteC_=new mp(i,{value:this.value,viewProps:this.viewProps}),this.svPaletteC_=new vp(i,{value:this.value,viewProps:this.viewProps}),this.alphaIcs_=a.supportsAlpha?{palette:new lp(i,{value:this.value,viewProps:this.viewProps}),text:new vr(i,{parser:mn,baseStep:.1,props:X.fromObject({draggingScale:.01,formatter:Se(2)}),value:U(0,{constraint:new gi({min:0,max:1})}),viewProps:this.viewProps})}:null,this.alphaIcs_&&mr({primary:this.value,secondary:this.alphaIcs_.text.value,forward:u=>u.rawValue.getComponents()[3],backward:(u,b)=>{const P=u.rawValue.getComponents();return P[3]=b.rawValue,new qt(P,u.rawValue.mode)}}),this.textC_=new pp(i,{colorType:a.colorType,parser:mn,value:this.value,viewProps:this.viewProps}),this.view=new qd(i,{alphaViews:this.alphaIcs_?{palette:this.alphaIcs_.palette.view,text:this.alphaIcs_.text.view}:null,hPaletteView:this.hPaletteC_.view,supportsAlpha:a.supportsAlpha,svPaletteView:this.svPaletteC_.view,textView:this.textC_.view,viewProps:this.viewProps})}get textController(){return this.textC_}}const Ao=M("colsw");class xp{constructor(i,a){this.onValueChange_=this.onValueChange_.bind(this),a.value.emitter.on("change",this.onValueChange_),this.value=a.value,this.element=i.createElement("div"),this.element.classList.add(Ao()),a.viewProps.bindClassModifiers(this.element);const u=i.createElement("div");u.classList.add(Ao("sw")),this.element.appendChild(u),this.swatchElem_=u;const b=i.createElement("button");b.classList.add(Ao("b")),a.viewProps.bindDisabled(b),this.element.appendChild(b),this.buttonElement=b,this.update_()}update_(){const i=this.value.rawValue;this.swatchElem_.style.backgroundColor=Mo(i)}onValueChange_(){this.update_()}}class bp{constructor(i,a){this.value=a.value,this.viewProps=a.viewProps,this.view=new xp(i,{value:this.value,viewProps:this.viewProps})}}class Po{constructor(i,a){this.onButtonBlur_=this.onButtonBlur_.bind(this),this.onButtonClick_=this.onButtonClick_.bind(this),this.onPopupChildBlur_=this.onPopupChildBlur_.bind(this),this.onPopupChildKeydown_=this.onPopupChildKeydown_.bind(this),this.value=a.value,this.viewProps=a.viewProps,this.foldable_=Nt.create(a.expanded),this.swatchC_=new bp(i,{value:this.value,viewProps:this.viewProps});const u=this.swatchC_.view.buttonElement;u.addEventListener("blur",this.onButtonBlur_),u.addEventListener("click",this.onButtonClick_),this.textC_=new es(i,{parser:a.parser,props:X.fromObject({formatter:a.formatter}),value:this.value,viewProps:this.viewProps}),this.view=new Fd(i,{foldable:this.foldable_,pickerLayout:a.pickerLayout}),this.view.swatchElement.appendChild(this.swatchC_.view.element),this.view.textElement.appendChild(this.textC_.view.element),this.popC_=a.pickerLayout==="popup"?new hl(i,{viewProps:this.viewProps}):null;const b=new _p(i,{colorType:a.colorType,supportsAlpha:a.supportsAlpha,value:this.value,viewProps:this.viewProps});b.view.allFocusableElements.forEach(P=>{P.addEventListener("blur",this.onPopupChildBlur_),P.addEventListener("keydown",this.onPopupChildKeydown_)}),this.pickerC_=b,this.popC_?(this.view.element.appendChild(this.popC_.view.element),this.popC_.view.element.appendChild(b.view.element),mr({primary:this.foldable_.value("expanded"),secondary:this.popC_.shows,forward:P=>P.rawValue,backward:(P,B)=>B.rawValue})):this.view.pickerElement&&(this.view.pickerElement.appendChild(this.pickerC_.view.element),De(this.foldable_,this.view.pickerElement))}get textController(){return this.textC_}onButtonBlur_(i){if(!this.popC_)return;const a=this.view.element,u=i.relatedTarget;(!u||!a.contains(u))&&(this.popC_.shows.rawValue=!1)}onButtonClick_(){this.foldable_.set("expanded",!this.foldable_.get("expanded")),this.foldable_.get("expanded")&&this.pickerC_.view.allFocusableElements[0].focus()}onPopupChildBlur_(i){if(!this.popC_)return;const a=this.popC_.view.element,u=ut(i);u&&a.contains(u)||u&&u===this.swatchC_.view.buttonElement&&!Ut(a.ownerDocument)||(this.popC_.shows.rawValue=!1)}onPopupChildKeydown_(i){this.popC_?i.key==="Escape"&&(this.popC_.shows.rawValue=!1):this.view.pickerElement&&i.key==="Escape"&&this.swatchC_.view.buttonElement.focus()}}function yp(c,i){return qt.isColorObject(c)?qt.fromObject(c,i):qt.black(i)}function wp(c){return ei(c.getComponents("rgb")).reduce((i,a)=>i<<8|Math.floor(a)&255,0)}function Mp(c){return c.getComponents("rgb").reduce((i,a,u)=>{const b=Math.floor(u===3?a*255:a)&255;return i<<8|b},0)>>>0}function Sp(c){return new qt([c>>16&255,c>>8&255,c&255],"rgb")}function Ep(c){return new qt([c>>24&255,c>>16&255,c>>8&255,ae(c&255,0,255,0,1)],"rgb")}function Tp(c){return typeof c!="number"?qt.black():Sp(c)}function Cp(c){return typeof c!="number"?qt.black():Ep(c)}function Ap(c){const i=So(c);return i?(a,u)=>{_r(a,i(u))}:null}function Pp(c){const i=c?Mp:wp;return(a,u)=>{_r(a,i(u))}}function Lp(c,i,a){const u=i.toRgbaObject(a);c.writeProperty("r",u.r),c.writeProperty("g",u.g),c.writeProperty("b",u.b),c.writeProperty("a",u.a)}function Rp(c,i,a){const u=i.toRgbaObject(a);c.writeProperty("r",u.r),c.writeProperty("g",u.g),c.writeProperty("b",u.b)}function Dp(c,i){return(a,u)=>{c?Lp(a,u,i):Rp(a,u,i)}}function Lo(c){var i;return!!((c==null?void 0:c.alpha)||((i=c==null?void 0:c.color)===null||i===void 0?void 0:i.alpha))}function Ip(c){return c?i=>Mo(i,"0x"):i=>Wl(i,"0x")}function Np(c){return"color"in c||"view"in c&&c.view==="color"}const Fp={id:"input-color-number",type:"input",accept:(c,i)=>{if(typeof c!="number"||!Np(i))return null;const a=bo(i);return a?{initialValue:c,params:a}:null},binding:{reader:c=>Lo(c.params)?Cp:Tp,equals:qt.equals,writer:c=>Pp(Lo(c.params))},controller:c=>{const i=Lo(c.params),a="expanded"in c.params?c.params.expanded:void 0,u="picker"in c.params?c.params.picker:void 0;return new Po(c.document,{colorType:"int",expanded:a!=null?a:!1,formatter:Ip(i),parser:wo("int"),pickerLayout:u!=null?u:"popup",supportsAlpha:i,value:c.value,viewProps:c.viewProps})}};function kp(c){return qt.isRgbaColorObject(c)}function Vp(c){return i=>yp(i,c)}function Bp(c,i){return a=>c?Xl(a,i):jl(a,i)}const zp={id:"input-color-object",type:"input",accept:(c,i)=>{if(!qt.isColorObject(c))return null;const a=bo(i);return a?{initialValue:c,params:a}:null},binding:{reader:c=>Vp(ii(c.params)),equals:qt.equals,writer:c=>Dp(kp(c.initialValue),ii(c.params))},controller:c=>{var i;const a=qt.isRgbaColorObject(c.initialValue),u="expanded"in c.params?c.params.expanded:void 0,b="picker"in c.params?c.params.picker:void 0,P=(i=ii(c.params))!==null&&i!==void 0?i:"int";return new Po(c.document,{colorType:P,expanded:u!=null?u:!1,formatter:Bp(a,P),parser:wo(P),pickerLayout:b!=null?b:"popup",supportsAlpha:a,value:c.value,viewProps:c.viewProps})}},Op={id:"input-color-string",type:"input",accept:(c,i)=>{if(typeof c!="string"||"view"in i&&i.view==="text")return null;const a=yo(c,ii(i));if(!a||!So(a))return null;const b=bo(i);return b?{initialValue:c,params:b}:null},binding:{reader:c=>{var i;return Qd((i=ii(c.params))!==null&&i!==void 0?i:"int")},equals:qt.equals,writer:c=>{const i=yo(c.initialValue,ii(c.params));if(!i)throw w.shouldNeverHappen();const a=Ap(i);if(!a)throw w.notBindable();return a}},controller:c=>{const i=yo(c.initialValue,ii(c.params));if(!i)throw w.shouldNeverHappen();const a=So(i);if(!a)throw w.shouldNeverHappen();const u="expanded"in c.params?c.params.expanded:void 0,b="picker"in c.params?c.params.picker:void 0;return new Po(c.document,{colorType:i.type,expanded:u!=null?u:!1,formatter:a,parser:wo(i.type),pickerLayout:b!=null?b:"popup",supportsAlpha:i.alpha,value:c.value,viewProps:c.viewProps})}};class Rn{constructor(i){this.components=i.components,this.asm_=i.assembly}constrain(i){const a=this.asm_.toComponents(i).map((u,b)=>{var P,B;return(B=(P=this.components[b])===null||P===void 0?void 0:P.constrain(u))!==null&&B!==void 0?B:u});return this.asm_.fromComponents(a)}}const Yl=M("pndtxt");class Up{constructor(i,a){this.textViews=a.textViews,this.element=i.createElement("div"),this.element.classList.add(Yl()),this.textViews.forEach(u=>{const b=i.createElement("div");b.classList.add(Yl("a")),b.appendChild(u.element),this.element.appendChild(b)})}}function Hp(c,i,a){return new vr(c,{arrayPosition:a===0?"fst":a===i.axes.length-1?"lst":"mid",baseStep:i.axes[a].baseStep,parser:i.parser,props:i.axes[a].textProps,value:U(0,{constraint:i.axes[a].constraint}),viewProps:i.viewProps})}class Ro{constructor(i,a){this.value=a.value,this.viewProps=a.viewProps,this.acs_=a.axes.map((u,b)=>Hp(i,a,b)),this.acs_.forEach((u,b)=>{mr({primary:this.value,secondary:u.value,forward:P=>a.assembly.toComponents(P.rawValue)[b],backward:(P,B)=>{const it=a.assembly.toComponents(P.rawValue);return it[b]=B.rawValue,a.assembly.fromComponents(it)}})}),this.view=new Up(i,{textViews:this.acs_.map(u=>u.view)})}}function Jl(c,i){return"step"in c&&!m(c.step)?new ts(c.step,i):null}function Zl(c){return!m(c.max)&&!m(c.min)?new gi({max:c.max,min:c.min}):!m(c.max)||!m(c.min)?new ll({max:c.max,min:c.min}):null}function Gp(c){const i=fn(c,gi);if(i)return[i.values.get("min"),i.values.get("max")];const a=fn(c,ll);return a?[a.minValue,a.maxValue]:[void 0,void 0]}function Wp(c,i){const a=[],u=Jl(c,i);u&&a.push(u);const b=Zl(c);b&&a.push(b);const P=xo(c.options);return P&&a.push(P),new hr(a)}const qp={id:"input-number",type:"input",accept:(c,i)=>{if(typeof c!="number")return null;const a=at,u=Tt(i,{format:a.optional.function,max:a.optional.number,min:a.optional.number,options:a.optional.custom(is),step:a.optional.number});return u?{initialValue:c,params:u}:null},binding:{reader:c=>vl,constraint:c=>Wp(c.params,c.initialValue),writer:c=>_r},controller:c=>{var i;const a=c.value,u=c.constraint,b=u&&fn(u,ur);if(b)return new dr(c.document,{props:new X({options:b.values.value("options")}),value:a,viewProps:c.viewProps});const P=(i="format"in c.params?c.params.format:void 0)!==null&&i!==void 0?i:Se(rs(u,a.rawValue)),B=u&&fn(u,gi);return B?new _o(c.document,{baseStep:vi(u),parser:mn,sliderProps:new X({maxValue:B.values.value("max"),minValue:B.values.value("min")}),textProps:X.fromObject({draggingScale:_i(u,a.rawValue),formatter:P}),value:a,viewProps:c.viewProps}):new vr(c.document,{baseStep:vi(u),parser:mn,props:X.fromObject({draggingScale:_i(u,a.rawValue),formatter:P}),value:a,viewProps:c.viewProps})}};class Dn{constructor(i=0,a=0){this.x=i,this.y=a}getComponents(){return[this.x,this.y]}static isObject(i){if(m(i))return!1;const a=i.x,u=i.y;return!(typeof a!="number"||typeof u!="number")}static equals(i,a){return i.x===a.x&&i.y===a.y}toObject(){return{x:this.x,y:this.y}}}const Kl={toComponents:c=>c.getComponents(),fromComponents:c=>new Dn(...c)},bi=M("p2d");class jp{constructor(i,a){this.element=i.createElement("div"),this.element.classList.add(bi()),a.viewProps.bindClassModifiers(this.element),k(a.expanded,Y(this.element,bi(void 0,"expanded")));const u=i.createElement("div");u.classList.add(bi("h")),this.element.appendChild(u);const b=i.createElement("button");b.classList.add(bi("b")),b.appendChild(et(i,"p2dpad")),a.viewProps.bindDisabled(b),u.appendChild(b),this.buttonElement=b;const P=i.createElement("div");if(P.classList.add(bi("t")),u.appendChild(P),this.textElement=P,a.pickerLayout==="inline"){const B=i.createElement("div");B.classList.add(bi("p")),this.element.appendChild(B),this.pickerElement=B}else this.pickerElement=null}}const In=M("p2dp");class Xp{constructor(i,a){this.onFoldableChange_=this.onFoldableChange_.bind(this),this.onValueChange_=this.onValueChange_.bind(this),this.invertsY_=a.invertsY,this.maxValue_=a.maxValue,this.element=i.createElement("div"),this.element.classList.add(In()),a.layout==="popup"&&this.element.classList.add(In(void 0,"p")),a.viewProps.bindClassModifiers(this.element);const u=i.createElement("div");u.classList.add(In("p")),a.viewProps.bindTabIndex(u),this.element.appendChild(u),this.padElement=u;const b=i.createElementNS(ht,"svg");b.classList.add(In("g")),this.padElement.appendChild(b),this.svgElem_=b;const P=i.createElementNS(ht,"line");P.classList.add(In("ax")),P.setAttributeNS(null,"x1","0"),P.setAttributeNS(null,"y1","50%"),P.setAttributeNS(null,"x2","100%"),P.setAttributeNS(null,"y2","50%"),this.svgElem_.appendChild(P);const B=i.createElementNS(ht,"line");B.classList.add(In("ax")),B.setAttributeNS(null,"x1","50%"),B.setAttributeNS(null,"y1","0"),B.setAttributeNS(null,"x2","50%"),B.setAttributeNS(null,"y2","100%"),this.svgElem_.appendChild(B);const it=i.createElementNS(ht,"line");it.classList.add(In("l")),it.setAttributeNS(null,"x1","50%"),it.setAttributeNS(null,"y1","50%"),this.svgElem_.appendChild(it),this.lineElem_=it;const St=i.createElement("div");St.classList.add(In("m")),this.padElement.appendChild(St),this.markerElem_=St,a.value.emitter.on("change",this.onValueChange_),this.value=a.value,this.update_()}get allFocusableElements(){return[this.padElement]}update_(){const[i,a]=this.value.rawValue.getComponents(),u=this.maxValue_,b=ae(i,-u,+u,0,100),P=ae(a,-u,+u,0,100),B=this.invertsY_?100-P:P;this.lineElem_.setAttributeNS(null,"x2",`${b}%`),this.lineElem_.setAttributeNS(null,"y2",`${B}%`),this.markerElem_.style.left=`${b}%`,this.markerElem_.style.top=`${B}%`}onValueChange_(){this.update_()}onFoldableChange_(){this.update_()}}function Ql(c,i,a){return[Fe(i[0],gn(c)),Fe(i[1],gr(c))*(a?1:-1)]}class $p{constructor(i,a){this.onPadKeyDown_=this.onPadKeyDown_.bind(this),this.onPadKeyUp_=this.onPadKeyUp_.bind(this),this.onPointerDown_=this.onPointerDown_.bind(this),this.onPointerMove_=this.onPointerMove_.bind(this),this.onPointerUp_=this.onPointerUp_.bind(this),this.value=a.value,this.viewProps=a.viewProps,this.baseSteps_=a.baseSteps,this.maxValue_=a.maxValue,this.invertsY_=a.invertsY,this.view=new Xp(i,{invertsY:this.invertsY_,layout:a.layout,maxValue:this.maxValue_,value:this.value,viewProps:this.viewProps}),this.ptHandler_=new Qn(this.view.padElement),this.ptHandler_.emitter.on("down",this.onPointerDown_),this.ptHandler_.emitter.on("move",this.onPointerMove_),this.ptHandler_.emitter.on("up",this.onPointerUp_),this.view.padElement.addEventListener("keydown",this.onPadKeyDown_),this.view.padElement.addEventListener("keyup",this.onPadKeyUp_)}handlePointerEvent_(i,a){if(!i.point)return;const u=this.maxValue_,b=ae(i.point.x,0,i.bounds.width,-u,+u),P=ae(this.invertsY_?i.bounds.height-i.point.y:i.point.y,0,i.bounds.height,-u,+u);this.value.setRawValue(new Dn(b,P),a)}onPointerDown_(i){this.handlePointerEvent_(i.data,{forceEmit:!1,last:!1})}onPointerMove_(i){this.handlePointerEvent_(i.data,{forceEmit:!1,last:!1})}onPointerUp_(i){this.handlePointerEvent_(i.data,{forceEmit:!0,last:!0})}onPadKeyDown_(i){xl(i.key)&&i.preventDefault();const[a,u]=Ql(i,this.baseSteps_,this.invertsY_);a===0&&u===0||this.value.setRawValue(new Dn(this.value.rawValue.x+a,this.value.rawValue.y+u),{forceEmit:!1,last:!1})}onPadKeyUp_(i){const[a,u]=Ql(i,this.baseSteps_,this.invertsY_);a===0&&u===0||this.value.setRawValue(this.value.rawValue,{forceEmit:!0,last:!0})}}class Yp{constructor(i,a){var u,b;this.onPopupChildBlur_=this.onPopupChildBlur_.bind(this),this.onPopupChildKeydown_=this.onPopupChildKeydown_.bind(this),this.onPadButtonBlur_=this.onPadButtonBlur_.bind(this),this.onPadButtonClick_=this.onPadButtonClick_.bind(this),this.value=a.value,this.viewProps=a.viewProps,this.foldable_=Nt.create(a.expanded),this.popC_=a.pickerLayout==="popup"?new hl(i,{viewProps:this.viewProps}):null;const P=new $p(i,{baseSteps:[a.axes[0].baseStep,a.axes[1].baseStep],invertsY:a.invertsY,layout:a.pickerLayout,maxValue:a.maxValue,value:this.value,viewProps:this.viewProps});P.view.allFocusableElements.forEach(B=>{B.addEventListener("blur",this.onPopupChildBlur_),B.addEventListener("keydown",this.onPopupChildKeydown_)}),this.pickerC_=P,this.textC_=new Ro(i,{assembly:Kl,axes:a.axes,parser:a.parser,value:this.value,viewProps:this.viewProps}),this.view=new jp(i,{expanded:this.foldable_.value("expanded"),pickerLayout:a.pickerLayout,viewProps:this.viewProps}),this.view.textElement.appendChild(this.textC_.view.element),(u=this.view.buttonElement)===null||u===void 0||u.addEventListener("blur",this.onPadButtonBlur_),(b=this.view.buttonElement)===null||b===void 0||b.addEventListener("click",this.onPadButtonClick_),this.popC_?(this.view.element.appendChild(this.popC_.view.element),this.popC_.view.element.appendChild(this.pickerC_.view.element),mr({primary:this.foldable_.value("expanded"),secondary:this.popC_.shows,forward:B=>B.rawValue,backward:(B,it)=>it.rawValue})):this.view.pickerElement&&(this.view.pickerElement.appendChild(this.pickerC_.view.element),De(this.foldable_,this.view.pickerElement))}onPadButtonBlur_(i){if(!this.popC_)return;const a=this.view.element,u=i.relatedTarget;(!u||!a.contains(u))&&(this.popC_.shows.rawValue=!1)}onPadButtonClick_(){this.foldable_.set("expanded",!this.foldable_.get("expanded")),this.foldable_.get("expanded")&&this.pickerC_.view.allFocusableElements[0].focus()}onPopupChildBlur_(i){if(!this.popC_)return;const a=this.popC_.view.element,u=ut(i);u&&a.contains(u)||u&&u===this.view.buttonElement&&!Ut(a.ownerDocument)||(this.popC_.shows.rawValue=!1)}onPopupChildKeydown_(i){this.popC_?i.key==="Escape"&&(this.popC_.shows.rawValue=!1):this.view.pickerElement&&i.key==="Escape"&&this.view.buttonElement.focus()}}class yi{constructor(i=0,a=0,u=0){this.x=i,this.y=a,this.z=u}getComponents(){return[this.x,this.y,this.z]}static isObject(i){if(m(i))return!1;const a=i.x,u=i.y,b=i.z;return!(typeof a!="number"||typeof u!="number"||typeof b!="number")}static equals(i,a){return i.x===a.x&&i.y===a.y&&i.z===a.z}toObject(){return{x:this.x,y:this.y,z:this.z}}}const tc={toComponents:c=>c.getComponents(),fromComponents:c=>new yi(...c)};function Jp(c){return yi.isObject(c)?new yi(c.x,c.y,c.z):new yi}function Zp(c,i){c.writeProperty("x",i.x),c.writeProperty("y",i.y),c.writeProperty("z",i.z)}function Kp(c,i){return new Rn({assembly:tc,components:[vn("x"in c?c.x:void 0,i.x),vn("y"in c?c.y:void 0,i.y),vn("z"in c?c.z:void 0,i.z)]})}function Do(c,i){return{baseStep:vi(i),constraint:i,textProps:X.fromObject({draggingScale:_i(i,c),formatter:Se(rs(i,c))})}}const Qp={id:"input-point3d",type:"input",accept:(c,i)=>{if(!yi.isObject(c))return null;const a=at,u=Tt(i,{x:a.optional.custom(Pn),y:a.optional.custom(Pn),z:a.optional.custom(Pn)});return u?{initialValue:c,params:u}:null},binding:{reader:c=>Jp,constraint:c=>Kp(c.params,c.initialValue),equals:yi.equals,writer:c=>Zp},controller:c=>{const i=c.value,a=c.constraint;if(!(a instanceof Rn))throw w.shouldNeverHappen();return new Ro(c.document,{assembly:tc,axes:[Do(i.rawValue.x,a.components[0]),Do(i.rawValue.y,a.components[1]),Do(i.rawValue.z,a.components[2])],parser:mn,value:i,viewProps:c.viewProps})}};class wi{constructor(i=0,a=0,u=0,b=0){this.x=i,this.y=a,this.z=u,this.w=b}getComponents(){return[this.x,this.y,this.z,this.w]}static isObject(i){if(m(i))return!1;const a=i.x,u=i.y,b=i.z,P=i.w;return!(typeof a!="number"||typeof u!="number"||typeof b!="number"||typeof P!="number")}static equals(i,a){return i.x===a.x&&i.y===a.y&&i.z===a.z&&i.w===a.w}toObject(){return{x:this.x,y:this.y,z:this.z,w:this.w}}}const ec={toComponents:c=>c.getComponents(),fromComponents:c=>new wi(...c)};function tf(c){return wi.isObject(c)?new wi(c.x,c.y,c.z,c.w):new wi}function ef(c,i){c.writeProperty("x",i.x),c.writeProperty("y",i.y),c.writeProperty("z",i.z),c.writeProperty("w",i.w)}function nf(c,i){return new Rn({assembly:ec,components:[vn("x"in c?c.x:void 0,i.x),vn("y"in c?c.y:void 0,i.y),vn("z"in c?c.z:void 0,i.z),vn("w"in c?c.w:void 0,i.w)]})}function rf(c,i){return{baseStep:vi(i),constraint:i,textProps:X.fromObject({draggingScale:_i(i,c),formatter:Se(rs(i,c))})}}const sf={id:"input-point4d",type:"input",accept:(c,i)=>{if(!wi.isObject(c))return null;const a=at,u=Tt(i,{x:a.optional.custom(Pn),y:a.optional.custom(Pn),z:a.optional.custom(Pn),w:a.optional.custom(Pn)});return u?{initialValue:c,params:u}:null},binding:{reader:c=>tf,constraint:c=>nf(c.params,c.initialValue),equals:wi.equals,writer:c=>ef},controller:c=>{const i=c.value,a=c.constraint;if(!(a instanceof Rn))throw w.shouldNeverHappen();return new Ro(c.document,{assembly:ec,axes:i.rawValue.getComponents().map((u,b)=>rf(u,a.components[b])),parser:mn,value:i,viewProps:c.viewProps})}};function of(c){const i=[],a=xo(c.options);return a&&i.push(a),new hr(i)}const af={id:"input-string",type:"input",accept:(c,i)=>{if(typeof c!="string")return null;const u=Tt(i,{options:at.optional.custom(is)});return u?{initialValue:c,params:u}:null},binding:{reader:c=>_l,constraint:c=>of(c.params),writer:c=>_r},controller:c=>{const i=c.document,a=c.value,u=c.constraint,b=u&&fn(u,ur);return b?new dr(i,{props:new X({options:b.values.value("options")}),value:a,viewProps:c.viewProps}):new es(i,{parser:P=>P,props:X.fromObject({formatter:fo}),value:a,viewProps:c.viewProps})}},br={monitor:{defaultInterval:200,defaultLineCount:3}},nc=M("mll");class lf{constructor(i,a){this.onValueUpdate_=this.onValueUpdate_.bind(this),this.formatter_=a.formatter,this.element=i.createElement("div"),this.element.classList.add(nc()),a.viewProps.bindClassModifiers(this.element);const u=i.createElement("textarea");u.classList.add(nc("i")),u.style.height=`calc(var(--bld-us) * ${a.lineCount})`,u.readOnly=!0,a.viewProps.bindDisabled(u),this.element.appendChild(u),this.textareaElem_=u,a.value.emitter.on("change",this.onValueUpdate_),this.value=a.value,this.update_()}update_(){const i=this.textareaElem_,a=i.scrollTop===i.scrollHeight-i.clientHeight,u=[];this.value.rawValue.forEach(b=>{b!==void 0&&u.push(this.formatter_(b))}),i.textContent=u.join(`
`),a&&(i.scrollTop=i.scrollHeight)}onValueUpdate_(){this.update_()}}class Io{constructor(i,a){this.value=a.value,this.viewProps=a.viewProps,this.view=new lf(i,{formatter:a.formatter,lineCount:a.lineCount,value:this.value,viewProps:this.viewProps})}}const ic=M("sgl");class cf{constructor(i,a){this.onValueUpdate_=this.onValueUpdate_.bind(this),this.formatter_=a.formatter,this.element=i.createElement("div"),this.element.classList.add(ic()),a.viewProps.bindClassModifiers(this.element);const u=i.createElement("input");u.classList.add(ic("i")),u.readOnly=!0,u.type="text",a.viewProps.bindDisabled(u),this.element.appendChild(u),this.inputElement=u,a.value.emitter.on("change",this.onValueUpdate_),this.value=a.value,this.update_()}update_(){const i=this.value.rawValue,a=i[i.length-1];this.inputElement.value=a!==void 0?this.formatter_(a):""}onValueUpdate_(){this.update_()}}class No{constructor(i,a){this.value=a.value,this.viewProps=a.viewProps,this.view=new cf(i,{formatter:a.formatter,value:this.value,viewProps:this.viewProps})}}const hf={id:"monitor-bool",type:"monitor",accept:(c,i)=>{if(typeof c!="boolean")return null;const u=Tt(i,{lineCount:at.optional.number});return u?{initialValue:c,params:u}:null},binding:{reader:c=>dl},controller:c=>{var i;return c.value.rawValue.length===1?new No(c.document,{formatter:pl,value:c.value,viewProps:c.viewProps}):new Io(c.document,{formatter:pl,lineCount:(i=c.params.lineCount)!==null&&i!==void 0?i:br.monitor.defaultLineCount,value:c.value,viewProps:c.viewProps})}},Nn=M("grl");class uf{constructor(i,a){this.onCursorChange_=this.onCursorChange_.bind(this),this.onValueUpdate_=this.onValueUpdate_.bind(this),this.element=i.createElement("div"),this.element.classList.add(Nn()),a.viewProps.bindClassModifiers(this.element),this.formatter_=a.formatter,this.props_=a.props,this.cursor_=a.cursor,this.cursor_.emitter.on("change",this.onCursorChange_);const u=i.createElementNS(ht,"svg");u.classList.add(Nn("g")),u.style.height=`calc(var(--bld-us) * ${a.lineCount})`,this.element.appendChild(u),this.svgElem_=u;const b=i.createElementNS(ht,"polyline");this.svgElem_.appendChild(b),this.lineElem_=b;const P=i.createElement("div");P.classList.add(Nn("t"),M("tt")()),this.element.appendChild(P),this.tooltipElem_=P,a.value.emitter.on("change",this.onValueUpdate_),this.value=a.value,this.update_()}get graphElement(){return this.svgElem_}update_(){const i=this.svgElem_.getBoundingClientRect(),a=this.value.rawValue.length-1,u=this.props_.get("minValue"),b=this.props_.get("maxValue"),P=[];this.value.rawValue.forEach((Jt,Kt)=>{if(Jt===void 0)return;const ri=ae(Kt,0,a,0,i.width),yr=ae(Jt,u,b,i.height,0);P.push([ri,yr].join(","))}),this.lineElem_.setAttributeNS(null,"points",P.join(" "));const B=this.tooltipElem_,it=this.value.rawValue[this.cursor_.rawValue];if(it===void 0){B.classList.remove(Nn("t","a"));return}const St=ae(this.cursor_.rawValue,0,a,0,i.width),Dt=ae(it,u,b,i.height,0);B.style.left=`${St}px`,B.style.top=`${Dt}px`,B.textContent=`${this.formatter_(it)}`,B.classList.contains(Nn("t","a"))||(B.classList.add(Nn("t","a"),Nn("t","in")),Pt(B),B.classList.remove(Nn("t","in")))}onValueUpdate_(){this.update_()}onCursorChange_(){this.update_()}}class df{constructor(i,a){if(this.onGraphMouseMove_=this.onGraphMouseMove_.bind(this),this.onGraphMouseLeave_=this.onGraphMouseLeave_.bind(this),this.onGraphPointerDown_=this.onGraphPointerDown_.bind(this),this.onGraphPointerMove_=this.onGraphPointerMove_.bind(this),this.onGraphPointerUp_=this.onGraphPointerUp_.bind(this),this.props_=a.props,this.value=a.value,this.viewProps=a.viewProps,this.cursor_=U(-1),this.view=new uf(i,{cursor:this.cursor_,formatter:a.formatter,lineCount:a.lineCount,props:this.props_,value:this.value,viewProps:this.viewProps}),!Ut(i))this.view.element.addEventListener("mousemove",this.onGraphMouseMove_),this.view.element.addEventListener("mouseleave",this.onGraphMouseLeave_);else{const u=new Qn(this.view.element);u.emitter.on("down",this.onGraphPointerDown_),u.emitter.on("move",this.onGraphPointerMove_),u.emitter.on("up",this.onGraphPointerUp_)}}onGraphMouseLeave_(){this.cursor_.rawValue=-1}onGraphMouseMove_(i){const a=this.view.element.getBoundingClientRect();this.cursor_.rawValue=Math.floor(ae(i.offsetX,0,a.width,0,this.value.rawValue.length))}onGraphPointerDown_(i){this.onGraphPointerMove_(i)}onGraphPointerMove_(i){if(!i.data.point){this.cursor_.rawValue=-1;return}this.cursor_.rawValue=Math.floor(ae(i.data.point.x,0,i.data.bounds.width,0,this.value.rawValue.length))}onGraphPointerUp_(){this.cursor_.rawValue=-1}}function Fo(c){return"format"in c&&!m(c.format)?c.format:Se(2)}function pf(c){var i;return c.value.rawValue.length===1?new No(c.document,{formatter:Fo(c.params),value:c.value,viewProps:c.viewProps}):new Io(c.document,{formatter:Fo(c.params),lineCount:(i=c.params.lineCount)!==null&&i!==void 0?i:br.monitor.defaultLineCount,value:c.value,viewProps:c.viewProps})}function ff(c){var i,a,u;return new df(c.document,{formatter:Fo(c.params),lineCount:(i=c.params.lineCount)!==null&&i!==void 0?i:br.monitor.defaultLineCount,props:X.fromObject({maxValue:(a="max"in c.params?c.params.max:null)!==null&&a!==void 0?a:100,minValue:(u="min"in c.params?c.params.min:null)!==null&&u!==void 0?u:0}),value:c.value,viewProps:c.viewProps})}function rc(c){return"view"in c&&c.view==="graph"}const mf={id:"monitor-number",type:"monitor",accept:(c,i)=>{if(typeof c!="number")return null;const a=at,u=Tt(i,{format:a.optional.function,lineCount:a.optional.number,max:a.optional.number,min:a.optional.number,view:a.optional.string});return u?{initialValue:c,params:u}:null},binding:{defaultBufferSize:c=>rc(c)?64:1,reader:c=>vl},controller:c=>rc(c.params)?ff(c):pf(c)},gf={id:"monitor-string",type:"monitor",accept:(c,i)=>{if(typeof c!="string")return null;const a=at,u=Tt(i,{lineCount:a.optional.number,multiline:a.optional.boolean});return u?{initialValue:c,params:u}:null},binding:{reader:c=>_l},controller:c=>{var i;const a=c.value;return a.rawValue.length>1||"multiline"in c.params&&c.params.multiline?new Io(c.document,{formatter:fo,lineCount:(i=c.params.lineCount)!==null&&i!==void 0?i:br.monitor.defaultLineCount,value:a,viewProps:c.viewProps}):new No(c.document,{formatter:fo,value:a,viewProps:c.viewProps})}};function vf(c,i){var a;const u=c.accept(i.target.read(),i.params);if(m(u))return null;const b=at,P={target:i.target,initialValue:u.initialValue,params:u.params},B=c.binding.reader(P),it=c.binding.constraint?c.binding.constraint(P):void 0,St=U(B(u.initialValue),{constraint:it,equals:c.binding.equals}),Dt=new Hu({reader:B,target:i.target,value:St,writer:c.binding.writer(P)}),Jt=b.optional.boolean(i.params.disabled).value,Kt=b.optional.boolean(i.params.hidden).value,ri=c.controller({constraint:it,document:i.document,initialValue:u.initialValue,params:u.params,value:Dt.value,viewProps:Ot.create({disabled:Jt,hidden:Kt})});return new Ne(i.document,{binding:Dt,blade:ft(),props:X.fromObject({label:"label"in i.params?(a=b.optional.string(i.params.label).value)!==null&&a!==void 0?a:null:i.target.key}),valueController:ri})}function _f(c,i){return i===0?new Ou:new Uu(c,i!=null?i:br.monitor.defaultInterval)}function xf(c,i){var a,u,b;const P=at,B=c.accept(i.target.read(),i.params);if(m(B))return null;const it={target:i.target,initialValue:B.initialValue,params:B.params},St=c.binding.reader(it),Dt=(u=(a=P.optional.number(i.params.bufferSize).value)!==null&&a!==void 0?a:c.binding.defaultBufferSize&&c.binding.defaultBufferSize(B.params))!==null&&u!==void 0?u:1,Jt=P.optional.number(i.params.interval).value,Kt=new ju({reader:St,target:i.target,ticker:_f(i.document,Jt),value:Gu(Dt)}),ri=P.optional.boolean(i.params.disabled).value,yr=P.optional.boolean(i.params.hidden).value,wr=c.controller({document:i.document,params:B.params,value:Kt.value,viewProps:Ot.create({disabled:ri,hidden:yr})});return new rn(i.document,{binding:Kt,blade:ft(),props:X.fromObject({label:"label"in i.params?(b=P.optional.string(i.params.label).value)!==null&&b!==void 0?b:null:i.target.key}),valueController:wr})}class bf{constructor(){this.pluginsMap_={blades:[],inputs:[],monitors:[]}}getAll(){return[...this.pluginsMap_.blades,...this.pluginsMap_.inputs,...this.pluginsMap_.monitors]}register(i){i.type==="blade"?this.pluginsMap_.blades.unshift(i):i.type==="input"?this.pluginsMap_.inputs.unshift(i):i.type==="monitor"&&this.pluginsMap_.monitors.unshift(i)}createInput(i,a,u){const b=a.read();if(m(b))throw new w({context:{key:a.key},type:"nomatchingcontroller"});const P=this.pluginsMap_.inputs.reduce((B,it)=>B!=null?B:vf(it,{document:i,target:a,params:u}),null);if(P)return P;throw new w({context:{key:a.key},type:"nomatchingcontroller"})}createMonitor(i,a,u){const b=this.pluginsMap_.monitors.reduce((P,B)=>P!=null?P:xf(B,{document:i,params:u,target:a}),null);if(b)return b;throw new w({context:{key:a.key},type:"nomatchingcontroller"})}createBlade(i,a){const u=this.pluginsMap_.blades.reduce((b,P)=>b!=null?b:zu(P,{document:i,params:a}),null);if(!u)throw new w({type:"nomatchingview",context:{params:a}});return u}createBladeApi(i){if(i instanceof Ne)return new lr(i);if(i instanceof rn)return new fi(i);if(i instanceof Wt)return new z(i,this);const a=this.pluginsMap_.blades.reduce((u,b)=>u!=null?u:b.api({controller:i,pool:this}),null);if(!a)throw w.shouldNeverHappen();return a}}function yf(){const c=new bf;return[Cf,Qp,sf,af,qp,Op,zp,Fp,Nd,hf,gf,mf,bt,Yt,Ze,ol].forEach(i=>{c.register(i)}),c}function wf(c){return Dn.isObject(c)?new Dn(c.x,c.y):new Dn}function Mf(c,i){c.writeProperty("x",i.x),c.writeProperty("y",i.y)}function vn(c,i){if(!c)return;const a=[],u=Jl(c,i);u&&a.push(u);const b=Zl(c);return b&&a.push(b),new hr(a)}function Sf(c,i){return new Rn({assembly:Kl,components:[vn("x"in c?c.x:void 0,i.x),vn("y"in c?c.y:void 0,i.y)]})}function sc(c,i){const[a,u]=c?Gp(c):[];if(!m(a)||!m(u))return Math.max(Math.abs(a!=null?a:0),Math.abs(u!=null?u:0));const b=vi(c);return Math.max(Math.abs(b)*10,Math.abs(i)*10)}function Ef(c,i){const a=i instanceof Rn?i.components[0]:void 0,u=i instanceof Rn?i.components[1]:void 0,b=sc(a,c.x),P=sc(u,c.y);return Math.max(b,P)}function oc(c,i){return{baseStep:vi(i),constraint:i,textProps:X.fromObject({draggingScale:_i(i,c),formatter:Se(rs(i,c))})}}function Tf(c){if(!("y"in c))return!1;const i=c.y;return i&&"inverted"in i?!!i.inverted:!1}const Cf={id:"input-point2d",type:"input",accept:(c,i)=>{if(!Dn.isObject(c))return null;const a=at,u=Tt(i,{expanded:a.optional.boolean,picker:a.optional.custom(wl),x:a.optional.custom(Pn),y:a.optional.object({inverted:a.optional.boolean,max:a.optional.number,min:a.optional.number,step:a.optional.number})});return u?{initialValue:c,params:u}:null},binding:{reader:c=>wf,constraint:c=>Sf(c.params,c.initialValue),equals:Dn.equals,writer:c=>Mf},controller:c=>{const i=c.document,a=c.value,u=c.constraint;if(!(u instanceof Rn))throw w.shouldNeverHappen();const b="expanded"in c.params?c.params.expanded:void 0,P="picker"in c.params?c.params.picker:void 0;return new Yp(i,{axes:[oc(a.rawValue.x,u.components[0]),oc(a.rawValue.y,u.components[1])],expanded:b!=null?b:!1,invertsY:Tf(c.params),maxValue:Ef(a.rawValue,u),parser:mn,pickerLayout:P!=null?P:"popup",value:a,viewProps:c.viewProps})}};class ac extends r{constructor(i){super(i),this.emitter_=new v,this.controller_.valueController.value.emitter.on("change",a=>{this.emitter_.emit("change",{event:new l(this,a.rawValue)})})}get label(){return this.controller_.props.get("label")}set label(i){this.controller_.props.set("label",i)}get options(){return this.controller_.valueController.props.get("options")}set options(i){this.controller_.valueController.props.set("options",i)}get value(){return this.controller_.valueController.value.rawValue}set value(i){this.controller_.valueController.value.rawValue=i}on(i,a){const u=a.bind(this);return this.emitter_.on(i,b=>{u(b.event)}),this}}class lc extends r{constructor(i){super(i),this.emitter_=new v,this.controller_.valueController.value.emitter.on("change",a=>{this.emitter_.emit("change",{event:new l(this,a.rawValue)})})}get label(){return this.controller_.props.get("label")}set label(i){this.controller_.props.set("label",i)}get maxValue(){return this.controller_.valueController.sliderController.props.get("maxValue")}set maxValue(i){this.controller_.valueController.sliderController.props.set("maxValue",i)}get minValue(){return this.controller_.valueController.sliderController.props.get("minValue")}set minValue(i){this.controller_.valueController.sliderController.props.set("minValue",i)}get value(){return this.controller_.valueController.value.rawValue}set value(i){this.controller_.valueController.value.rawValue=i}on(i,a){const u=a.bind(this);return this.emitter_.on(i,b=>{u(b.event)}),this}}class cc extends r{constructor(i){super(i),this.emitter_=new v,this.controller_.valueController.value.emitter.on("change",a=>{this.emitter_.emit("change",{event:new l(this,a.rawValue)})})}get label(){return this.controller_.props.get("label")}set label(i){this.controller_.props.set("label",i)}get formatter(){return this.controller_.valueController.props.get("formatter")}set formatter(i){this.controller_.valueController.props.set("formatter",i)}get value(){return this.controller_.valueController.value.rawValue}set value(i){this.controller_.valueController.value.rawValue=i}on(i,a){const u=a.bind(this);return this.emitter_.on(i,b=>{u(b.event)}),this}}const Af=function(){return{id:"list",type:"blade",accept(c){const i=at,a=Tt(c,{options:i.required.custom(is),value:i.required.raw,view:i.required.constant("list"),label:i.optional.string});return a?{params:a}:null},controller(c){const i=new ur(Ml(c.params.options)),a=U(c.params.value,{constraint:i}),u=new dr(c.document,{props:new X({options:i.values.value("options")}),value:a,viewProps:c.viewProps});return new Me(c.document,{blade:c.blade,props:X.fromObject({label:c.params.label}),valueController:u})},api(c){return!(c.controller instanceof Me)||!(c.controller.valueController instanceof dr)?null:new ac(c.controller)}}}();function Pf(c){return c.reduce((i,a)=>Object.assign(i,{[a.presetKey]:a.read()}),{})}function Lf(c,i){c.forEach(a=>{const u=i[a.target.presetKey];u!==void 0&&a.writer(a.target,a.reader(u))})}class Rf extends W{constructor(i,a){super(i,a)}get element(){return this.controller_.view.element}importPreset(i){const a=this.controller_.rackController.rack.find(Ne).map(u=>u.binding);Lf(a,i),this.refresh()}exportPreset(){const i=this.controller_.rackController.rack.find(Ne).map(a=>a.binding.target);return Pf(i)}refresh(){this.controller_.rackController.rack.find(Ne).forEach(i=>{i.binding.read()}),this.controller_.rackController.rack.find(rn).forEach(i=>{i.binding.read()})}}class Df extends sn{constructor(i,a){super(i,{expanded:a.expanded,blade:a.blade,props:a.props,root:!0,viewProps:a.viewProps})}}const If={id:"slider",type:"blade",accept(c){const i=at,a=Tt(c,{max:i.required.number,min:i.required.number,view:i.required.constant("slider"),format:i.optional.function,label:i.optional.string,value:i.optional.number});return a?{params:a}:null},controller(c){var i,a;const u=(i=c.params.value)!==null&&i!==void 0?i:0,b=new gi({max:c.params.max,min:c.params.min}),P=new _o(c.document,{baseStep:1,parser:mn,sliderProps:new X({maxValue:b.values.value("max"),minValue:b.values.value("min")}),textProps:X.fromObject({draggingScale:_i(void 0,u),formatter:(a=c.params.format)!==null&&a!==void 0?a:Md}),value:U(u,{constraint:b}),viewProps:c.viewProps});return new Me(c.document,{blade:c.blade,props:X.fromObject({label:c.params.label}),valueController:P})},api(c){return!(c.controller instanceof Me)||!(c.controller.valueController instanceof _o)?null:new lc(c.controller)}},Nf=function(){return{id:"text",type:"blade",accept(c){const i=at,a=Tt(c,{parse:i.required.function,value:i.required.raw,view:i.required.constant("text"),format:i.optional.function,label:i.optional.string});return a?{params:a}:null},controller(c){var i;const a=new es(c.document,{parser:c.params.parse,props:X.fromObject({formatter:(i=c.params.format)!==null&&i!==void 0?i:u=>String(u)}),value:U(c.params.value),viewProps:c.viewProps});return new Me(c.document,{blade:c.blade,props:X.fromObject({label:c.params.label}),valueController:a})},api(c){return!(c.controller instanceof Me)||!(c.controller.valueController instanceof es)?null:new cc(c.controller)}}}();function Ff(c){const i=c.createElement("div");return i.classList.add(M("dfw")()),c.body&&c.body.appendChild(i),i}function hc(c,i,a){if(c.querySelector(`style[data-tp-style=${i}]`))return;const u=c.createElement("style");u.dataset.tpStyle=i,u.textContent=a,c.head.appendChild(u)}class kf extends Rf{constructor(i){var a,u;const b=i!=null?i:{},P=(a=b.document)!==null&&a!==void 0?a:L(),B=yf(),it=new Df(P,{expanded:b.expanded,blade:ft(),props:X.fromObject({title:b.title}),viewProps:Ot.create()});super(it,B),this.pool_=B,this.containerElem_=(u=b.container)!==null&&u!==void 0?u:Ff(P),this.containerElem_.appendChild(this.element),this.doc_=P,this.usesDefaultWrapper_=!b.container,this.setUpDefaultPlugins_()}get document(){if(!this.doc_)throw w.alreadyDisposed();return this.doc_}dispose(){const i=this.containerElem_;if(!i)throw w.alreadyDisposed();if(this.usesDefaultWrapper_){const a=i.parentElement;a&&a.removeChild(i)}this.containerElem_=null,this.doc_=null,super.dispose()}registerPlugin(i){("plugin"in i?[i.plugin]:"plugins"in i?i.plugins:[]).forEach(u=>{this.pool_.register(u),this.embedPluginStyle_(u)})}embedPluginStyle_(i){i.css&&hc(this.document,`plugin-${i.id}`,i.css)}setUpDefaultPlugins_(){hc(this.document,"default",'.tp-tbiv_b,.tp-coltxtv_ms,.tp-ckbv_i,.tp-rotv_b,.tp-fldv_b,.tp-mllv_i,.tp-sglv_i,.tp-grlv_g,.tp-txtv_i,.tp-p2dpv_p,.tp-colswv_sw,.tp-p2dv_b,.tp-btnv_b,.tp-lstv_s{-webkit-appearance:none;-moz-appearance:none;appearance:none;background-color:rgba(0,0,0,0);border-width:0;font-family:inherit;font-size:inherit;font-weight:inherit;margin:0;outline:none;padding:0}.tp-p2dv_b,.tp-btnv_b,.tp-lstv_s{background-color:var(--btn-bg);border-radius:var(--elm-br);color:var(--btn-fg);cursor:pointer;display:block;font-weight:bold;height:var(--bld-us);line-height:var(--bld-us);overflow:hidden;text-overflow:ellipsis;white-space:nowrap}.tp-p2dv_b:hover,.tp-btnv_b:hover,.tp-lstv_s:hover{background-color:var(--btn-bg-h)}.tp-p2dv_b:focus,.tp-btnv_b:focus,.tp-lstv_s:focus{background-color:var(--btn-bg-f)}.tp-p2dv_b:active,.tp-btnv_b:active,.tp-lstv_s:active{background-color:var(--btn-bg-a)}.tp-p2dv_b:disabled,.tp-btnv_b:disabled,.tp-lstv_s:disabled{opacity:.5}.tp-txtv_i,.tp-p2dpv_p,.tp-colswv_sw{background-color:var(--in-bg);border-radius:var(--elm-br);box-sizing:border-box;color:var(--in-fg);font-family:inherit;height:var(--bld-us);line-height:var(--bld-us);min-width:0;width:100%}.tp-txtv_i:hover,.tp-p2dpv_p:hover,.tp-colswv_sw:hover{background-color:var(--in-bg-h)}.tp-txtv_i:focus,.tp-p2dpv_p:focus,.tp-colswv_sw:focus{background-color:var(--in-bg-f)}.tp-txtv_i:active,.tp-p2dpv_p:active,.tp-colswv_sw:active{background-color:var(--in-bg-a)}.tp-txtv_i:disabled,.tp-p2dpv_p:disabled,.tp-colswv_sw:disabled{opacity:.5}.tp-mllv_i,.tp-sglv_i,.tp-grlv_g{background-color:var(--mo-bg);border-radius:var(--elm-br);box-sizing:border-box;color:var(--mo-fg);height:var(--bld-us);scrollbar-color:currentColor rgba(0,0,0,0);scrollbar-width:thin;width:100%}.tp-mllv_i::-webkit-scrollbar,.tp-sglv_i::-webkit-scrollbar,.tp-grlv_g::-webkit-scrollbar{height:8px;width:8px}.tp-mllv_i::-webkit-scrollbar-corner,.tp-sglv_i::-webkit-scrollbar-corner,.tp-grlv_g::-webkit-scrollbar-corner{background-color:rgba(0,0,0,0)}.tp-mllv_i::-webkit-scrollbar-thumb,.tp-sglv_i::-webkit-scrollbar-thumb,.tp-grlv_g::-webkit-scrollbar-thumb{background-clip:padding-box;background-color:currentColor;border:rgba(0,0,0,0) solid 2px;border-radius:4px}.tp-rotv{--font-family: var(--tp-font-family, Roboto Mono, Source Code Pro, Menlo, Courier, monospace);--bs-br: var(--tp-base-border-radius, 6px);--cnt-h-p: var(--tp-container-horizontal-padding, 4px);--cnt-v-p: var(--tp-container-vertical-padding, 4px);--elm-br: var(--tp-element-border-radius, 2px);--bld-s: var(--tp-blade-spacing, 4px);--bld-us: var(--tp-blade-unit-size, 20px);--bs-bg: var(--tp-base-background-color, hsl(230, 7%, 17%));--bs-sh: var(--tp-base-shadow-color, rgba(0, 0, 0, 0.2));--btn-bg: var(--tp-button-background-color, hsl(230, 7%, 70%));--btn-bg-a: var(--tp-button-background-color-active, #d6d7db);--btn-bg-f: var(--tp-button-background-color-focus, #c8cad0);--btn-bg-h: var(--tp-button-background-color-hover, #bbbcc4);--btn-fg: var(--tp-button-foreground-color, hsl(230, 7%, 17%));--cnt-bg: var(--tp-container-background-color, rgba(187, 188, 196, 0.1));--cnt-bg-a: var(--tp-container-background-color-active, rgba(187, 188, 196, 0.25));--cnt-bg-f: var(--tp-container-background-color-focus, rgba(187, 188, 196, 0.2));--cnt-bg-h: var(--tp-container-background-color-hover, rgba(187, 188, 196, 0.15));--cnt-fg: var(--tp-container-foreground-color, hsl(230, 7%, 75%));--in-bg: var(--tp-input-background-color, rgba(187, 188, 196, 0.1));--in-bg-a: var(--tp-input-background-color-active, rgba(187, 188, 196, 0.25));--in-bg-f: var(--tp-input-background-color-focus, rgba(187, 188, 196, 0.2));--in-bg-h: var(--tp-input-background-color-hover, rgba(187, 188, 196, 0.15));--in-fg: var(--tp-input-foreground-color, hsl(230, 7%, 75%));--lbl-fg: var(--tp-label-foreground-color, rgba(187, 188, 196, 0.7));--mo-bg: var(--tp-monitor-background-color, rgba(0, 0, 0, 0.2));--mo-fg: var(--tp-monitor-foreground-color, rgba(187, 188, 196, 0.7));--grv-fg: var(--tp-groove-foreground-color, rgba(187, 188, 196, 0.1))}.tp-rotv_c>.tp-cntv.tp-v-lst,.tp-tabv_c .tp-brkv>.tp-cntv.tp-v-lst,.tp-fldv_c>.tp-cntv.tp-v-lst{margin-bottom:calc(-1*var(--cnt-v-p))}.tp-rotv_c>.tp-fldv.tp-v-lst .tp-fldv_c,.tp-tabv_c .tp-brkv>.tp-fldv.tp-v-lst .tp-fldv_c,.tp-fldv_c>.tp-fldv.tp-v-lst .tp-fldv_c{border-bottom-left-radius:0}.tp-rotv_c>.tp-fldv.tp-v-lst .tp-fldv_b,.tp-tabv_c .tp-brkv>.tp-fldv.tp-v-lst .tp-fldv_b,.tp-fldv_c>.tp-fldv.tp-v-lst .tp-fldv_b{border-bottom-left-radius:0}.tp-rotv_c>*:not(.tp-v-fst),.tp-tabv_c .tp-brkv>*:not(.tp-v-fst),.tp-fldv_c>*:not(.tp-v-fst){margin-top:var(--bld-s)}.tp-rotv_c>.tp-sprv:not(.tp-v-fst),.tp-tabv_c .tp-brkv>.tp-sprv:not(.tp-v-fst),.tp-fldv_c>.tp-sprv:not(.tp-v-fst),.tp-rotv_c>.tp-cntv:not(.tp-v-fst),.tp-tabv_c .tp-brkv>.tp-cntv:not(.tp-v-fst),.tp-fldv_c>.tp-cntv:not(.tp-v-fst){margin-top:var(--cnt-v-p)}.tp-rotv_c>.tp-sprv+*:not(.tp-v-hidden),.tp-tabv_c .tp-brkv>.tp-sprv+*:not(.tp-v-hidden),.tp-fldv_c>.tp-sprv+*:not(.tp-v-hidden),.tp-rotv_c>.tp-cntv+*:not(.tp-v-hidden),.tp-tabv_c .tp-brkv>.tp-cntv+*:not(.tp-v-hidden),.tp-fldv_c>.tp-cntv+*:not(.tp-v-hidden){margin-top:var(--cnt-v-p)}.tp-rotv_c>.tp-sprv:not(.tp-v-hidden)+.tp-sprv,.tp-tabv_c .tp-brkv>.tp-sprv:not(.tp-v-hidden)+.tp-sprv,.tp-fldv_c>.tp-sprv:not(.tp-v-hidden)+.tp-sprv,.tp-rotv_c>.tp-cntv:not(.tp-v-hidden)+.tp-cntv,.tp-tabv_c .tp-brkv>.tp-cntv:not(.tp-v-hidden)+.tp-cntv,.tp-fldv_c>.tp-cntv:not(.tp-v-hidden)+.tp-cntv{margin-top:0}.tp-tabv_c .tp-brkv>.tp-cntv,.tp-fldv_c>.tp-cntv{margin-left:4px}.tp-tabv_c .tp-brkv>.tp-fldv>.tp-fldv_b,.tp-fldv_c>.tp-fldv>.tp-fldv_b{border-top-left-radius:var(--elm-br);border-bottom-left-radius:var(--elm-br)}.tp-tabv_c .tp-brkv>.tp-fldv.tp-fldv-expanded>.tp-fldv_b,.tp-fldv_c>.tp-fldv.tp-fldv-expanded>.tp-fldv_b{border-bottom-left-radius:0}.tp-tabv_c .tp-brkv .tp-fldv>.tp-fldv_c,.tp-fldv_c .tp-fldv>.tp-fldv_c{border-bottom-left-radius:var(--elm-br)}.tp-tabv_c .tp-brkv>.tp-cntv+.tp-fldv>.tp-fldv_b,.tp-fldv_c>.tp-cntv+.tp-fldv>.tp-fldv_b{border-top-left-radius:0}.tp-tabv_c .tp-brkv>.tp-cntv+.tp-tabv>.tp-tabv_t,.tp-fldv_c>.tp-cntv+.tp-tabv>.tp-tabv_t{border-top-left-radius:0}.tp-tabv_c .tp-brkv>.tp-tabv>.tp-tabv_t,.tp-fldv_c>.tp-tabv>.tp-tabv_t{border-top-left-radius:var(--elm-br)}.tp-tabv_c .tp-brkv .tp-tabv>.tp-tabv_c,.tp-fldv_c .tp-tabv>.tp-tabv_c{border-bottom-left-radius:var(--elm-br)}.tp-rotv_b,.tp-fldv_b{background-color:var(--cnt-bg);color:var(--cnt-fg);cursor:pointer;display:block;height:calc(var(--bld-us) + 4px);line-height:calc(var(--bld-us) + 4px);overflow:hidden;padding-left:var(--cnt-h-p);padding-right:calc(4px + var(--bld-us) + var(--cnt-h-p));position:relative;text-align:left;text-overflow:ellipsis;white-space:nowrap;width:100%;transition:border-radius .2s ease-in-out .2s}.tp-rotv_b:hover,.tp-fldv_b:hover{background-color:var(--cnt-bg-h)}.tp-rotv_b:focus,.tp-fldv_b:focus{background-color:var(--cnt-bg-f)}.tp-rotv_b:active,.tp-fldv_b:active{background-color:var(--cnt-bg-a)}.tp-rotv_b:disabled,.tp-fldv_b:disabled{opacity:.5}.tp-rotv_m,.tp-fldv_m{background:linear-gradient(to left, var(--cnt-fg), var(--cnt-fg) 2px, transparent 2px, transparent 4px, var(--cnt-fg) 4px);border-radius:2px;bottom:0;content:"";display:block;height:6px;right:calc(var(--cnt-h-p) + (var(--bld-us) + 4px - 6px)/2 - 2px);margin:auto;opacity:.5;position:absolute;top:0;transform:rotate(90deg);transition:transform .2s ease-in-out;width:6px}.tp-rotv.tp-rotv-expanded .tp-rotv_m,.tp-fldv.tp-fldv-expanded>.tp-fldv_b>.tp-fldv_m{transform:none}.tp-rotv_c,.tp-fldv_c{box-sizing:border-box;height:0;opacity:0;overflow:hidden;padding-bottom:0;padding-top:0;position:relative;transition:height .2s ease-in-out,opacity .2s linear,padding .2s ease-in-out}.tp-rotv.tp-rotv-cpl:not(.tp-rotv-expanded) .tp-rotv_c,.tp-fldv.tp-fldv-cpl:not(.tp-fldv-expanded)>.tp-fldv_c{display:none}.tp-rotv.tp-rotv-expanded .tp-rotv_c,.tp-fldv.tp-fldv-expanded>.tp-fldv_c{opacity:1;padding-bottom:var(--cnt-v-p);padding-top:var(--cnt-v-p);transform:none;overflow:visible;transition:height .2s ease-in-out,opacity .2s linear .2s,padding .2s ease-in-out}.tp-lstv,.tp-coltxtv_m{position:relative}.tp-lstv_s{padding:0 20px 0 4px;width:100%}.tp-lstv_m,.tp-coltxtv_mm{bottom:0;margin:auto;pointer-events:none;position:absolute;right:2px;top:0}.tp-lstv_m svg,.tp-coltxtv_mm svg{bottom:0;height:16px;margin:auto;position:absolute;right:0;top:0;width:16px}.tp-lstv_m svg path,.tp-coltxtv_mm svg path{fill:currentColor}.tp-pndtxtv,.tp-coltxtv_w{display:flex}.tp-pndtxtv_a,.tp-coltxtv_c{width:100%}.tp-pndtxtv_a+.tp-pndtxtv_a,.tp-coltxtv_c+.tp-pndtxtv_a,.tp-pndtxtv_a+.tp-coltxtv_c,.tp-coltxtv_c+.tp-coltxtv_c{margin-left:2px}.tp-btnv_b{width:100%}.tp-btnv_t{text-align:center}.tp-ckbv_l{display:block;position:relative}.tp-ckbv_i{left:0;opacity:0;position:absolute;top:0}.tp-ckbv_w{background-color:var(--in-bg);border-radius:var(--elm-br);cursor:pointer;display:block;height:var(--bld-us);position:relative;width:var(--bld-us)}.tp-ckbv_w svg{bottom:0;display:block;height:16px;left:0;margin:auto;opacity:0;position:absolute;right:0;top:0;width:16px}.tp-ckbv_w svg path{fill:none;stroke:var(--in-fg);stroke-width:2}.tp-ckbv_i:hover+.tp-ckbv_w{background-color:var(--in-bg-h)}.tp-ckbv_i:focus+.tp-ckbv_w{background-color:var(--in-bg-f)}.tp-ckbv_i:active+.tp-ckbv_w{background-color:var(--in-bg-a)}.tp-ckbv_i:checked+.tp-ckbv_w svg{opacity:1}.tp-ckbv.tp-v-disabled .tp-ckbv_w{opacity:.5}.tp-colv{position:relative}.tp-colv_h{display:flex}.tp-colv_s{flex-grow:0;flex-shrink:0;width:var(--bld-us)}.tp-colv_t{flex:1;margin-left:4px}.tp-colv_p{height:0;margin-top:0;opacity:0;overflow:hidden;transition:height .2s ease-in-out,opacity .2s linear,margin .2s ease-in-out}.tp-colv.tp-colv-cpl .tp-colv_p{overflow:visible}.tp-colv.tp-colv-expanded .tp-colv_p{margin-top:var(--bld-s);opacity:1}.tp-colv .tp-popv{left:calc(-1*var(--cnt-h-p));right:calc(-1*var(--cnt-h-p));top:var(--bld-us)}.tp-colpv_h,.tp-colpv_ap{margin-left:6px;margin-right:6px}.tp-colpv_h{margin-top:var(--bld-s)}.tp-colpv_rgb{display:flex;margin-top:var(--bld-s);width:100%}.tp-colpv_a{display:flex;margin-top:var(--cnt-v-p);padding-top:calc(var(--cnt-v-p) + 2px);position:relative}.tp-colpv_a::before{background-color:var(--grv-fg);content:"";height:2px;left:calc(-1*var(--cnt-h-p));position:absolute;right:calc(-1*var(--cnt-h-p));top:0}.tp-colpv.tp-v-disabled .tp-colpv_a::before{opacity:.5}.tp-colpv_ap{align-items:center;display:flex;flex:3}.tp-colpv_at{flex:1;margin-left:4px}.tp-svpv{border-radius:var(--elm-br);outline:none;overflow:hidden;position:relative}.tp-svpv.tp-v-disabled{opacity:.5}.tp-svpv_c{cursor:crosshair;display:block;height:calc(var(--bld-us)*4);width:100%}.tp-svpv_m{border-radius:100%;border:rgba(255,255,255,.75) solid 2px;box-sizing:border-box;filter:drop-shadow(0 0 1px rgba(0, 0, 0, 0.3));height:12px;margin-left:-6px;margin-top:-6px;pointer-events:none;position:absolute;width:12px}.tp-svpv:focus .tp-svpv_m{border-color:#fff}.tp-hplv{cursor:pointer;height:var(--bld-us);outline:none;position:relative}.tp-hplv.tp-v-disabled{opacity:.5}.tp-hplv_c{background-image:url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAEAAAAABCAYAAABubagXAAAAQ0lEQVQoU2P8z8Dwn0GCgQEDi2OK/RBgYHjBgIpfovFh8j8YBIgzFGQxuqEgPhaDOT5gOhPkdCxOZeBg+IDFZZiGAgCaSSMYtcRHLgAAAABJRU5ErkJggg==);background-position:left top;background-repeat:no-repeat;background-size:100% 100%;border-radius:2px;display:block;height:4px;left:0;margin-top:-2px;position:absolute;top:50%;width:100%}.tp-hplv_m{border-radius:var(--elm-br);border:rgba(255,255,255,.75) solid 2px;box-shadow:0 0 2px rgba(0,0,0,.1);box-sizing:border-box;height:12px;left:50%;margin-left:-6px;margin-top:-6px;pointer-events:none;position:absolute;top:50%;width:12px}.tp-hplv:focus .tp-hplv_m{border-color:#fff}.tp-aplv{cursor:pointer;height:var(--bld-us);outline:none;position:relative;width:100%}.tp-aplv.tp-v-disabled{opacity:.5}.tp-aplv_b{background-color:#fff;background-image:linear-gradient(to top right, #ddd 25%, transparent 25%, transparent 75%, #ddd 75%),linear-gradient(to top right, #ddd 25%, transparent 25%, transparent 75%, #ddd 75%);background-size:4px 4px;background-position:0 0,2px 2px;border-radius:2px;display:block;height:4px;left:0;margin-top:-2px;overflow:hidden;position:absolute;top:50%;width:100%}.tp-aplv_c{bottom:0;left:0;position:absolute;right:0;top:0}.tp-aplv_m{background-color:#fff;background-image:linear-gradient(to top right, #ddd 25%, transparent 25%, transparent 75%, #ddd 75%),linear-gradient(to top right, #ddd 25%, transparent 25%, transparent 75%, #ddd 75%);background-size:12px 12px;background-position:0 0,6px 6px;border-radius:var(--elm-br);box-shadow:0 0 2px rgba(0,0,0,.1);height:12px;left:50%;margin-left:-6px;margin-top:-6px;overflow:hidden;pointer-events:none;position:absolute;top:50%;width:12px}.tp-aplv_p{border-radius:var(--elm-br);border:rgba(255,255,255,.75) solid 2px;box-sizing:border-box;bottom:0;left:0;position:absolute;right:0;top:0}.tp-aplv:focus .tp-aplv_p{border-color:#fff}.tp-colswv{background-color:#fff;background-image:linear-gradient(to top right, #ddd 25%, transparent 25%, transparent 75%, #ddd 75%),linear-gradient(to top right, #ddd 25%, transparent 25%, transparent 75%, #ddd 75%);background-size:10px 10px;background-position:0 0,5px 5px;border-radius:var(--elm-br);overflow:hidden}.tp-colswv.tp-v-disabled{opacity:.5}.tp-colswv_sw{border-radius:0}.tp-colswv_b{-webkit-appearance:none;-moz-appearance:none;appearance:none;background-color:rgba(0,0,0,0);border-width:0;cursor:pointer;display:block;height:var(--bld-us);left:0;margin:0;outline:none;padding:0;position:absolute;top:0;width:var(--bld-us)}.tp-colswv_b:focus::after{border:rgba(255,255,255,.75) solid 2px;border-radius:var(--elm-br);bottom:0;content:"";display:block;left:0;position:absolute;right:0;top:0}.tp-coltxtv{display:flex;width:100%}.tp-coltxtv_m{margin-right:4px}.tp-coltxtv_ms{border-radius:var(--elm-br);color:var(--lbl-fg);cursor:pointer;height:var(--bld-us);line-height:var(--bld-us);padding:0 18px 0 4px}.tp-coltxtv_ms:hover{background-color:var(--in-bg-h)}.tp-coltxtv_ms:focus{background-color:var(--in-bg-f)}.tp-coltxtv_ms:active{background-color:var(--in-bg-a)}.tp-coltxtv_mm{color:var(--lbl-fg)}.tp-coltxtv.tp-v-disabled .tp-coltxtv_mm{opacity:.5}.tp-coltxtv_w{flex:1}.tp-dfwv{position:absolute;top:8px;right:8px;width:256px}.tp-fldv{position:relative}.tp-fldv.tp-fldv-not .tp-fldv_b{display:none}.tp-fldv_t{padding-left:4px}.tp-fldv_b:disabled .tp-fldv_m{display:none}.tp-fldv_c{padding-left:4px}.tp-fldv_i{bottom:0;color:var(--cnt-bg);left:0;overflow:hidden;position:absolute;top:calc(var(--bld-us) + 4px);width:var(--bs-br)}.tp-fldv_i::before{background-color:currentColor;bottom:0;content:"";left:0;position:absolute;top:0;width:4px}.tp-fldv_b:hover+.tp-fldv_i{color:var(--cnt-bg-h)}.tp-fldv_b:focus+.tp-fldv_i{color:var(--cnt-bg-f)}.tp-fldv_b:active+.tp-fldv_i{color:var(--cnt-bg-a)}.tp-fldv.tp-v-disabled>.tp-fldv_i{opacity:.5}.tp-grlv{position:relative}.tp-grlv_g{display:block;height:calc(var(--bld-us)*3)}.tp-grlv_g polyline{fill:none;stroke:var(--mo-fg);stroke-linejoin:round}.tp-grlv_t{margin-top:-4px;transition:left .05s,top .05s;visibility:hidden}.tp-grlv_t.tp-grlv_t-a{visibility:visible}.tp-grlv_t.tp-grlv_t-in{transition:none}.tp-grlv.tp-v-disabled .tp-grlv_g{opacity:.5}.tp-grlv .tp-ttv{background-color:var(--mo-fg)}.tp-grlv .tp-ttv::before{border-top-color:var(--mo-fg)}.tp-lblv{align-items:center;display:flex;line-height:1.3;padding-left:var(--cnt-h-p);padding-right:var(--cnt-h-p)}.tp-lblv.tp-lblv-nol{display:block}.tp-lblv_l{color:var(--lbl-fg);flex:1;-webkit-hyphens:auto;hyphens:auto;overflow:hidden;padding-left:4px;padding-right:16px}.tp-lblv.tp-v-disabled .tp-lblv_l{opacity:.5}.tp-lblv.tp-lblv-nol .tp-lblv_l{display:none}.tp-lblv_v{align-self:flex-start;flex-grow:0;flex-shrink:0;width:160px}.tp-lblv.tp-lblv-nol .tp-lblv_v{width:100%}.tp-lstv_s{padding:0 20px 0 4px;width:100%}.tp-lstv_m{color:var(--btn-fg)}.tp-sglv_i{padding:0 4px}.tp-sglv.tp-v-disabled .tp-sglv_i{opacity:.5}.tp-mllv_i{display:block;height:calc(var(--bld-us)*3);line-height:var(--bld-us);padding:0 4px;resize:none;white-space:pre}.tp-mllv.tp-v-disabled .tp-mllv_i{opacity:.5}.tp-p2dv{position:relative}.tp-p2dv_h{display:flex}.tp-p2dv_b{height:var(--bld-us);margin-right:4px;position:relative;width:var(--bld-us)}.tp-p2dv_b svg{display:block;height:16px;left:50%;margin-left:-8px;margin-top:-8px;position:absolute;top:50%;width:16px}.tp-p2dv_b svg path{stroke:currentColor;stroke-width:2}.tp-p2dv_b svg circle{fill:currentColor}.tp-p2dv_t{flex:1}.tp-p2dv_p{height:0;margin-top:0;opacity:0;overflow:hidden;transition:height .2s ease-in-out,opacity .2s linear,margin .2s ease-in-out}.tp-p2dv.tp-p2dv-expanded .tp-p2dv_p{margin-top:var(--bld-s);opacity:1}.tp-p2dv .tp-popv{left:calc(-1*var(--cnt-h-p));right:calc(-1*var(--cnt-h-p));top:var(--bld-us)}.tp-p2dpv{padding-left:calc(var(--bld-us) + 4px)}.tp-p2dpv_p{cursor:crosshair;height:0;overflow:hidden;padding-bottom:100%;position:relative}.tp-p2dpv.tp-v-disabled .tp-p2dpv_p{opacity:.5}.tp-p2dpv_g{display:block;height:100%;left:0;pointer-events:none;position:absolute;top:0;width:100%}.tp-p2dpv_ax{opacity:.1;stroke:var(--in-fg);stroke-dasharray:1}.tp-p2dpv_l{opacity:.5;stroke:var(--in-fg);stroke-dasharray:1}.tp-p2dpv_m{border:var(--in-fg) solid 1px;border-radius:50%;box-sizing:border-box;height:4px;margin-left:-2px;margin-top:-2px;position:absolute;width:4px}.tp-p2dpv_p:focus .tp-p2dpv_m{background-color:var(--in-fg);border-width:0}.tp-popv{background-color:var(--bs-bg);border-radius:6px;box-shadow:0 2px 4px var(--bs-sh);display:none;max-width:168px;padding:var(--cnt-v-p) var(--cnt-h-p);position:absolute;visibility:hidden;z-index:1000}.tp-popv.tp-popv-v{display:block;visibility:visible}.tp-sprv_r{background-color:var(--grv-fg);border-width:0;display:block;height:2px;margin:0;width:100%}.tp-sprv.tp-v-disabled .tp-sprv_r{opacity:.5}.tp-sldv.tp-v-disabled{opacity:.5}.tp-sldv_t{box-sizing:border-box;cursor:pointer;height:var(--bld-us);margin:0 6px;outline:none;position:relative}.tp-sldv_t::before{background-color:var(--in-bg);border-radius:1px;bottom:0;content:"";display:block;height:2px;left:0;margin:auto;position:absolute;right:0;top:0}.tp-sldv_k{height:100%;left:0;position:absolute;top:0}.tp-sldv_k::before{background-color:var(--in-fg);border-radius:1px;bottom:0;content:"";display:block;height:2px;left:0;margin-bottom:auto;margin-top:auto;position:absolute;right:0;top:0}.tp-sldv_k::after{background-color:var(--btn-bg);border-radius:var(--elm-br);bottom:0;content:"";display:block;height:12px;margin-bottom:auto;margin-top:auto;position:absolute;right:-6px;top:0;width:12px}.tp-sldv_t:hover .tp-sldv_k::after{background-color:var(--btn-bg-h)}.tp-sldv_t:focus .tp-sldv_k::after{background-color:var(--btn-bg-f)}.tp-sldv_t:active .tp-sldv_k::after{background-color:var(--btn-bg-a)}.tp-sldtxtv{display:flex}.tp-sldtxtv_s{flex:2}.tp-sldtxtv_t{flex:1;margin-left:4px}.tp-tabv{position:relative}.tp-tabv_t{align-items:flex-end;color:var(--cnt-bg);display:flex;overflow:hidden;position:relative}.tp-tabv_t:hover{color:var(--cnt-bg-h)}.tp-tabv_t:has(*:focus){color:var(--cnt-bg-f)}.tp-tabv_t:has(*:active){color:var(--cnt-bg-a)}.tp-tabv_t::before{background-color:currentColor;bottom:0;content:"";height:2px;left:0;pointer-events:none;position:absolute;right:0}.tp-tabv.tp-v-disabled .tp-tabv_t::before{opacity:.5}.tp-tabv.tp-tabv-nop .tp-tabv_t{height:calc(var(--bld-us) + 4px);position:relative}.tp-tabv.tp-tabv-nop .tp-tabv_t::before{background-color:var(--cnt-bg);bottom:0;content:"";height:2px;left:0;position:absolute;right:0}.tp-tabv_c{padding-bottom:var(--cnt-v-p);padding-left:4px;padding-top:var(--cnt-v-p)}.tp-tabv_i{bottom:0;color:var(--cnt-bg);left:0;overflow:hidden;position:absolute;top:calc(var(--bld-us) + 4px);width:var(--bs-br)}.tp-tabv_i::before{background-color:currentColor;bottom:0;content:"";left:0;position:absolute;top:0;width:4px}.tp-tabv_t:hover+.tp-tabv_i{color:var(--cnt-bg-h)}.tp-tabv_t:has(*:focus)+.tp-tabv_i{color:var(--cnt-bg-f)}.tp-tabv_t:has(*:active)+.tp-tabv_i{color:var(--cnt-bg-a)}.tp-tabv.tp-v-disabled>.tp-tabv_i{opacity:.5}.tp-tbiv{flex:1;min-width:0;position:relative}.tp-tbiv+.tp-tbiv{margin-left:2px}.tp-tbiv+.tp-tbiv.tp-v-disabled::before{opacity:.5}.tp-tbiv_b{display:block;padding-left:calc(var(--cnt-h-p) + 4px);padding-right:calc(var(--cnt-h-p) + 4px);position:relative;width:100%}.tp-tbiv_b:disabled{opacity:.5}.tp-tbiv_b::before{background-color:var(--cnt-bg);bottom:2px;content:"";left:0;pointer-events:none;position:absolute;right:0;top:0}.tp-tbiv_b:hover::before{background-color:var(--cnt-bg-h)}.tp-tbiv_b:focus::before{background-color:var(--cnt-bg-f)}.tp-tbiv_b:active::before{background-color:var(--cnt-bg-a)}.tp-tbiv_t{color:var(--cnt-fg);height:calc(var(--bld-us) + 4px);line-height:calc(var(--bld-us) + 4px);opacity:.5;overflow:hidden;text-overflow:ellipsis}.tp-tbiv.tp-tbiv-sel .tp-tbiv_t{opacity:1}.tp-txtv{position:relative}.tp-txtv_i{padding:0 4px}.tp-txtv.tp-txtv-fst .tp-txtv_i{border-bottom-right-radius:0;border-top-right-radius:0}.tp-txtv.tp-txtv-mid .tp-txtv_i{border-radius:0}.tp-txtv.tp-txtv-lst .tp-txtv_i{border-bottom-left-radius:0;border-top-left-radius:0}.tp-txtv.tp-txtv-num .tp-txtv_i{text-align:right}.tp-txtv.tp-txtv-drg .tp-txtv_i{opacity:.3}.tp-txtv_k{cursor:pointer;height:100%;left:-3px;position:absolute;top:0;width:12px}.tp-txtv_k::before{background-color:var(--in-fg);border-radius:1px;bottom:0;content:"";height:calc(var(--bld-us) - 4px);left:50%;margin-bottom:auto;margin-left:-1px;margin-top:auto;opacity:.1;position:absolute;top:0;transition:border-radius .1s,height .1s,transform .1s,width .1s;width:2px}.tp-txtv_k:hover::before,.tp-txtv.tp-txtv-drg .tp-txtv_k::before{opacity:1}.tp-txtv.tp-txtv-drg .tp-txtv_k::before{border-radius:50%;height:4px;transform:translateX(-1px);width:4px}.tp-txtv_g{bottom:0;display:block;height:8px;left:50%;margin:auto;overflow:visible;pointer-events:none;position:absolute;top:0;visibility:hidden;width:100%}.tp-txtv.tp-txtv-drg .tp-txtv_g{visibility:visible}.tp-txtv_gb{fill:none;stroke:var(--in-fg);stroke-dasharray:1}.tp-txtv_gh{fill:none;stroke:var(--in-fg)}.tp-txtv .tp-ttv{margin-left:6px;visibility:hidden}.tp-txtv.tp-txtv-drg .tp-ttv{visibility:visible}.tp-ttv{background-color:var(--in-fg);border-radius:var(--elm-br);color:var(--bs-bg);padding:2px 4px;pointer-events:none;position:absolute;transform:translate(-50%, -100%)}.tp-ttv::before{border-color:var(--in-fg) rgba(0,0,0,0) rgba(0,0,0,0) rgba(0,0,0,0);border-style:solid;border-width:2px;box-sizing:border-box;content:"";font-size:.9em;height:4px;left:50%;margin-left:-2px;position:absolute;top:100%;width:4px}.tp-rotv{background-color:var(--bs-bg);border-radius:var(--bs-br);box-shadow:0 2px 4px var(--bs-sh);font-family:var(--font-family);font-size:11px;font-weight:500;line-height:1;text-align:left}.tp-rotv_b{border-bottom-left-radius:var(--bs-br);border-bottom-right-radius:var(--bs-br);border-top-left-radius:var(--bs-br);border-top-right-radius:var(--bs-br);padding-left:calc(4px + var(--bld-us) + var(--cnt-h-p));text-align:center}.tp-rotv.tp-rotv-expanded .tp-rotv_b{border-bottom-left-radius:0;border-bottom-right-radius:0}.tp-rotv.tp-rotv-not .tp-rotv_b{display:none}.tp-rotv_b:disabled .tp-rotv_m{display:none}.tp-rotv_c>.tp-fldv.tp-v-lst>.tp-fldv_c{border-bottom-left-radius:var(--bs-br);border-bottom-right-radius:var(--bs-br)}.tp-rotv_c>.tp-fldv.tp-v-lst>.tp-fldv_i{border-bottom-left-radius:var(--bs-br)}.tp-rotv_c>.tp-fldv.tp-v-lst:not(.tp-fldv-expanded)>.tp-fldv_b{border-bottom-left-radius:var(--bs-br);border-bottom-right-radius:var(--bs-br)}.tp-rotv_c .tp-fldv.tp-v-vlst:not(.tp-fldv-expanded)>.tp-fldv_b{border-bottom-right-radius:var(--bs-br)}.tp-rotv.tp-rotv-not .tp-rotv_c>.tp-fldv.tp-v-fst{margin-top:calc(-1*var(--cnt-v-p))}.tp-rotv.tp-rotv-not .tp-rotv_c>.tp-fldv.tp-v-fst>.tp-fldv_b{border-top-left-radius:var(--bs-br);border-top-right-radius:var(--bs-br)}.tp-rotv_c>.tp-tabv.tp-v-lst>.tp-tabv_c{border-bottom-left-radius:var(--bs-br);border-bottom-right-radius:var(--bs-br)}.tp-rotv_c>.tp-tabv.tp-v-lst>.tp-tabv_i{border-bottom-left-radius:var(--bs-br)}.tp-rotv.tp-rotv-not .tp-rotv_c>.tp-tabv.tp-v-fst{margin-top:calc(-1*var(--cnt-v-p))}.tp-rotv.tp-rotv-not .tp-rotv_c>.tp-tabv.tp-v-fst>.tp-tabv_t{border-top-left-radius:var(--bs-br);border-top-right-radius:var(--bs-br)}.tp-rotv.tp-v-disabled,.tp-rotv .tp-v-disabled{pointer-events:none}.tp-rotv.tp-v-hidden,.tp-rotv .tp-v-hidden{display:none}'),this.pool_.getAll().forEach(i=>{this.embedPluginStyle_(i)}),this.registerPlugin({plugins:[If,Af,ol,Nf]})}}const Vf=new n("3.1.7");e.BladeApi=r,e.ButtonApi=x,e.FolderApi=W,e.InputBindingApi=lr,e.ListApi=ac,e.MonitorBindingApi=fi,e.Pane=kf,e.SeparatorApi=ue,e.SliderApi=lc,e.TabApi=il,e.TabPageApi=nl,e.TextApi=cc,e.TpChangeEvent=l,e.VERSION=Vf,Object.defineProperty(e,"__esModule",{value:!0})})})(Bh,Bh.exports);function jy(){const o=Vh;console.log(o);const t=new $t.Group,e=new $t.Group,n=new $t.Group,r={camera:{speed:.1,wiggle:5},material:{color:"#CCCCDD",metal:0,rough:.4,alpha:1,glass:1.15,thick:.58,reflex:.5,clearcoat:0,coatrough:.08,normal:1.43,envInt:10,ior:1,disc:0,ao:1,dither:!0},background:"#232323",lines:"#202030"};function s(){const l=document.querySelector("canvas"),h=new $t.WebGLRenderer({canvas:l,antialias:!0,alpha:!1}),d=new $t.Scene,p=new $t.PerspectiveCamera(45),f=new Wf(p,l);f.target.set(0,0,0),f.rotateSpeed=.2,f.enableZoom=!1,f.enableDamping=!0,f.dampingFactor=.08,f.update(),h.shadowMap.enabled=!0,h.shadowMap.type=$t.PCFShoftShadowMap,h.outputEncoding=$t.sRGBEncoding,p.position.set(0,0,5),d.add(t),d.background=new $t.Color(14939903);let m=0;const g=(F,k=2)=>{const ot={0:Vh,1:xa,2:Hy,3:xa,4:xa}[m];return console.log(F,ot,k),m=m+1,new $t.TextureLoader().load(ot||o,V=>{V.mapping=$t.EquirectangularRefractionMapping,V.anisotropy=h.capabilities.getMaxAnisotropy(),V.magFilter=$t.NearestFilter,V.minFilter=$t.LinearMipmapLinearFilter,V.wrapS=V.wrapT=$t.MirroredRepeatWrapping,V.type=$t.HalfFloatType,V.format=$t.RGBAFormat,V.repeat.set(k,k),V.dispose()})},_=new $t.MeshBasicMaterial({map:g("rainbow",1)}),y=new $t.MeshPhysicalMaterial({aoMap:g("lava"),normalMap:g("lava"),envMap:g("lava"),metalness:g(),rougthness:g(),sheenRoughnessMap:g(),clearcoatMap:g("lava"),displacementMap:g(),displacementScale:.03,color:16777215,emissive:0,dithering:!1,sheen:1,flatShading:!1,combine:$t.AddOperation}),w=()=>{const F=new $t.PlaneGeometry(6,4);new $t.MeshBasicMaterial({map:g("lava",2)});const k=new $t.Mesh(F,_);return k.position.z=-3,k.name="wallpaper",k},S=()=>{new $t.IcosahedronGeometry(1,6),new $t.TorusGeometry(1,.4,32,100),new $t.TorusKnotGeometry(.8,.3,132,16,4,3),new zy().load("/node_modules/three/examples/fonts/optimer_regular.typeface.json",j=>{console.log("123123");const ot=new $t.TextGeometry("I T Z Y",{font:j,size:.9,height:.5,curveSegments:22,bevelEnabled:!0,bevelThickness:.21,bevelSize:.11,bevelOffset:0,bevelSegments:3});ot.computeBoundingBox(),ot.center(),new $t.MeshBasicMaterial;const Y=new $t.Mesh(ot,y);d.add(Y)});const k=new $t.Mesh;return k.rotation.z=90*Math.PI/180,k.name="object3D",k},x=()=>(new $t.HemisphereLight(15658751,11184844,2),new $t.PointLight(16777215,5).position.set(5,5,5),new $t.Group),v=new $t.Clock;function N(){const F=y;F.attenuationDistance=r.material.sheen,F.dithering=r.material.dither,F.metalness=r.material.metal,F.roughness=r.material.rough,F.opacity=r.material.alpha,F.transmission=r.material.glass,F.ior=r.material.ior,F.thickness=r.material.thick,F.reflectivity=r.material.reflex,F.clearcoat=r.material.clearcoat*5,F.clearcoatRoughness=r.material.coatrough,F.envMapIntensity=r.material.envInt,F.displacementScale=r.material.disc*.1,F.aoMapIntensity=r.material.ao,F.normalScale.set(r.material.normal,r.material.normal),F.needsUpdate=!0}const M=()=>{f.update();const F=v.getElapsedTime()*r.camera.speed*2;t.rotation.y=Math.sin(F*r.camera.wiggle)*Math.PI/180*r.camera.wiggle,t.rotation.x=Math.cos(F*r.camera.wiggle)*Math.PI/180*r.camera.wiggle,e.position.x=Math.sin(F*3)*1,e.position.y=Math.cos(F*3)*1,d.background=new $t.Color(r.background),p.lookAt(d.position),p.updateMatrixWorld(),N(),h.render(d,p),requestAnimationFrame(M)},R=()=>{const F=window.innerWidth,k=window.innerHeight;return p.aspect=F/k,p.updateProjectionMatrix(),h.setSize(F,k),null};t.add(w(),n),n.add(S(),e),d.add(x()),M(),R(),window.addEventListener("resize",R,!1)}return Hf.exports.useEffect(()=>{s()},[]),Gf("div",{children:[on("canvas",{}),on("div",{className:"container",children:on("div",{className:"row",children:on("div",{className:"col info",children:on("p",{children:"[Run again to update the textures]"})})})}),on("div",{className:"container",children:on("div",{className:"row footer",children:on("div",{className:"col",children:on("a",{href:"https://victorvergara.co/",target:"_blank",children:on("img",{src:"https://victorvergara.co/2019/src/logo.svg"})})})})})]})}export{jy as default};
